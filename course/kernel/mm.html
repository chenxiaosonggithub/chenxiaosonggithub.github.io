<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>内存管理</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://chenxiaosong.com/stylesheet.css" />
</head>
<body>
<header id="title-block-header">
<!-- sign begin -->
<ul>
<li>作者: 陈孝松</li>
<li><a href="https://chenxiaosong.com/">中文主页: chenxiaosong.com</a></li>
<li><a href="https://chenxiaosong.com/en">英文主页: chenxiaosong.com/en</a></li>
<li><a href="https://chenxiaosong.com/video.html">哔哩哔哩教学视频: 陈孝松</a></li>
<li><a href="https://chenxiaosong.com/course.html">课程: chenxiaosong.com/course</a></li>
<li><a href="https://chenxiaosong.com/blog.html">博客: chenxiaosong.com/blog</a></li>
<li><a href="https://chenxiaosong.com/contribution.html">贡献: chenxiaosong.com/contribution</a></li>
<li>邮箱: <a href="mailto:chenxiaosong@chenxiaosong.com" class="email">chenxiaosong@chenxiaosong.com</a></li>
<li><a href="https://chenxiaosong.com/q.html">QQ交流群: 544216206, 点击查看群介绍</a></li>
</ul>
<!-- sign end -->
<h1 class="title">内存管理</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#内存地址"><span class="toc-section-number">1</span> 内存地址</a></li>
<li><a href="#页"><span class="toc-section-number">2</span> 页</a><ul>
<li><a href="#struct-page"><span class="toc-section-number">2.1</span> <code>struct page</code></a></li>
<li><a href="#两个union"><span class="toc-section-number">2.2</span> 两个<code>union</code></a></li>
<li><a href="#struct-folio"><span class="toc-section-number">2.3</span> <code>struct folio</code></a></li>
<li><a href="#区"><span class="toc-section-number">2.4</span> 区</a></li>
</ul></li>
<li><a href="#内存分配与释放"><span class="toc-section-number">3</span> 内存分配与释放</a><ul>
<li><a href="#函数接口"><span class="toc-section-number">3.1</span> 函数接口</a></li>
<li><a href="#gfp_t"><span class="toc-section-number">3.2</span> <code>gfp_t</code></a><ul>
<li><a href="#行为修饰符"><span class="toc-section-number">3.2.1</span> 行为修饰符</a></li>
<li><a href="#区修饰符"><span class="toc-section-number">3.2.2</span> 区修饰符</a></li>
<li><a href="#页面的移动性和放置提示"><span class="toc-section-number">3.2.3</span> 页面的移动性和放置提示</a></li>
<li><a href="#水位标志修饰符"><span class="toc-section-number">3.2.4</span> 水位标志修饰符</a></li>
<li><a href="#回收修饰符"><span class="toc-section-number">3.2.5</span> 回收修饰符</a></li>
<li><a href="#类型标志"><span class="toc-section-number">3.2.6</span> 类型标志</a></li>
</ul></li>
</ul></li>
<li><a href="#slab"><span class="toc-section-number">4</span> slab</a></li>
<li><a href="#高端内存"><span class="toc-section-number">5</span> 高端内存</a></li>
<li><a href="#每cpu变量"><span class="toc-section-number">6</span> 每CPU变量</a><ul>
<li><a href="#老的方法"><span class="toc-section-number">6.1</span> 老的方法</a></li>
<li><a href="#新的接口"><span class="toc-section-number">6.2</span> 新的接口</a></li>
</ul></li>
<li><a href="#进程地址空间"><span class="toc-section-number">7</span> 进程地址空间</a><ul>
<li><a href="#内存描述符"><span class="toc-section-number">7.1</span> 内存描述符</a></li>
<li><a href="#相关函数"><span class="toc-section-number">7.2</span> 相关函数</a></li>
<li><a href="#虚拟内存区域"><span class="toc-section-number">7.3</span> 虚拟内存区域</a></li>
<li><a href="#vma操作"><span class="toc-section-number">7.4</span> VMA操作</a></li>
<li><a href="#查看内存区域"><span class="toc-section-number">7.5</span> 查看内存区域</a></li>
<li><a href="#内存区域操作函数"><span class="toc-section-number">7.6</span> 内存区域操作函数</a></li>
<li><a href="#页表"><span class="toc-section-number">7.7</span> 页表</a></li>
</ul></li>
<li><a href="#伙伴算法"><span class="toc-section-number">8</span> 伙伴算法</a></li>
</ul>
</nav>
<p><a href="https://chenxiaosong.com/course/kernel/kernel.html">点击跳转到内核课程所有目录</a>。</p>
<p><a href="https://chenxiaosong.com/course/kernel/video.html">点击这里查看配套的教学视频</a>。</p>
<h1 id="内存地址"><span class="header-section-number">1</span> 内存地址</h1>
<p>操作系统是横跨软件和硬件的桥梁，其中内存寻址是操作系统设计的硬件基础之一。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="ex">logical</span>                 linear              physical</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ex">address</span>  +------------+ address  +--------+ address</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ex">--------</span><span class="op">&gt;</span><span class="kw">|</span><span class="ex">segmentation</span><span class="kw">|</span><span class="ex">---------</span><span class="op">&gt;</span><span class="kw">|</span> <span class="ex">paging</span> <span class="kw">|</span><span class="ex">---------</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb1-4" title="4">         <span class="kw">|</span>   <span class="ex">unit</span>     <span class="kw">|</span>          <span class="kw">|</span>  <span class="ex">unit</span>  <span class="kw">|</span></a>
<a class="sourceLine" id="cb1-5" title="5">         <span class="ex">+------------+</span>          +--------+</a></code></pre></div>
<p>三种地址介绍:</p>
<ul>
<li>逻辑地址（logical address）: 由段（segment）和偏移量（offset或displacement）组成。RISC（Reduced Instruction Set Computers）体系结构（如ARM）分段支持有限，在某些支持段的CISC（Complex Instruction Set Computers）体系结构如x86（x86无法绕过分段），Linux内核中，所有的段（如: 用户代码段、用户数据段、内核代码段、内核数据段）都从0地址开始，偏移量就是线性地址的大小，所以逻辑地址和线性地址是一毛一样的。 对x86汇编感兴趣的话可以参考小甲鱼老师的<a href="https://www.bilibili.com/video/BV1Rs411c7HG/">【8086汇编入门】《零基础入门学习汇编语言》</a>。</li>
<li>线性地址（linear address）: 又叫虚拟地址（virtual address），是连续的地址。在32位系统中，用户空间通常占用前3GB的线性地址空间，内核空间通常占用3GB~4GB的线性地址空间。在64位系统中，用户空间和内核空间占用更大的范围，具体的范围取决于内核的配置和架构。</li>
<li>物理地址（physical address）: 用于内存芯片级的内存寻址单元。</li>
</ul>
<p>分段单元（segmentation unit）和分页单元（paging unit）都由MMU完成，英文全称Memory Management Unit，中文翻译为内存管理单元，又叫分页内存管理单元（Paged Memory Management Unit），最终转换成物理地址。MMU以page大小为单位管理内存，虚拟内存的最小单位就是page。</p>
<h1 id="页"><span class="header-section-number">2</span> 页</h1>
<h2 id="struct-page"><span class="header-section-number">2.1</span> <code>struct page</code></h2>
<p>系统中的每个物理页面都用<code>struct page</code>描述:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">struct</span> page {</a>
<a class="sourceLine" id="cb2-2" title="2">        <span class="dt">unsigned</span> <span class="dt">long</span> flags;            <span class="co">/* 原子标志，其中一些可能被异步更新 */</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4">        <span class="kw">union</span> page_union_1;</a>
<a class="sourceLine" id="cb2-5" title="5">        <span class="kw">union</span> page_union_2;</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">        <span class="co">/* 使用计数。*不要直接使用*。请参见 page_ref.h 头文件 */</span></a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="co">// page_count()返回0代表空闲</span></a>
<a class="sourceLine" id="cb2-9" title="9">        atomic_t _refcount;</a>
<a class="sourceLine" id="cb2-10" title="10"></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="pp">#ifdef CONFIG_MEMCG</span></a>
<a class="sourceLine" id="cb2-12" title="12">        <span class="dt">unsigned</span> <span class="dt">long</span> memcg_data;</a>
<a class="sourceLine" id="cb2-13" title="13"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="co">         * 在所有 RAM 都映射到内核地址空间的机器上，</span></a>
<a class="sourceLine" id="cb2-17" title="17"><span class="co">         * 我们可以简单地计算虚拟地址。在具有 highmem 的机器上，</span></a>
<a class="sourceLine" id="cb2-18" title="18"><span class="co">         * 部分内存会动态映射到内核虚拟内存中，因此我们需要一个地方来存储该地址。</span></a>
<a class="sourceLine" id="cb2-19" title="19"><span class="co">         * 请注意，在 x86 上这个字段可以是 16 位的 ... ;)</span></a>
<a class="sourceLine" id="cb2-20" title="20"><span class="co">         *</span></a>
<a class="sourceLine" id="cb2-21" title="21"><span class="co">         * 具有慢速乘法运算的架构可以在 asm/page.h 中定义</span></a>
<a class="sourceLine" id="cb2-22" title="22"><span class="co">         * WANT_PAGE_VIRTUAL</span></a>
<a class="sourceLine" id="cb2-23" title="23"><span class="co">         */</span></a>
<a class="sourceLine" id="cb2-24" title="24"><span class="pp">#if defined(WANT_PAGE_VIRTUAL)</span></a>
<a class="sourceLine" id="cb2-25" title="25">        <span class="dt">void</span> *virtual;                  <span class="co">/* 内核虚拟地址（如果不是 kmapped，即 highmem，则为 NULL） */</span></a>
<a class="sourceLine" id="cb2-26" title="26"><span class="pp">#endif </span><span class="co">/* WANT_PAGE_VIRTUAL */</span></a>
<a class="sourceLine" id="cb2-27" title="27"></a>
<a class="sourceLine" id="cb2-28" title="28"><span class="pp">#ifdef CONFIG_KMSAN</span></a>
<a class="sourceLine" id="cb2-29" title="29">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb2-30" title="30"><span class="co">        * 此页面的 KMSAN 元数据:</span></a>
<a class="sourceLine" id="cb2-31" title="31"><span class="co">        *  - 影子页面: 每个位表示原始页面对应位是否已初始化（0）或未初始化（1）；</span></a>
<a class="sourceLine" id="cb2-32" title="32"><span class="co">        *  - 原始页面: 每 4 个字节包含一个栈追踪的 ID，用于指示未初始化值的创建位置。</span></a>
<a class="sourceLine" id="cb2-33" title="33"><span class="co">        */</span></a>
<a class="sourceLine" id="cb2-34" title="34">        <span class="kw">struct</span> page *kmsan_shadow;</a>
<a class="sourceLine" id="cb2-35" title="35">        <span class="kw">struct</span> page *kmsan_origin;</a>
<a class="sourceLine" id="cb2-36" title="36"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb2-37" title="37"></a>
<a class="sourceLine" id="cb2-38" title="38"><span class="pp">#ifdef LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></a>
<a class="sourceLine" id="cb2-39" title="39">        <span class="dt">int</span> _last_cpupid;</a>
<a class="sourceLine" id="cb2-40" title="40"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb2-41" title="41">} _struct_page_alignment;</a></code></pre></div>
<p><code>flags</code>字段里的每一位定义在<code>enum pageflags</code>。在内核代码中，我们经常看到类似<code>SetPageError</code>、<code>PagePrivate</code>的函数，但总是找不到定义，这是因为这些函数是通过宏定义生成的。宏定义是对<code>enum pageflags</code>中的每个值进行宏展开，这里列出设置和检测的宏定义:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="co">// 检测</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="pp">#define TESTPAGEFLAG(uname, lname, policy)                       </span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="dt">static</span> __always_inline <span class="dt">int</span> Page##uname(<span class="kw">struct</span> page *page)        </a>
<a class="sourceLine" id="cb3-4" title="4">        { <span class="cf">return</span> test_bit(PG_##lname, &amp;policy(page, <span class="dv">0</span>)-&gt;flags); }</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="co">// 设置                                          </span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="pp">#define SETPAGEFLAG(uname, lname, policy)                        </span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="dt">static</span> __always_inline <span class="dt">void</span> SetPage##uname(<span class="kw">struct</span> page *page)    </a>
<a class="sourceLine" id="cb3-9" title="9">        { set_bit(PG_##lname, &amp;policy(page, <span class="dv">1</span>)-&gt;flags); }        </a></code></pre></div>
<p>页的拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码、页高速缓存等。</p>
<p>页的大小可以用<code>getconf -a | grep PAGESIZE</code>命令查看。<code>x86</code>默认打开配置<code>CONFIG_HAVE_PAGE_SIZE_4KB</code>和<code>CONFIG_PAGE_SIZE_4KB</code>。</p>
<p>在看内存相关的代码时，还会看到KASAN（Kernel Address Sanitizer）和KMSAN（Kernel Memory Sanitizer）两个概念，他们是用于检测和调试内存错误的工具。</p>
<h2 id="两个union"><span class="header-section-number">2.2</span> 两个<code>union</code></h2>
<p>我们再把<code>struct page</code>结构体中的两个<code>union</code>单独拎出来讲:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co"> * 这个联合体中有五个字（20/40字节）可用。</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co"> * 警告: 第一个字的第0位用于 PageTail()。这意味着</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"> * 这个联合体的其他使用者不能使用这个位，以避免</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co"> * 冲突和误报的 PageTail()。</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co"> */</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="kw">union</span> page_union_1 {</a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="kw">struct</span> {        <span class="co">/* 页面缓存和匿名页 */</span></a>
<a class="sourceLine" id="cb4-9" title="9">                <span class="co">/**</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co">                * </span><span class="an">@lru:</span><span class="co"> 页面淘汰列表，例如 active_list，由 lruvec-&gt;lru_lock 保护。</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co">                * 有时由页面所有者用作通用列表。</span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="co">                */</span></a>
<a class="sourceLine" id="cb4-13" title="13">                <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb4-14" title="14">                        <span class="kw">struct</span> list_head lru;</a>
<a class="sourceLine" id="cb4-15" title="15"></a>
<a class="sourceLine" id="cb4-16" title="16">                        <span class="co">/* 或者，对于不可回收的 &quot;LRU 列表&quot; 槽位 */</span></a>
<a class="sourceLine" id="cb4-17" title="17">                        <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb4-18" title="18">                                <span class="co">/* 总是偶数，以抵消 PageTail */</span></a>
<a class="sourceLine" id="cb4-19" title="19">                                <span class="dt">void</span> *__filler;</a>
<a class="sourceLine" id="cb4-20" title="20">                                <span class="co">/* 统计页面或页片的 mlock 数量 */</span></a>
<a class="sourceLine" id="cb4-21" title="21">                                <span class="dt">unsigned</span> <span class="dt">int</span> mlock_count;</a>
<a class="sourceLine" id="cb4-22" title="22">                        };</a>
<a class="sourceLine" id="cb4-23" title="23"></a>
<a class="sourceLine" id="cb4-24" title="24">                        <span class="co">/* 或者，空闲页面 */</span></a>
<a class="sourceLine" id="cb4-25" title="25">                        <span class="kw">struct</span> list_head buddy_list;</a>
<a class="sourceLine" id="cb4-26" title="26">                        <span class="kw">struct</span> list_head pcp_list;</a>
<a class="sourceLine" id="cb4-27" title="27">                };</a>
<a class="sourceLine" id="cb4-28" title="28">                <span class="co">/* 有关 PAGE_MAPPING_FLAGS，请参见 page-flags.h */</span></a>
<a class="sourceLine" id="cb4-29" title="29">                <span class="kw">struct</span> address_space *mapping;</a>
<a class="sourceLine" id="cb4-30" title="30">                <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb4-31" title="31">                        pgoff_t index;          <span class="co">/* 我们在映射中的偏移量。 */</span></a>
<a class="sourceLine" id="cb4-32" title="32">                        <span class="dt">unsigned</span> <span class="dt">long</span> share;    <span class="co">/* fsdax 的共享计数 */</span></a>
<a class="sourceLine" id="cb4-33" title="33">                };</a>
<a class="sourceLine" id="cb4-34" title="34">                <span class="co">/**</span></a>
<a class="sourceLine" id="cb4-35" title="35"><span class="co">                * </span><span class="an">@private:</span><span class="co"> 映射专用的不透明数据。</span></a>
<a class="sourceLine" id="cb4-36" title="36"><span class="co">                * 如果 PagePrivate，通常用于 buffer_heads。</span></a>
<a class="sourceLine" id="cb4-37" title="37"><span class="co">                * 如果 PageSwapCache，则用于 swp_entry_t。</span></a>
<a class="sourceLine" id="cb4-38" title="38"><span class="co">                * 如果 PageBuddy，则表示伙伴系统中的顺序。</span></a>
<a class="sourceLine" id="cb4-39" title="39"><span class="co">                */</span></a>
<a class="sourceLine" id="cb4-40" title="40">                <span class="dt">unsigned</span> <span class="dt">long</span> private;</a>
<a class="sourceLine" id="cb4-41" title="41">        };</a>
<a class="sourceLine" id="cb4-42" title="42">        <span class="kw">struct</span> {        <span class="co">/* 网络栈使用的 page_pool */</span></a>
<a class="sourceLine" id="cb4-43" title="43">                <span class="co">/**</span></a>
<a class="sourceLine" id="cb4-44" title="44"><span class="co">                * </span><span class="an">@pp_magic:</span><span class="co"> 魔术值，用于避免回收非 page_pool 分配的页面。</span></a>
<a class="sourceLine" id="cb4-45" title="45"><span class="co">                */</span></a>
<a class="sourceLine" id="cb4-46" title="46">                <span class="dt">unsigned</span> <span class="dt">long</span> pp_magic;</a>
<a class="sourceLine" id="cb4-47" title="47">                <span class="kw">struct</span> page_pool *pp;</a>
<a class="sourceLine" id="cb4-48" title="48">                <span class="dt">unsigned</span> <span class="dt">long</span> _pp_mapping_pad;</a>
<a class="sourceLine" id="cb4-49" title="49">                <span class="dt">unsigned</span> <span class="dt">long</span> dma_addr;</a>
<a class="sourceLine" id="cb4-50" title="50">                <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb4-51" title="51">                        <span class="co">/**</span></a>
<a class="sourceLine" id="cb4-52" title="52"><span class="co">                        * dma_addr_upper: 在 32 位架构上可能需要 64 位值。</span></a>
<a class="sourceLine" id="cb4-53" title="53"><span class="co">                        */</span></a>
<a class="sourceLine" id="cb4-54" title="54">                        <span class="dt">unsigned</span> <span class="dt">long</span> dma_addr_upper;</a>
<a class="sourceLine" id="cb4-55" title="55">                        <span class="co">/**</span></a>
<a class="sourceLine" id="cb4-56" title="56"><span class="co">                        * 支持 frag page，不支持 64 位 DMA 的 32 位架构。</span></a>
<a class="sourceLine" id="cb4-57" title="57"><span class="co">                        */</span></a>
<a class="sourceLine" id="cb4-58" title="58">                        atomic_long_t pp_frag_count;</a>
<a class="sourceLine" id="cb4-59" title="59">                };</a>
<a class="sourceLine" id="cb4-60" title="60">        };</a>
<a class="sourceLine" id="cb4-61" title="61">        <span class="kw">struct</span> {        <span class="co">/* 复合页面的尾页 */</span></a>
<a class="sourceLine" id="cb4-62" title="62">                <span class="dt">unsigned</span> <span class="dt">long</span> compound_head;    <span class="co">/* 位零已设置 */</span></a>
<a class="sourceLine" id="cb4-63" title="63">        };</a>
<a class="sourceLine" id="cb4-64" title="64">        <span class="kw">struct</span> {        <span class="co">/* ZONE_DEVICE 页面 */</span></a>
<a class="sourceLine" id="cb4-65" title="65">                <span class="co">/** </span><span class="an">@pgmap:</span><span class="co"> 指向宿主设备页面映射。 */</span></a>
<a class="sourceLine" id="cb4-66" title="66">                <span class="kw">struct</span> dev_pagemap *pgmap;</a>
<a class="sourceLine" id="cb4-67" title="67">                <span class="dt">void</span> *zone_device_data;</a>
<a class="sourceLine" id="cb4-68" title="68">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb4-69" title="69"><span class="co">                * ZONE_DEVICE 私有页面被计为已映射，因此接下来的 3 个字保存了</span></a>
<a class="sourceLine" id="cb4-70" title="70"><span class="co">                * 映射、索引和私有字段，当页面迁移到设备私有内存时，这些字段来自</span></a>
<a class="sourceLine" id="cb4-71" title="71"><span class="co">                * 源匿名页面或页面缓存页面。</span></a>
<a class="sourceLine" id="cb4-72" title="72"><span class="co">                * ZONE_DEVICE MEMORY_DEVICE_FS_DAX 页面在 pmem 支持的 DAX 文件</span></a>
<a class="sourceLine" id="cb4-73" title="73"><span class="co">                * 被映射时也使用映射、索引和私有字段。</span></a>
<a class="sourceLine" id="cb4-74" title="74"><span class="co">                */</span></a>
<a class="sourceLine" id="cb4-75" title="75">        };</a>
<a class="sourceLine" id="cb4-76" title="76"></a>
<a class="sourceLine" id="cb4-77" title="77">        <span class="co">/** </span><span class="an">@rcu_head:</span><span class="co"> 您可以使用它通过 RCU 释放页面。 */</span></a>
<a class="sourceLine" id="cb4-78" title="78">        <span class="kw">struct</span> rcu_head rcu_head;</a>
<a class="sourceLine" id="cb4-79" title="79">}</a>
<a class="sourceLine" id="cb4-80" title="80"></a>
<a class="sourceLine" id="cb4-81" title="81"><span class="co">/* 这个联合体的大小是4字节。 */</span></a>
<a class="sourceLine" id="cb4-82" title="82"><span class="kw">union</span> page_union_2 {</a>
<a class="sourceLine" id="cb4-83" title="83">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb4-84" title="84"><span class="co">        * 如果页面可以映射到用户空间，则编码该页面被页表引用的次数。</span></a>
<a class="sourceLine" id="cb4-85" title="85"><span class="co">        */</span></a>
<a class="sourceLine" id="cb4-86" title="86">        atomic_t _mapcount;</a>
<a class="sourceLine" id="cb4-87" title="87"></a>
<a class="sourceLine" id="cb4-88" title="88">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb4-89" title="89"><span class="co">        * 如果页面既不是 PageSlab 也不能映射到用户空间，此处存储的值可能有助于</span></a>
<a class="sourceLine" id="cb4-90" title="90"><span class="co">        * 确定该页面的用途。有关当前存储在此处的页面类型列表，请参见 page-flags.h。</span></a>
<a class="sourceLine" id="cb4-91" title="91"><span class="co">        */</span></a>
<a class="sourceLine" id="cb4-92" title="92">        <span class="dt">unsigned</span> <span class="dt">int</span> page_type;</a>
<a class="sourceLine" id="cb4-93" title="93">}</a></code></pre></div>
<h2 id="struct-folio"><span class="header-section-number">2.3</span> <code>struct folio</code></h2>
<p><code>struct folio</code> 是一种新引入的结构，旨在表示多个连续页面的集合（例如，多个 4KB 页面的组合）。它包含对多个页面的引用，允许内核在处理大页或多个相邻页面时更有效地管理内存。<code>struct folio</code> 是对 <code>struct page</code> 概念的扩展。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co"> * struct folio - 表示一组连续的字节。</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co"> * </span><span class="an">@flags:</span><span class="co"> 与页面标志相同。</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co"> * </span><span class="an">@lru:</span><span class="co"> 最近最少使用列表；跟踪此 folio 最近的使用情况。</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co"> * </span><span class="an">@mlock_count:</span><span class="co"> 此 folio 被 mlock() 固定的次数。</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co"> * </span><span class="an">@mapping:</span><span class="co"> 此页面所属的文件，或指向匿名内存的 anon_vma。</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co"> * </span><span class="an">@index:</span><span class="co"> 文件内的偏移量，以页面为单位。对于匿名内存，这是从 mmap 开始的索引。</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="co"> * </span><span class="an">@private:</span><span class="co"> 文件系统每个 folio 的数据（参见 folio_attach_private()）。</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="co"> * </span><span class="an">@swap:</span><span class="co"> 如果 folio_test_swapcache()，则用于 swp_entry_t。</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="co"> * </span><span class="an">@_mapcount:</span><span class="co"> 不要直接访问此成员。使用 folio_mapcount() 来查找此 folio 被用户空间映射的次数。</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="co"> * </span><span class="an">@_refcount:</span><span class="co"> 不要直接访问此成员。使用 folio_ref_count() 来查找对此 folio 的引用次数。</span></a>
<a class="sourceLine" id="cb5-12" title="12"><span class="co"> * </span><span class="an">@memcg_data:</span><span class="co"> 内存控制组数据。</span></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co"> * </span><span class="an">@_entire_mapcount:</span><span class="co"> 不要直接使用，请调用 folio_entire_mapcount()。</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="co"> * </span><span class="an">@_nr_pages_mapped:</span><span class="co"> 不要直接使用，请调用 folio_mapcount()。</span></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="co"> * </span><span class="an">@_pincount:</span><span class="co"> 不要直接使用，请调用 folio_maybe_dma_pinned()。</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="co"> * </span><span class="an">@_folio_nr_pages:</span><span class="co"> 不要直接使用，请调用 folio_nr_pages()。</span></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="co"> * </span><span class="an">@_hugetlb_subpool:</span><span class="co"> 不要直接使用，请在 hugetlb.h 中使用访问器。</span></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co"> * </span><span class="an">@_hugetlb_cgroup:</span><span class="co"> 不要直接使用，请在 hugetlb_cgroup.h 中使用访问器。</span></a>
<a class="sourceLine" id="cb5-19" title="19"><span class="co"> * </span><span class="an">@_hugetlb_cgroup_rsvd:</span><span class="co"> 不要直接使用，请在 hugetlb_cgroup.h 中使用访问器。</span></a>
<a class="sourceLine" id="cb5-20" title="20"><span class="co"> * </span><span class="an">@_hugetlb_hwpoison:</span><span class="co"> 不要直接使用，请调用 raw_hwp_list_head()。</span></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="co"> * </span><span class="an">@_deferred_list:</span><span class="co"> 内存压力下要拆分的 folios。</span></a>
<a class="sourceLine" id="cb5-22" title="22"><span class="co"> *</span></a>
<a class="sourceLine" id="cb5-23" title="23"><span class="co"> * folio 是一组物理上、虚拟上和逻辑上连续的字节。它的大小是 2 的幂，并且与该幂对齐。它至少与 %PAGE_SIZE 一样大。如果它在页面缓存中，它位于文件偏移的倍数位置。它可以映射到用户空间的任意页面偏移地址，但其内核虚拟地址与其大小对齐。</span></a>
<a class="sourceLine" id="cb5-24" title="24"><span class="co"> */</span></a>
<a class="sourceLine" id="cb5-25" title="25"><span class="kw">struct</span> folio {</a>
<a class="sourceLine" id="cb5-26" title="26">        <span class="co">/* private: 不要记录匿名联合体 */</span></a>
<a class="sourceLine" id="cb5-27" title="27">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb5-28" title="28">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb5-29" title="29">        <span class="co">/* public: */</span></a>
<a class="sourceLine" id="cb5-30" title="30">                        <span class="dt">unsigned</span> <span class="dt">long</span> flags;</a>
<a class="sourceLine" id="cb5-31" title="31">                        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb5-32" title="32">                                <span class="kw">struct</span> list_head lru;</a>
<a class="sourceLine" id="cb5-33" title="33">        <span class="co">/* private: 避免输出混乱 */</span></a>
<a class="sourceLine" id="cb5-34" title="34">                                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb5-35" title="35">                                        <span class="dt">void</span> *__filler;</a>
<a class="sourceLine" id="cb5-36" title="36">        <span class="co">/* public: */</span></a>
<a class="sourceLine" id="cb5-37" title="37">                                        <span class="dt">unsigned</span> <span class="dt">int</span> mlock_count;</a>
<a class="sourceLine" id="cb5-38" title="38">        <span class="co">/* private: */</span></a>
<a class="sourceLine" id="cb5-39" title="39">                                };</a>
<a class="sourceLine" id="cb5-40" title="40">        <span class="co">/* public: */</span></a>
<a class="sourceLine" id="cb5-41" title="41">                        };</a>
<a class="sourceLine" id="cb5-42" title="42">                        <span class="kw">struct</span> address_space *mapping;</a>
<a class="sourceLine" id="cb5-43" title="43">                        pgoff_t index;</a>
<a class="sourceLine" id="cb5-44" title="44">                        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb5-45" title="45">                                <span class="dt">void</span> *private;</a>
<a class="sourceLine" id="cb5-46" title="46">                                swp_entry_t swap;</a>
<a class="sourceLine" id="cb5-47" title="47">                        };</a>
<a class="sourceLine" id="cb5-48" title="48">                        atomic_t _mapcount;</a>
<a class="sourceLine" id="cb5-49" title="49">                        atomic_t _refcount;</a>
<a class="sourceLine" id="cb5-50" title="50"><span class="pp">#ifdef CONFIG_MEMCG</span></a>
<a class="sourceLine" id="cb5-51" title="51">                        <span class="dt">unsigned</span> <span class="dt">long</span> memcg_data;</a>
<a class="sourceLine" id="cb5-52" title="52"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb5-53" title="53">        <span class="co">/* private: 带有 struct page 的联合体是过渡性的 */</span></a>
<a class="sourceLine" id="cb5-54" title="54">                };</a>
<a class="sourceLine" id="cb5-55" title="55">                <span class="kw">struct</span> page page;</a>
<a class="sourceLine" id="cb5-56" title="56">        };</a>
<a class="sourceLine" id="cb5-57" title="57">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb5-58" title="58">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb5-59" title="59">                        <span class="dt">unsigned</span> <span class="dt">long</span> _flags_1;</a>
<a class="sourceLine" id="cb5-60" title="60">                        <span class="dt">unsigned</span> <span class="dt">long</span> _head_1;</a>
<a class="sourceLine" id="cb5-61" title="61">                        <span class="dt">unsigned</span> <span class="dt">long</span> _folio_avail;</a>
<a class="sourceLine" id="cb5-62" title="62">        <span class="co">/* public: */</span></a>
<a class="sourceLine" id="cb5-63" title="63">                        atomic_t _entire_mapcount;</a>
<a class="sourceLine" id="cb5-64" title="64">                        atomic_t _nr_pages_mapped;</a>
<a class="sourceLine" id="cb5-65" title="65">                        atomic_t _pincount;</a>
<a class="sourceLine" id="cb5-66" title="66"><span class="pp">#ifdef CONFIG_64BIT</span></a>
<a class="sourceLine" id="cb5-67" title="67">                        <span class="dt">unsigned</span> <span class="dt">int</span> _folio_nr_pages;</a>
<a class="sourceLine" id="cb5-68" title="68"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb5-69" title="69">        <span class="co">/* private: 带有 struct page 的联合体是过渡性的 */</span></a>
<a class="sourceLine" id="cb5-70" title="70">                };</a>
<a class="sourceLine" id="cb5-71" title="71">                <span class="kw">struct</span> page __page_1;</a>
<a class="sourceLine" id="cb5-72" title="72">        };</a>
<a class="sourceLine" id="cb5-73" title="73">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb5-74" title="74">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb5-75" title="75">                        <span class="dt">unsigned</span> <span class="dt">long</span> _flags_2;</a>
<a class="sourceLine" id="cb5-76" title="76">                        <span class="dt">unsigned</span> <span class="dt">long</span> _head_2;</a>
<a class="sourceLine" id="cb5-77" title="77">        <span class="co">/* public: */</span></a>
<a class="sourceLine" id="cb5-78" title="78">                        <span class="dt">void</span> *_hugetlb_subpool;</a>
<a class="sourceLine" id="cb5-79" title="79">                        <span class="dt">void</span> *_hugetlb_cgroup;</a>
<a class="sourceLine" id="cb5-80" title="80">                        <span class="dt">void</span> *_hugetlb_cgroup_rsvd;</a>
<a class="sourceLine" id="cb5-81" title="81">                        <span class="dt">void</span> *_hugetlb_hwpoison;</a>
<a class="sourceLine" id="cb5-82" title="82">        <span class="co">/* private: 带有 struct page 的联合体是过渡性的 */</span></a>
<a class="sourceLine" id="cb5-83" title="83">                };</a>
<a class="sourceLine" id="cb5-84" title="84">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb5-85" title="85">                        <span class="dt">unsigned</span> <span class="dt">long</span> _flags_2a;</a>
<a class="sourceLine" id="cb5-86" title="86">                        <span class="dt">unsigned</span> <span class="dt">long</span> _head_2a;</a>
<a class="sourceLine" id="cb5-87" title="87">        <span class="co">/* public: */</span></a>
<a class="sourceLine" id="cb5-88" title="88">                        <span class="kw">struct</span> list_head _deferred_list;</a>
<a class="sourceLine" id="cb5-89" title="89">        <span class="co">/* private: 带有 struct page 的联合体是过渡性的 */</span></a>
<a class="sourceLine" id="cb5-90" title="90">                };</a>
<a class="sourceLine" id="cb5-91" title="91">                <span class="kw">struct</span> page __page_2;</a>
<a class="sourceLine" id="cb5-92" title="92">        };</a>
<a class="sourceLine" id="cb5-93" title="93">};</a></code></pre></div>
<h2 id="区"><span class="header-section-number">2.4</span> 区</h2>
<p>物理内存在逻辑上分为三级结构: 节点（在NUMA系统中，Non-Uniform Memory Access，非统一内存访问，可查看<code>pg_data_t</code>），区，页。</p>
<p>内核使用区（zone）对相似特性的页进行分组，描述的是物理内存。定义在<code>include/linux/mmzone.h</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">enum</span> zone_type {</a>
<a class="sourceLine" id="cb6-2" title="2">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co">         * ZONE_DMA 和 ZONE_DMA32 用于当外设无法对所有可寻址内存（ZONE_NORMAL）进行 DMA 时。</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co">         * 在该区域覆盖整个 32 位地址空间的架构上使用 ZONE_DMA32。对于具有较小 DMA 地址限制的</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">         * 架构，保留 ZONE_DMA。当定义了 ZONE_DMA32 时，假定 32 位 DMA 掩码。</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="co">         * 一些 64 位平台可能需要同时使用这两个区域，因为它们支持具有不同 DMA 地址限制的外设。</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">         */</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="pp">#ifdef CONFIG_ZONE_DMA</span></a>
<a class="sourceLine" id="cb6-9" title="9">        ZONE_DMA,</a>
<a class="sourceLine" id="cb6-10" title="10"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb6-11" title="11"><span class="pp">#ifdef CONFIG_ZONE_DMA32</span></a>
<a class="sourceLine" id="cb6-12" title="12">        ZONE_DMA32,</a>
<a class="sourceLine" id="cb6-13" title="13"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb6-14" title="14">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb6-15" title="15"><span class="co">        * 可寻址的常规内存在 ZONE_NORMAL 中。如果 DMA 设备支持对所有可寻址内存的传输，</span></a>
<a class="sourceLine" id="cb6-16" title="16"><span class="co">        * 则可以对 ZONE_NORMAL 中的页面执行 DMA 操作。</span></a>
<a class="sourceLine" id="cb6-17" title="17"><span class="co">        */</span></a>
<a class="sourceLine" id="cb6-18" title="18">        ZONE_NORMAL,</a>
<a class="sourceLine" id="cb6-19" title="19"><span class="pp">#ifdef CONFIG_HIGHMEM</span></a>
<a class="sourceLine" id="cb6-20" title="20">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb6-21" title="21"><span class="co">        * 一种只能通过将部分映射到其自身地址空间来由内核寻址的内存区域。</span></a>
<a class="sourceLine" id="cb6-22" title="22"><span class="co">        * 例如，i386 使用此区域允许内核寻址超过 900MB 的内存。</span></a>
<a class="sourceLine" id="cb6-23" title="23"><span class="co">        * 内核将为每个需要访问的页面设置特殊映射（在 i386 上为页表项）。</span></a>
<a class="sourceLine" id="cb6-24" title="24"><span class="co">        */</span></a>
<a class="sourceLine" id="cb6-25" title="25">        ZONE_HIGHMEM,</a>
<a class="sourceLine" id="cb6-26" title="26"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb6-27" title="27">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb6-28" title="28"><span class="co">        * ZONE_MOVABLE 类似于 ZONE_NORMAL，不同之处在于它包含可移动页面，</span></a>
<a class="sourceLine" id="cb6-29" title="29"><span class="co">        * 下面描述了几个例外情况。ZONE_MOVABLE 的主要用途是增加内存下线/卸载</span></a>
<a class="sourceLine" id="cb6-30" title="30"><span class="co">        * 成功的可能性，并局部限制不可移动的分配 - 例如，增加 THP(Transparent Huge Pages， 透明大页)/大页的数量。</span></a>
<a class="sourceLine" id="cb6-31" title="31"><span class="co">        * 值得注意的特殊情况包括:</span></a>
<a class="sourceLine" id="cb6-32" title="32"><span class="co">        *</span></a>
<a class="sourceLine" id="cb6-33" title="33"><span class="co">        * 1. 锁定页面: （长期）锁定可移动页面可能会实质上使这些页面变得不可移动。</span></a>
<a class="sourceLine" id="cb6-34" title="34"><span class="co">        *    因此，我们不允许在 ZONE_MOVABLE 中长期锁定页面。当页面被锁定并出现错误时，</span></a>
<a class="sourceLine" id="cb6-35" title="35"><span class="co">        *    它们会立即从正确的区域中获取。然而，当页面被锁定时，地址空间中可能已经有</span></a>
<a class="sourceLine" id="cb6-36" title="36"><span class="co">        *    位于 ZONE_MOVABLE 中的页面（即用户在锁定前已访问该内存）。在这种情况下，</span></a>
<a class="sourceLine" id="cb6-37" title="37"><span class="co">        *    我们将它们迁移到不同的区域。当迁移失败时 - 锁定失败。</span></a>
<a class="sourceLine" id="cb6-38" title="38"><span class="co">        * 2. memblock 分配: kernelcore/movablecore 设置可能会在引导后导致</span></a>
<a class="sourceLine" id="cb6-39" title="39"><span class="co">        *    ZONE_MOVABLE 中包含不可移动的分配。内存下线和分配会很早失败。</span></a>
<a class="sourceLine" id="cb6-40" title="40"><span class="co">        * 3. 内存空洞: kernelcore/movablecore 设置可能会在引导后导致 ZONE_MOVABLE</span></a>
<a class="sourceLine" id="cb6-41" title="41"><span class="co">        *    中包含内存空洞，例如，如果我们有仅部分填充的部分。内存下线和分配会很早失败。</span></a>
<a class="sourceLine" id="cb6-42" title="42"><span class="co">        * 4. PG_hwpoison 页面: 虽然在内存下线期间可以跳过中毒页面，但这些页面不能被分配。</span></a>
<a class="sourceLine" id="cb6-43" title="43"><span class="co">        * 5. 不可移动的 PG_offline 页面: 在半虚拟化环境中，热插拔的内存块可能仅部分</span></a>
<a class="sourceLine" id="cb6-44" title="44"><span class="co">        *    由伙伴系统管理（例如，通过 XEN-balloon、Hyper-V balloon、virtio-mem）。</span></a>
<a class="sourceLine" id="cb6-45" title="45"><span class="co">        *    由伙伴系统未管理的部分是不可移动的 PG_offline 页面。在某些情况下</span></a>
<a class="sourceLine" id="cb6-46" title="46"><span class="co">        *    （virtio-mem），在内存下线期间可以跳过这些页面，但不能移动/分配。</span></a>
<a class="sourceLine" id="cb6-47" title="47"><span class="co">        *    这些技术可能会使用 alloc_contig_range() 再次隐藏之前暴露的页面</span></a>
<a class="sourceLine" id="cb6-48" title="48"><span class="co">        *    （例如，在 virtio-mem 中实现某种内存卸载）。</span></a>
<a class="sourceLine" id="cb6-49" title="49"><span class="co">        * 6. ZERO_PAGE(0): kernelcore/movablecore 设置可能会导致</span></a>
<a class="sourceLine" id="cb6-50" title="50"><span class="co">        *    ZERO_PAGE(0)（在不同平台上分配方式不同）最终位于可移动区域。</span></a>
<a class="sourceLine" id="cb6-51" title="51"><span class="co">        *    ZERO_PAGE(0) 不能迁移。</span></a>
<a class="sourceLine" id="cb6-52" title="52"><span class="co">        * 7. 内存热插拔: 当使用 memmap_on_memory 并将内存上线到 MOVABLE 区域时，</span></a>
<a class="sourceLine" id="cb6-53" title="53"><span class="co">        *    vmemmap 页面也会放置在该区域。这些页面不能真正移动，因为它们自存储在范围内，</span></a>
<a class="sourceLine" id="cb6-54" title="54"><span class="co">        *    但在描述的范围即将下线时，它们被视为可移动。</span></a>
<a class="sourceLine" id="cb6-55" title="55"><span class="co">        *</span></a>
<a class="sourceLine" id="cb6-56" title="56"><span class="co">        * 总体而言，不应在 ZONE_MOVABLE 中出现不可移动的分配，这会降低内存下线的效果。</span></a>
<a class="sourceLine" id="cb6-57" title="57"><span class="co">        * 分配器（如 alloc_contig_range()）必须预料到在 ZONE_MOVABLE 中迁移页面可能会失败</span></a>
<a class="sourceLine" id="cb6-58" title="58"><span class="co">        * （即使 has_unmovable_pages() 表示没有不可移动页面，也可能存在假阴性）。</span></a>
<a class="sourceLine" id="cb6-59" title="59"><span class="co">        */</span></a>
<a class="sourceLine" id="cb6-60" title="60">        ZONE_MOVABLE,</a>
<a class="sourceLine" id="cb6-61" title="61"><span class="pp">#ifdef CONFIG_ZONE_DEVICE</span></a>
<a class="sourceLine" id="cb6-62" title="62">        ZONE_DEVICE,</a>
<a class="sourceLine" id="cb6-63" title="63"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb6-64" title="64">        __MAX_NR_ZONES</a>
<a class="sourceLine" id="cb6-65" title="65"></a>
<a class="sourceLine" id="cb6-66" title="66">};</a></code></pre></div>
<p>内存区域的划分取决于体系结构，有些体系结构上所有的内存都是<code>ZONE_NORMAL</code>。</p>
<p>32位<code>x86</code>:</p>
<ul>
<li><code>ZONE_DMA</code>范围是<code>0~16M</code>。</li>
<li><code>ZONE_NORMAL</code>的范围是<code>16~896M</code>。</li>
<li><code>ZONE_HIGHMEM</code>的范围是大于<code>896M</code>的内存。</li>
</ul>
<p>而64位<code>x86_64</code>则没有<code>ZONE_HIGHMEM</code>。</p>
<p>每个区用结构结构体<code>struct zone</code>表示:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">enum</span> zone_watermarks {</a>
<a class="sourceLine" id="cb7-2" title="2">        WMARK_MIN, <span class="co">// 最低水印。当可用内存低于此水印时，内核将强制执行紧急内存回收操作，以确保系统不会耗尽内存</span></a>
<a class="sourceLine" id="cb7-3" title="3">        WMARK_LOW, <span class="co">// 低水印。当可用内存低于此水印但高于最低水印时，内核将开始执行内存回收操作，但不会像最低水印那么紧急</span></a>
<a class="sourceLine" id="cb7-4" title="4">        WMARK_HIGH, <span class="co">// 高水印。当可用内存高于此水印时，内核认为系统内存充足，不需要进行内存回收操作</span></a>
<a class="sourceLine" id="cb7-5" title="5">        WMARK_PROMO, <span class="co">// promotion提升，一种优化机制，用于更细粒度地控制内存分配和回收。它的作用是当内存压力较高时，将某些内存区域的水印提升到较高水平，以便更积极地进行内存回收，防止内存耗尽的风险。</span></a>
<a class="sourceLine" id="cb7-6" title="6">        NR_WMARK  <span class="co">// 总数</span></a>
<a class="sourceLine" id="cb7-7" title="7">};                    </a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="kw">struct</span> zone {</a>
<a class="sourceLine" id="cb7-10" title="10">        <span class="co">/* 主要为只读字段 */</span></a>
<a class="sourceLine" id="cb7-11" title="11"></a>
<a class="sourceLine" id="cb7-12" title="12">        <span class="co">/* 区域水印，通过 *_wmark_pages(zone) 宏访问 */</span></a>
<a class="sourceLine" id="cb7-13" title="13">        <span class="dt">unsigned</span> <span class="dt">long</span> _watermark[NR_WMARK]; <span class="co">// 查看 zone_watermarks</span></a>
<a class="sourceLine" id="cb7-14" title="14">        <span class="dt">unsigned</span> <span class="dt">long</span> watermark_boost;</a>
<a class="sourceLine" id="cb7-15" title="15"></a>
<a class="sourceLine" id="cb7-16" title="16">        <span class="dt">unsigned</span> <span class="dt">long</span> nr_reserved_highatomic;</a>
<a class="sourceLine" id="cb7-17" title="17"></a>
<a class="sourceLine" id="cb7-18" title="18">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb7-19" title="19"><span class="co">        * 我们不知道将要分配的内存是否可释放或最终会被释放，所以为了避免完全浪费数GB的内存，</span></a>
<a class="sourceLine" id="cb7-20" title="20"><span class="co">        * 我们必须保留一些较低区域的内存（否则我们有可能在较低区域内存不足的情况下，</span></a>
<a class="sourceLine" id="cb7-21" title="21"><span class="co">        * 而较高区域却有大量可释放的内存）。如果 sysctl_lowmem_reserve_ratio 的 sysctl 发生变化，</span></a>
<a class="sourceLine" id="cb7-22" title="22"><span class="co">        * 该数组会在运行时重新计算。</span></a>
<a class="sourceLine" id="cb7-23" title="23"><span class="co">        */</span></a>
<a class="sourceLine" id="cb7-24" title="24">        <span class="dt">long</span> lowmem_reserve[MAX_NR_ZONES];</a>
<a class="sourceLine" id="cb7-25" title="25"></a>
<a class="sourceLine" id="cb7-26" title="26"><span class="pp">#ifdef CONFIG_NUMA</span></a>
<a class="sourceLine" id="cb7-27" title="27">        <span class="dt">int</span> node;</a>
<a class="sourceLine" id="cb7-28" title="28"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-29" title="29">        <span class="kw">struct</span> pglist_data      *zone_pgdat;</a>
<a class="sourceLine" id="cb7-30" title="30">        <span class="kw">struct</span> per_cpu_pages    __percpu *per_cpu_pageset;</a>
<a class="sourceLine" id="cb7-31" title="31">        <span class="kw">struct</span> per_cpu_zonestat __percpu *per_cpu_zonestats;</a>
<a class="sourceLine" id="cb7-32" title="32">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb7-33" title="33"><span class="co">        * high 和 batch 值被复制到各个页面集以便更快速地访问</span></a>
<a class="sourceLine" id="cb7-34" title="34"><span class="co">        */</span></a>
<a class="sourceLine" id="cb7-35" title="35">        <span class="dt">int</span> pageset_high;</a>
<a class="sourceLine" id="cb7-36" title="36">        <span class="dt">int</span> pageset_batch;</a>
<a class="sourceLine" id="cb7-37" title="37"></a>
<a class="sourceLine" id="cb7-38" title="38"><span class="pp">#ifndef CONFIG_SPARSEMEM</span></a>
<a class="sourceLine" id="cb7-39" title="39">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb7-40" title="40"><span class="co">        * pageblock_nr_pages 块的标志。请参阅 pageblock-flags.h。</span></a>
<a class="sourceLine" id="cb7-41" title="41"><span class="co">        * 在 SPARSEMEM 中，此映射存储在 struct mem_section 中。</span></a>
<a class="sourceLine" id="cb7-42" title="42"><span class="co">        */</span></a>
<a class="sourceLine" id="cb7-43" title="43">        <span class="dt">unsigned</span> <span class="dt">long</span>           *pageblock_flags;</a>
<a class="sourceLine" id="cb7-44" title="44"><span class="pp">#endif </span><span class="co">/* CONFIG_SPARSEMEM */</span></a>
<a class="sourceLine" id="cb7-45" title="45"></a>
<a class="sourceLine" id="cb7-46" title="46">        <span class="co">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></a>
<a class="sourceLine" id="cb7-47" title="47">        <span class="dt">unsigned</span> <span class="dt">long</span>           zone_start_pfn;</a>
<a class="sourceLine" id="cb7-48" title="48">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb7-49" title="49"><span class="co">        * spanned_pages 是该区域所跨越的总页数，包括空洞，计算公式为:</span></a>
<a class="sourceLine" id="cb7-50" title="50"><span class="co">        *      spanned_pages = zone_end_pfn - zone_start_pfn;</span></a>
<a class="sourceLine" id="cb7-51" title="51"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-52" title="52"><span class="co">        * present_pages 是该区域内存在的物理页，计算公式为:</span></a>
<a class="sourceLine" id="cb7-53" title="53"><span class="co">        *      present_pages = spanned_pages - absent_pages(空洞中的页数);</span></a>
<a class="sourceLine" id="cb7-54" title="54"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-55" title="55"><span class="co">        * present_early_pages 是自启动早期以来该区域内存在的内存页，不包括热插拔内存。</span></a>
<a class="sourceLine" id="cb7-56" title="56"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-57" title="57"><span class="co">        * managed_pages 是由伙伴系统管理的存在页，计算公式为（reserved_pages 包括由 bootmem 分配器分配的页）:</span></a>
<a class="sourceLine" id="cb7-58" title="58"><span class="co">        *      managed_pages = present_pages - reserved_pages;</span></a>
<a class="sourceLine" id="cb7-59" title="59"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-60" title="60"><span class="co">        * cma_pages 是分配给 CMA 使用的存在页（MIGRATE_CMA）。</span></a>
<a class="sourceLine" id="cb7-61" title="61"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-62" title="62"><span class="co">        * 因此， present_pages 可被内存热插拔或内存电源管理逻辑用来通过检查</span></a>
<a class="sourceLine" id="cb7-63" title="63"><span class="co">        * (present_pages - managed_pages) 来找出未管理的页。而 managed_pages</span></a>
<a class="sourceLine" id="cb7-64" title="64"><span class="co">        * 应该被页分配器和虚拟内存扫描器用来计算各种水印和阈值。</span></a>
<a class="sourceLine" id="cb7-65" title="65"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-66" title="66"><span class="co">        * 锁定规则:</span></a>
<a class="sourceLine" id="cb7-67" title="67"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-68" title="68"><span class="co">        * zone_start_pfn 和 spanned_pages 受 span_seqlock 保护。</span></a>
<a class="sourceLine" id="cb7-69" title="69"><span class="co">        * 这是一个 seqlock，因为它必须在 zone-&gt;lock 外部读取，</span></a>
<a class="sourceLine" id="cb7-70" title="70"><span class="co">        * 并且它是在主分配器路径中完成的。但是，它的写入频率非常低。</span></a>
<a class="sourceLine" id="cb7-71" title="71"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-72" title="72"><span class="co">        * span_seq 锁与 zone-&gt;lock 一起声明，因为它在 zone-&gt;lock 附近经常被读取。</span></a>
<a class="sourceLine" id="cb7-73" title="73"><span class="co">        * 这样有机会使它们位于同一个缓存行中。</span></a>
<a class="sourceLine" id="cb7-74" title="74"><span class="co">        *</span></a>
<a class="sourceLine" id="cb7-75" title="75"><span class="co">        * 运行时对 present_pages 的写访问应由 mem_hotplug_begin/done() 保护。</span></a>
<a class="sourceLine" id="cb7-76" title="76"><span class="co">        * 任何无法容忍 present_pages 漂移的读者应使用 get_online_mems() 以获得稳定的值。</span></a>
<a class="sourceLine" id="cb7-77" title="77"><span class="co">        */</span></a>
<a class="sourceLine" id="cb7-78" title="78">        atomic_long_t           managed_pages;</a>
<a class="sourceLine" id="cb7-79" title="79">        <span class="dt">unsigned</span> <span class="dt">long</span>           spanned_pages;</a>
<a class="sourceLine" id="cb7-80" title="80">        <span class="dt">unsigned</span> <span class="dt">long</span>           present_pages;</a>
<a class="sourceLine" id="cb7-81" title="81"><span class="pp">#if defined(CONFIG_MEMORY_HOTPLUG)</span></a>
<a class="sourceLine" id="cb7-82" title="82">        <span class="dt">unsigned</span> <span class="dt">long</span>           present_early_pages;</a>
<a class="sourceLine" id="cb7-83" title="83"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-84" title="84"><span class="pp">#ifdef CONFIG_CMA</span></a>
<a class="sourceLine" id="cb7-85" title="85">        <span class="dt">unsigned</span> <span class="dt">long</span>           cma_pages;</a>
<a class="sourceLine" id="cb7-86" title="86"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-87" title="87"></a>
<a class="sourceLine" id="cb7-88" title="88">        <span class="dt">const</span> <span class="dt">char</span>              *name; <span class="co">// 查看 char * const zone_names[MAX_NR_ZONES]</span></a>
<a class="sourceLine" id="cb7-89" title="89"></a>
<a class="sourceLine" id="cb7-90" title="90"><span class="pp">#ifdef CONFIG_MEMORY_ISOLATION</span></a>
<a class="sourceLine" id="cb7-91" title="91">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb7-92" title="92"><span class="co">        * 隔离页面块的数量。用于解决由于竞争性检索页面块的迁移类型导致的错误空闲页计数问题。</span></a>
<a class="sourceLine" id="cb7-93" title="93"><span class="co">        * 受 zone-&gt;lock 保护。</span></a>
<a class="sourceLine" id="cb7-94" title="94"><span class="co">        */</span></a>
<a class="sourceLine" id="cb7-95" title="95">        <span class="dt">unsigned</span> <span class="dt">long</span>           nr_isolate_pageblock;</a>
<a class="sourceLine" id="cb7-96" title="96"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-97" title="97"></a>
<a class="sourceLine" id="cb7-98" title="98"><span class="pp">#ifdef CONFIG_MEMORY_HOTPLUG</span></a>
<a class="sourceLine" id="cb7-99" title="99">        <span class="co">/* 有关详细描述，请参阅 spanned/present_pages */</span></a>
<a class="sourceLine" id="cb7-100" title="100">        seqlock_t               span_seqlock;</a>
<a class="sourceLine" id="cb7-101" title="101"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-102" title="102"></a>
<a class="sourceLine" id="cb7-103" title="103">        <span class="dt">int</span> initialized;</a>
<a class="sourceLine" id="cb7-104" title="104"></a>
<a class="sourceLine" id="cb7-105" title="105">        <span class="co">/* 页分配器使用的写密集字段 */</span></a>
<a class="sourceLine" id="cb7-106" title="106">        CACHELINE_PADDING(_pad1_);</a>
<a class="sourceLine" id="cb7-107" title="107"></a>
<a class="sourceLine" id="cb7-108" title="108">        <span class="co">/* 不同大小的空闲区域 */</span></a>
<a class="sourceLine" id="cb7-109" title="109">        <span class="kw">struct</span> free_area        free_area[MAX_ORDER + <span class="dv">1</span>];</a>
<a class="sourceLine" id="cb7-110" title="110"></a>
<a class="sourceLine" id="cb7-111" title="111"><span class="pp">#ifdef CONFIG_UNACCEPTED_MEMORY</span></a>
<a class="sourceLine" id="cb7-112" title="112">        <span class="co">/* 待接受的页面。列表中的所有页面都是 MAX_ORDER */</span></a>
<a class="sourceLine" id="cb7-113" title="113">        <span class="kw">struct</span> list_head        unaccepted_pages;</a>
<a class="sourceLine" id="cb7-114" title="114"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-115" title="115"></a>
<a class="sourceLine" id="cb7-116" title="116">        <span class="co">/* 区域标志，见下文 */</span></a>
<a class="sourceLine" id="cb7-117" title="117">        <span class="dt">unsigned</span> <span class="dt">long</span>           flags;</a>
<a class="sourceLine" id="cb7-118" title="118"></a>
<a class="sourceLine" id="cb7-119" title="119">        <span class="co">/* 主要保护 free_area */</span></a>
<a class="sourceLine" id="cb7-120" title="120">        spinlock_t              lock; <span class="co">// 只保护结构，不保护在这个区的页</span></a>
<a class="sourceLine" id="cb7-121" title="121"></a>
<a class="sourceLine" id="cb7-122" title="122">        <span class="co">/* 由压缩和 vmstats 使用的写密集字段。 */</span></a>
<a class="sourceLine" id="cb7-123" title="123">        CACHELINE_PADDING(_pad2_);</a>
<a class="sourceLine" id="cb7-124" title="124"></a>
<a class="sourceLine" id="cb7-125" title="125">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb7-126" title="126"><span class="co">        * 当空闲页数低于此点时，在读取空闲页数时会采取额外步骤，</span></a>
<a class="sourceLine" id="cb7-127" title="127"><span class="co">        * 以避免每个 CPU 计数器漂移导致水印被突破</span></a>
<a class="sourceLine" id="cb7-128" title="128"><span class="co">        */</span></a>
<a class="sourceLine" id="cb7-129" title="129">        <span class="dt">unsigned</span> <span class="dt">long</span> percpu_drift_mark;</a>
<a class="sourceLine" id="cb7-130" title="130"></a>
<a class="sourceLine" id="cb7-131" title="131"><span class="pp">#if defined CONFIG_COMPACTION || defined CONFIG_CMA</span></a>
<a class="sourceLine" id="cb7-132" title="132">        <span class="co">/* 压缩空闲扫描器应开始的 pfn（page frame number 页帧号） */</span></a>
<a class="sourceLine" id="cb7-133" title="133">        <span class="dt">unsigned</span> <span class="dt">long</span>           compact_cached_free_pfn;</a>
<a class="sourceLine" id="cb7-134" title="134">        <span class="co">/* 压缩迁移扫描器应开始的页帧号（pfn） */</span></a>
<a class="sourceLine" id="cb7-135" title="135">        <span class="dt">unsigned</span> <span class="dt">long</span>           compact_cached_migrate_pfn[ASYNC_AND_SYNC];</a>
<a class="sourceLine" id="cb7-136" title="136">        <span class="dt">unsigned</span> <span class="dt">long</span>           compact_init_migrate_pfn;</a>
<a class="sourceLine" id="cb7-137" title="137">        <span class="dt">unsigned</span> <span class="dt">long</span>           compact_init_free_pfn;</a>
<a class="sourceLine" id="cb7-138" title="138"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-139" title="139"></a>
<a class="sourceLine" id="cb7-140" title="140"><span class="pp">#ifdef CONFIG_COMPACTION</span></a>
<a class="sourceLine" id="cb7-141" title="141">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb7-142" title="142"><span class="co">        * 在压缩失败时，跳过 1&lt;&lt;compact_defer_shift 次压缩后再尝试。</span></a>
<a class="sourceLine" id="cb7-143" title="143"><span class="co">        * 自上次失败以来尝试的次数由 compact_considered 跟踪。</span></a>
<a class="sourceLine" id="cb7-144" title="144"><span class="co">        * compact_order_failed 是压缩失败的最小顺序。</span></a>
<a class="sourceLine" id="cb7-145" title="145"><span class="co">        */</span></a>
<a class="sourceLine" id="cb7-146" title="146">        <span class="dt">unsigned</span> <span class="dt">int</span>            compact_considered;</a>
<a class="sourceLine" id="cb7-147" title="147">        <span class="dt">unsigned</span> <span class="dt">int</span>            compact_defer_shift;</a>
<a class="sourceLine" id="cb7-148" title="148">        <span class="dt">int</span>                     compact_order_failed;</a>
<a class="sourceLine" id="cb7-149" title="149"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-150" title="150"></a>
<a class="sourceLine" id="cb7-151" title="151"><span class="pp">#if defined CONFIG_COMPACTION || defined CONFIG_CMA</span></a>
<a class="sourceLine" id="cb7-152" title="152">        <span class="co">/* 当应清除 PG_migrate_skip 位时设为 true */</span></a>
<a class="sourceLine" id="cb7-153" title="153">        <span class="dt">bool</span>                    compact_blockskip_flush;</a>
<a class="sourceLine" id="cb7-154" title="154"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-155" title="155"></a>
<a class="sourceLine" id="cb7-156" title="156">        <span class="dt">bool</span>                    contiguous;</a>
<a class="sourceLine" id="cb7-157" title="157"></a>
<a class="sourceLine" id="cb7-158" title="158">        CACHELINE_PADDING(_pad3_);</a>
<a class="sourceLine" id="cb7-159" title="159">        <span class="co">/* Zone statistics */</span></a>
<a class="sourceLine" id="cb7-160" title="160">        atomic_long_t           vm_stat[NR_VM_ZONE_STAT_ITEMS];</a>
<a class="sourceLine" id="cb7-161" title="161">        atomic_long_t           vm_numa_event[NR_VM_NUMA_EVENT_ITEMS];</a>
<a class="sourceLine" id="cb7-162" title="162">} ____cacheline_internodealigned_in_smp;</a></code></pre></div>
<h1 id="内存分配与释放"><span class="header-section-number">3</span> 内存分配与释放</h1>
<h2 id="函数接口"><span class="header-section-number">3.1</span> 函数接口</h2>
<p>分配页:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="co">// 分配 2^order 个连续物理page，返回值是第一个page的指针</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">struct</span> page *alloc_pages(gfp_t gfp_mask, <span class="dt">unsigned</span> <span class="dt">int</span> order)</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">// 页转换成逻辑地址</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="dt">void</span> *page_address(<span class="dt">const</span> <span class="kw">struct</span> page *page)</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="co">// 返回值是逻辑地址</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="dt">unsigned</span> <span class="dt">long</span> __get_free_pages(gfp_t gfp_mask, <span class="dt">unsigned</span> <span class="dt">int</span> order)</a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co">// 只分配一个page，返回值是page的指针</span></a>
<a class="sourceLine" id="cb8-8" title="8">alloc_page(gfp_mask)</a>
<a class="sourceLine" id="cb8-9" title="9"><span class="co">// 只分配一个page，返回值是虚拟地址</span></a>
<a class="sourceLine" id="cb8-10" title="10">__get_free_page(gfp_mask)</a>
<a class="sourceLine" id="cb8-11" title="11"><span class="co">// 只分配一个page，返回值是虚拟地址，全部填充0</span></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="dt">unsigned</span> <span class="dt">long</span> get_zeroed_page(gfp_t gfp_mask)</a></code></pre></div>
<p>释放页:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="co">// 传入page指针</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="dt">void</span> __free_pages(<span class="kw">struct</span> page *page, <span class="dt">unsigned</span> <span class="dt">int</span> order)</a>
<a class="sourceLine" id="cb9-3" title="3"><span class="co">// 传入虚拟地址</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="dt">void</span> free_pages(<span class="dt">unsigned</span> <span class="dt">long</span> addr, <span class="dt">unsigned</span> <span class="dt">int</span> order)</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="co">// 释放一个page，传入虚拟地址</span></a>
<a class="sourceLine" id="cb9-6" title="6">free_page(addr)</a></code></pre></div>
<p>分配以字节为单位的内存:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="co">// 物理地址是连续的，一般是硬件设备要用到</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="dt">void</span> *kmalloc(<span class="dt">size_t</span> size, gfp_t gfp)</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">// 和kmalloc()配对使用，参数p可以为NULL</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="dt">void</span> kfree(<span class="dt">void</span> *p)</a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">// 可能睡眠，物理地址可以不连续，虚拟地址连续，典型用途是获取大块内存，如模块装载</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="dt">void</span> *vmalloc(<span class="dt">unsigned</span> <span class="dt">long</span> size)</a>
<a class="sourceLine" id="cb10-7" title="7"><span class="co">// 可能睡眠，和 vmalloc() 配对使用</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="dt">void</span> vfree(<span class="dt">const</span> <span class="dt">void</span> *addr)</a></code></pre></div>
<h2 id="gfp_t"><span class="header-section-number">3.2</span> <code>gfp_t</code></h2>
<p>在<code>include/linux/gfp_types.h</code>中的解释:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="co">/* typedef 在 include/linux/types.h 中，但我们希望将文档放在这里 */</span>     </a>
<a class="sourceLine" id="cb11-2" title="2"><span class="pp">#if 0                                                                  </span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co">/**</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="co"> * typedef gfp_t - 内存分配标志。</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="co"> * </span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="co"> * GFP 标志在 Linux 中广泛用于指示如何分配内存。GFP 的缩写来源于</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="co"> * get_free_pages()，这是底层的内存分配函数。并不是每个 GFP 标志都被</span></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="co"> * 每个可能分配内存的函数所支持。大多数用户会使用简单的 ``GFP_KERNEL``。</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="co"> */                                                               </span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="co">typedef unsigned int __bitwise gfp_t;                                  </span></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="pp">#endif</span>                                                                 </a></code></pre></div>
<h3 id="行为修饰符"><span class="header-section-number">3.2.1</span> 行为修饰符</h3>
<p>表示内核应该如何分配所需的内存。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co"> * DOC: 操作修饰符</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co"> * </span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co"> * 操作修饰符</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co"> * ----------------</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co"> * </span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co"> * %__GFP_NOWARN 抑制分配失败报告。</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co"> * </span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co"> * %__GFP_COMP 处理复合页元数据。</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="co"> * </span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="co"> * %__GFP_ZERO 成功时返回已清零的页。</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="co"> * </span></a>
<a class="sourceLine" id="cb12-13" title="13"><span class="co"> * %__GFP_ZEROTAGS 如果内存本身被清零（通过 __GFP_ZERO 或 init_on_alloc，</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="co"> * 前提是未设置 __GFP_SKIP_ZERO ），则在分配时清零内存标签。此标志用于优化:</span></a>
<a class="sourceLine" id="cb12-15" title="15"><span class="co"> * 在清零内存的同时设置内存标签对性能的额外影响最小。</span></a>
<a class="sourceLine" id="cb12-16" title="16"><span class="co"> * </span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="co"> * %__GFP_SKIP_KASAN 使 KASAN 在页分配时跳过取消标记。用于用户空间和 vmalloc 页；</span></a>
<a class="sourceLine" id="cb12-18" title="18"><span class="co"> * 后者由 kasan_unpoison_vmalloc 代替取消标记。对于用户空间页，</span></a>
<a class="sourceLine" id="cb12-19" title="19"><span class="co"> * 也会跳过标记，详细信息见 should_skip_kasan_poison。仅在 HW_TAGS 模式下有效。</span></a>
<a class="sourceLine" id="cb12-20" title="20"><span class="co"> */</span>                                                                            </a>
<a class="sourceLine" id="cb12-21" title="21"><span class="pp">#define __GFP_NOWARN    ((__force gfp_t)___GFP_NOWARN)                          </span></a>
<a class="sourceLine" id="cb12-22" title="22"><span class="pp">#define __GFP_COMP      ((__force gfp_t)___GFP_COMP)                            </span></a>
<a class="sourceLine" id="cb12-23" title="23"><span class="pp">#define __GFP_ZERO      ((__force gfp_t)___GFP_ZERO)                            </span></a>
<a class="sourceLine" id="cb12-24" title="24"><span class="pp">#define __GFP_ZEROTAGS  ((__force gfp_t)___GFP_ZEROTAGS)                        </span></a>
<a class="sourceLine" id="cb12-25" title="25"><span class="pp">#define __GFP_SKIP_ZERO ((__force gfp_t)___GFP_SKIP_ZERO)                       </span></a>
<a class="sourceLine" id="cb12-26" title="26"><span class="pp">#define __GFP_SKIP_KASAN ((__force gfp_t)___GFP_SKIP_KASAN)                     </span></a>
<a class="sourceLine" id="cb12-27" title="27">                                                                                </a>
<a class="sourceLine" id="cb12-28" title="28"><span class="co">/* 禁用 GFP 上下文跟踪的 lockdep */</span>                               </a>
<a class="sourceLine" id="cb12-29" title="29"><span class="pp">#define __GFP_NOLOCKDEP ((__force gfp_t)___GFP_NOLOCKDEP)                       </span></a>
<a class="sourceLine" id="cb12-30" title="30">                                                                                </a>
<a class="sourceLine" id="cb12-31" title="31"><span class="co">/* 为 N 个 __GFP_FOO 位预留空间 */</span>                                               </a>
<a class="sourceLine" id="cb12-32" title="32"><span class="pp">#define __GFP_BITS_SHIFT (26 + IS_ENABLED(CONFIG_LOCKDEP))                      </span></a>
<a class="sourceLine" id="cb12-33" title="33"><span class="pp">#define __GFP_BITS_MASK ((__force gfp_t)((1 &lt;&lt; __GFP_BITS_SHIFT) - 1))          </span></a></code></pre></div>
<h3 id="区修饰符"><span class="header-section-number">3.2.2</span> 区修饰符</h3>
<p>表示从哪个区分配内存。注意返回逻辑地址的函数如<code>__get_free_pages()</code>和<code>kmalloc()</code>等不能指定<code>__GFP_HIGHMEM</code>，因为可能会出现还没映射虚拟地址空间，没有虚拟地址。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co"> * 物理地址区域修饰符（参见 linux/mmzone.h - 低四位）</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co"> * </span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="co"> * 不要对这些修饰符做任何条件判断。如有必要，修改没有下划线的定义并一致地使用它们。</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="co"> * 这里的定义可能会用于位比较。</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="co"> */</span>                                                                              </a>
<a class="sourceLine" id="cb13-7" title="7"><span class="pp">#define __GFP_DMA       ((__force gfp_t)___GFP_DMA)                                </span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="pp">#define __GFP_HIGHMEM   ((__force gfp_t)___GFP_HIGHMEM)                            </span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="pp">#define __GFP_DMA32     ((__force gfp_t)___GFP_DMA32)                              </span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="pp">#define __GFP_MOVABLE   ((__force gfp_t)___GFP_MOVABLE)  </span><span class="co">/* ZONE_MOVABLE allowed */</span></a>
<a class="sourceLine" id="cb13-11" title="11"><span class="pp">#define GFP_ZONEMASK    (__GFP_DMA|__GFP_HIGHMEM|__GFP_DMA32|__GFP_MOVABLE)        </span></a></code></pre></div>
<h3 id="页面的移动性和放置提示"><span class="header-section-number">3.2.3</span> 页面的移动性和放置提示</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="co"> * DOC: 页面的移动性和放置提示</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="co"> * 页面的移动性和放置提示</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="co"> * -----------------------</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="co"> * 这些标志提供了有关页面移动性的信息。具有相似移动性的页面被放置在相同的页面块中，以最大限度地减少由外部碎片引起的问题。</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="co"> * %__GFP_MOVABLE （也是一个区域修饰符）表示页面可以通过内存压缩期间的页面迁移来移动或可以被回收。</span></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="co"> * %__GFP_RECLAIMABLE 用于指定 SLAB_RECLAIM_ACCOUNT 的 slab 分配，其页面可以通过收缩器（shrinkers）释放。</span></a>
<a class="sourceLine" id="cb14-12" title="12"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="co"> * %__GFP_WRITE 表示调用者打算对页面进行写操作。尽可能地，这些页面将分散在本地区域之间，以避免所有脏页面集中在一个区域（公平区域分配策略）。</span></a>
<a class="sourceLine" id="cb14-14" title="14"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-15" title="15"><span class="co"> * %__GFP_HARDWALL 强制执行 cpuset 内存分配策略。</span></a>
<a class="sourceLine" id="cb14-16" title="16"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-17" title="17"><span class="co"> * %__GFP_THISNODE 强制分配从请求的节点中满足，不进行回退或放置策略的强制执行。</span></a>
<a class="sourceLine" id="cb14-18" title="18"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-19" title="19"><span class="co"> * %__GFP_ACCOUNT 使分配计入 kmemcg。kmemcg 是 Kernel Memory Control Group（内核内存控制组）的缩写。它是 Linux 内核中的一种内存管理机制，用于对内核内存进行分组和控制。具体来说，kmemcg 允许用户限制和监视内核分配的内存，以防止某些进程消耗过多的内核内存资源，从而影响系统的整体性能和稳定性。</span></a>
<a class="sourceLine" id="cb14-20" title="20"><span class="co"> */</span></a>
<a class="sourceLine" id="cb14-21" title="21"><span class="pp">#define __GFP_RECLAIMABLE ((__force gfp_t)___GFP_RECLAIMABLE)</span></a>
<a class="sourceLine" id="cb14-22" title="22"><span class="pp">#define __GFP_WRITE     ((__force gfp_t)___GFP_WRITE)</span></a>
<a class="sourceLine" id="cb14-23" title="23"><span class="pp">#define __GFP_HARDWALL   ((__force gfp_t)___GFP_HARDWALL)</span></a>
<a class="sourceLine" id="cb14-24" title="24"><span class="pp">#define __GFP_THISNODE  ((__force gfp_t)___GFP_THISNODE)</span></a>
<a class="sourceLine" id="cb14-25" title="25"><span class="pp">#define __GFP_ACCOUNT   ((__force gfp_t)___GFP_ACCOUNT)</span></a></code></pre></div>
<h3 id="水位标志修饰符"><span class="header-section-number">3.2.4</span> 水位标志修饰符</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="co"> * DOC: 水位标志修饰符</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="co"> *</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="co"> * 水位标志修饰符 -- 控制对紧急预留内存的访问</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="co"> * --------------------------------------------</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="co"> *</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="co"> * %__GFP_HIGH 表示调用者是高优先级的，并且在系统能够继续前进之前，必须满足该请求。</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="co"> * 例如，从原子上下文创建 IO 上下文以清理页面和请求。</span></a>
<a class="sourceLine" id="cb15-9" title="9"><span class="co"> *</span></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="co"> * %__GFP_MEMALLOC 允许访问所有内存。这只能在调用者保证分配将很快释放更多内存时使用，</span></a>
<a class="sourceLine" id="cb15-11" title="11"><span class="co"> * 例如进程退出或交换。使用者应该是内存管理（MM）或与虚拟内存（VM）紧密协作（例如通过 NFS 进行交换）。</span></a>
<a class="sourceLine" id="cb15-12" title="12"><span class="co"> * 使用此标志的用户必须非常小心，不要完全耗尽预留内存，并实施一种控制机制，</span></a>
<a class="sourceLine" id="cb15-13" title="13"><span class="co"> * 根据释放的内存量来控制预留内存的消耗。在使用此标志之前，应始终考虑使用预先分配的池（例如 mempool）。</span></a>
<a class="sourceLine" id="cb15-14" title="14"><span class="co"> *</span></a>
<a class="sourceLine" id="cb15-15" title="15"><span class="co"> * %__GFP_NOMEMALLOC 用于明确禁止访问紧急预留内存。如果同时设置了 %__GFP_MEMALLOC 标志，此标志优先。</span></a>
<a class="sourceLine" id="cb15-16" title="16"><span class="co"> */</span></a>
<a class="sourceLine" id="cb15-17" title="17"><span class="pp">#define __GFP_HIGH      ((__force gfp_t)___GFP_HIGH)</span></a>
<a class="sourceLine" id="cb15-18" title="18"><span class="pp">#define __GFP_MEMALLOC  ((__force gfp_t)___GFP_MEMALLOC)</span></a>
<a class="sourceLine" id="cb15-19" title="19"><span class="pp">#define __GFP_NOMEMALLOC ((__force gfp_t)___GFP_NOMEMALLOC)</span></a></code></pre></div>
<h3 id="回收修饰符"><span class="header-section-number">3.2.5</span> 回收修饰符</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="co"> * DOC: 回收修饰符</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="co"> * 回收修饰符</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="co"> * ----------</span></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="co"> * 请注意，以下所有标志仅适用于可休眠的分配（例如 %GFP_NOWAIT 和 %GFP_ATOMIC 将忽略它们）。</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="co"> * %__GFP_IO 可以启动物理 IO。</span></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="co"> * %__GFP_FS 可以调用底层文件系统。清除此标志可以避免分配器递归到可能已经持有锁的文件系统中。</span></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-12" title="12"><span class="co"> * %__GFP_DIRECT_RECLAIM 表示调用者可以进入直接回收。如果有备用选项可用，可以清除此标志以避免不必要的延迟。</span></a>
<a class="sourceLine" id="cb16-13" title="13"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="co"> * %__GFP_KSWAPD_RECLAIM 表示调用者希望在达到低水位时唤醒 kswapd 并让它回收页面直到达到高水位。当有备用选项可用且回收可能会中断系统时，调用者可能希望清除此标志。一个典型的例子是 THP(Transparent Huge Pages， 透明大页) 分配，其中备用选项成本低廉，但回收/压缩可能导致间接停滞。</span></a>
<a class="sourceLine" id="cb16-15" title="15"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-16" title="16"><span class="co"> * %__GFP_RECLAIM 是允许/禁止直接回收和 kswapd 回收的简写。</span></a>
<a class="sourceLine" id="cb16-17" title="17"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-18" title="18"><span class="co"> * 默认分配器行为取决于请求大小。我们有一个所谓昂贵分配（order &gt; %PAGE_ALLOC_COSTLY_ORDER）的概念。</span></a>
<a class="sourceLine" id="cb16-19" title="19"><span class="co"> * !昂贵分配是至关重要的，不能失败，所以它们默认情况下是隐含的不失败（某些例外情况如 OOM 受害者可能会失败，因此调用者仍需检查失败）而昂贵请求则试图不造成干扰，即使不调用 OOM 杀手也会后退。</span></a>
<a class="sourceLine" id="cb16-20" title="20"><span class="co"> * 以下三个修饰符可以用来覆盖某些隐含规则</span></a>
<a class="sourceLine" id="cb16-21" title="21"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-22" title="22"><span class="co"> * %__GFP_NORETRY: 虚拟内存实现将只尝试非常轻量级的内存直接回收以在内存压力下获得一些内存（因此它可以休眠）。它将避免像 OOM 杀手这样具有破坏性的操作。在内存压力大的情况下，失败是很可能发生的，因此调用者必须处理失败。此标志适用于可以轻松处理失败且成本较低的情况，例如降低吞吐量</span></a>
<a class="sourceLine" id="cb16-23" title="23"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-24" title="24"><span class="co"> * %__GFP_RETRY_MAYFAIL: 虚拟内存实现将在某些地方有进展的情况下重试先前失败的内存回收过程。它可以等待其他任务尝试高层次的内存释放方法，例如压缩（消除碎片）和页面换出。</span></a>
<a class="sourceLine" id="cb16-25" title="25"><span class="co"> * 重试次数有一定限制，但比 %__GFP_NORETRY 的限制大。</span></a>
<a class="sourceLine" id="cb16-26" title="26"><span class="co"> * 带有此标志的分配可能会失败，但只有在确实没有未使用的内存时才会失败。尽管这些分配不会直接触发 OOM 杀手，但它们的失败表明系统可能很快需要使用 OOM 杀手。</span></a>
<a class="sourceLine" id="cb16-27" title="27"><span class="co"> * 调用者必须处理失败，但可以通过失败更高级别的请求或以效率低得多的方式完成来合理地处理。</span></a>
<a class="sourceLine" id="cb16-28" title="28"><span class="co"> * 如果分配确实失败，并且调用者能够释放一些非必要的内存，那么这样做可能会使整个系统受益。</span></a>
<a class="sourceLine" id="cb16-29" title="29"><span class="co"> *</span></a>
<a class="sourceLine" id="cb16-30" title="30"><span class="co"> * %__GFP_NOFAIL: 虚拟内存实现 _必须_ 无限重试: 调用者无法处理分配失败。分配可能会无限期阻塞，但不会返回失败。测试失败是没有意义的。</span></a>
<a class="sourceLine" id="cb16-31" title="31"><span class="co"> * 新用户应仔细评估（并且该标志应仅在没有合理的失败策略时使用），但绝对比在分配器周围编写无尽循环代码更可取。</span></a>
<a class="sourceLine" id="cb16-32" title="32"><span class="co"> * 强烈不建议将此标志用于昂贵的分配。</span></a>
<a class="sourceLine" id="cb16-33" title="33"><span class="co"> */</span></a>
<a class="sourceLine" id="cb16-34" title="34"><span class="pp">#define __GFP_IO        ((__force gfp_t)___GFP_IO)</span></a>
<a class="sourceLine" id="cb16-35" title="35"><span class="pp">#define __GFP_FS        ((__force gfp_t)___GFP_FS)</span></a>
<a class="sourceLine" id="cb16-36" title="36"><span class="pp">#define __GFP_DIRECT_RECLAIM    ((__force gfp_t)___GFP_DIRECT_RECLAIM) </span><span class="co">/* 调用者可以回收 */</span></a>
<a class="sourceLine" id="cb16-37" title="37"><span class="pp">#define __GFP_KSWAPD_RECLAIM    ((__force gfp_t)___GFP_KSWAPD_RECLAIM) </span><span class="co">/* kswapd 可以唤醒 */</span></a>
<a class="sourceLine" id="cb16-38" title="38"><span class="pp">#define __GFP_RECLAIM ((__force gfp_t)(___GFP_DIRECT_RECLAIM|___GFP_KSWAPD_RECLAIM))</span></a>
<a class="sourceLine" id="cb16-39" title="39"><span class="pp">#define __GFP_RETRY_MAYFAIL     ((__force gfp_t)___GFP_RETRY_MAYFAIL)</span></a>
<a class="sourceLine" id="cb16-40" title="40"><span class="pp">#define __GFP_NOFAIL    ((__force gfp_t)___GFP_NOFAIL)</span></a>
<a class="sourceLine" id="cb16-41" title="41"><span class="pp">#define __GFP_NORETRY   ((__force gfp_t)___GFP_NORETRY)</span></a></code></pre></div>
<h3 id="类型标志"><span class="header-section-number">3.2.6</span> 类型标志</h3>
<p>组合了以上修饰符。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="co"> * DOC: 有用的 GFP 标志组合</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="co"> * 有用的 GFP 标志组合</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="co"> * ----------------------------</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-7" title="7"><span class="co"> * 常用的 GFP 标志组合。建议子系统从这些组合之一开始，然后根据需要设置/清除 %__GFP_FOO 标志。</span></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-9" title="9"><span class="co"> * %GFP_ATOMIC 用户不能休眠，需要分配成功。应用了较低的水印以允许访问“原子保留”。</span></a>
<a class="sourceLine" id="cb17-10" title="10"><span class="co"> * 当前实现不支持 NMI 和其他一些严格的非抢占上下文（例如 raw_spin_lock）。</span></a>
<a class="sourceLine" id="cb17-11" title="11"><span class="co"> * %GFP_NOWAIT 也是如此。</span></a>
<a class="sourceLine" id="cb17-12" title="12"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-13" title="13"><span class="co"> * %GFP_KERNEL 适用于内核内部分配。调用者需要 %ZONE_NORMAL 或更低区域以直接访问，但可以直接回收。</span></a>
<a class="sourceLine" id="cb17-14" title="14"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-15" title="15"><span class="co"> * %GFP_KERNEL_ACCOUNT 与 GFP_KERNEL 相同，但分配会记入 kmemcg。</span></a>
<a class="sourceLine" id="cb17-16" title="16"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-17" title="17"><span class="co"> * %GFP_NOWAIT 适用于不应因直接回收、启动物理 IO 或使用任何文件系统回调而停滞的内核分配。</span></a>
<a class="sourceLine" id="cb17-18" title="18"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-19" title="19"><span class="co"> * %GFP_NOIO 将使用直接回收来丢弃不需要启动任何物理 IO 的干净页或 slab 页。</span></a>
<a class="sourceLine" id="cb17-20" title="20"><span class="co"> * 请尽量避免直接使用此标志，而应使用 memalloc_noio_{save,restore}</span></a>
<a class="sourceLine" id="cb17-21" title="21"><span class="co"> * 来标记整个范围，说明不能执行任何 IO 的原因。所有分配请求将隐式继承 GFP_NOIO。</span></a>
<a class="sourceLine" id="cb17-22" title="22"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-23" title="23"><span class="co"> * %GFP_NOFS 将使用直接回收，但不会使用任何文件系统接口。</span></a>
<a class="sourceLine" id="cb17-24" title="24"><span class="co"> * 请尽量避免直接使用此标志，而应使用 memalloc_nofs_{save,restore}</span></a>
<a class="sourceLine" id="cb17-25" title="25"><span class="co"> * 来标记整个范围，说明不能/不应递归到 FS 层的原因。所有分配请求将隐式继承 GFP_NOFS。</span></a>
<a class="sourceLine" id="cb17-26" title="26"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-27" title="27"><span class="co"> * %GFP_USER 适用于需要内核或硬件直接访问的用户空间分配。</span></a>
<a class="sourceLine" id="cb17-28" title="28"><span class="co"> * 它通常用于映射到用户空间的硬件缓冲区（例如图形），硬件仍然必须进行 DMA。</span></a>
<a class="sourceLine" id="cb17-29" title="29"><span class="co"> * 这些分配强制执行 cpuset 限制。</span></a>
<a class="sourceLine" id="cb17-30" title="30"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-31" title="31"><span class="co"> * %GFP_DMA 出于历史原因存在，应尽可能避免使用。</span></a>
<a class="sourceLine" id="cb17-32" title="32"><span class="co"> * 标志表示调用者要求使用最低区域（%ZONE_DMA 或 x86-64 上的 16M）。</span></a>
<a class="sourceLine" id="cb17-33" title="33"><span class="co"> * 理想情况下，应删除该标志，但这需要仔细审核，因为一些用户确实需要它，</span></a>
<a class="sourceLine" id="cb17-34" title="34"><span class="co"> * 而其他用户使用该标志来避免 %ZONE_DMA 中的低内存保留，并将最低区域视为一种紧急保留。</span></a>
<a class="sourceLine" id="cb17-35" title="35"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-36" title="36"><span class="co"> * %GFP_DMA32 类似于 %GFP_DMA，除了调用者要求 32 位地址。</span></a>
<a class="sourceLine" id="cb17-37" title="37"><span class="co"> * 请注意，kmalloc(..., GFP_DMA32) 不返回 DMA32 内存，因为未实现 DMA32 kmalloc 缓存数组。</span></a>
<a class="sourceLine" id="cb17-38" title="38"><span class="co"> * （原因: 内核中没有这样的用户）。</span></a>
<a class="sourceLine" id="cb17-39" title="39"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-40" title="40"><span class="co"> * %GFP_HIGHUSER 适用于可能映射到用户空间的用户空间分配，</span></a>
<a class="sourceLine" id="cb17-41" title="41"><span class="co"> * 不需要内核直接访问但一旦使用便不能移动。例如硬件分配，直接将数据映射到用户空间，</span></a>
<a class="sourceLine" id="cb17-42" title="42"><span class="co"> * 但没有地址限制。</span></a>
<a class="sourceLine" id="cb17-43" title="43"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-44" title="44"><span class="co"> * %GFP_HIGHUSER_MOVABLE 适用于内核不需要直接访问的用户空间分配，但需要访问时可以使用 kmap()。</span></a>
<a class="sourceLine" id="cb17-45" title="45"><span class="co"> * 预计这些分配可通过页回收或页迁移移动。通常，LRU 上的页也会分配 %GFP_HIGHUSER_MOVABLE。</span></a>
<a class="sourceLine" id="cb17-46" title="46"><span class="co"> *</span></a>
<a class="sourceLine" id="cb17-47" title="47"><span class="co"> * %GFP_TRANSHUGE 和 %GFP_TRANSHUGE_LIGHT 用于 THP(Transparent Huge Pages， 透明大页) 分配。</span></a>
<a class="sourceLine" id="cb17-48" title="48"><span class="co"> * 它们是复合分配，如果内存不可用，通常会快速失败，并且在失败时不会唤醒 kswapd/kcompactd。</span></a>
<a class="sourceLine" id="cb17-49" title="49"><span class="co"> * _LIGHT 版本根本不尝试回收/压缩，默认用于页面错误路径，而非轻量版用于 khugepaged。</span></a>
<a class="sourceLine" id="cb17-50" title="50"><span class="co"> */</span></a>
<a class="sourceLine" id="cb17-51" title="51"><span class="pp">#define GFP_ATOMIC      (__GFP_HIGH|__GFP_KSWAPD_RECLAIM) </span><span class="co">// 在中断处理程序、软中断、tasklet</span></a>
<a class="sourceLine" id="cb17-52" title="52"><span class="pp">#define GFP_KERNEL      (__GFP_RECLAIM | __GFP_IO | __GFP_FS)</span></a>
<a class="sourceLine" id="cb17-53" title="53"><span class="pp">#define GFP_KERNEL_ACCOUNT (GFP_KERNEL | __GFP_ACCOUNT)</span></a>
<a class="sourceLine" id="cb17-54" title="54"><span class="pp">#define GFP_NOWAIT      (__GFP_KSWAPD_RECLAIM)</span></a>
<a class="sourceLine" id="cb17-55" title="55"><span class="co">// GFP_NOIO 表示在内存分配期间不允许执行任何 I/O 操作</span></a>
<a class="sourceLine" id="cb17-56" title="56"><span class="co">// 当你在一个上下文中进行内存分配，而这个上下文可能已经持有某些锁，</span></a>
<a class="sourceLine" id="cb17-57" title="57"><span class="co">// 这些锁在进行 I/O 操作时可能会导致死锁。在这种情况下，</span></a>
<a class="sourceLine" id="cb17-58" title="58"><span class="co">// 使用 GFP_NOIO 可以确保内存分配不会触发 I/O 操作，</span></a>
<a class="sourceLine" id="cb17-59" title="59"><span class="co">// 从而避免潜在的死锁问题。</span></a>
<a class="sourceLine" id="cb17-60" title="60"><span class="pp">#define GFP_NOIO        (__GFP_RECLAIM)</span></a>
<a class="sourceLine" id="cb17-61" title="61"><span class="co">// GFP_NOFS 表示在内存分配期间不允许执行任何与文件系统相关的操作。</span></a>
<a class="sourceLine" id="cb17-62" title="62"><span class="co">// 当你在文件系统代码中进行内存分配，而这个上下文可能已经持有文件系统的锁，</span></a>
<a class="sourceLine" id="cb17-63" title="63"><span class="co">// 这些锁在进行文件系统操作时可能会导致死锁。在这种情况下，</span></a>
<a class="sourceLine" id="cb17-64" title="64"><span class="co">// 使用 GFP_NOFS 可以确保内存分配不会触发文件系统操作，</span></a>
<a class="sourceLine" id="cb17-65" title="65"><span class="co">// 从而避免潜在的死锁问题。</span></a>
<a class="sourceLine" id="cb17-66" title="66"><span class="co">// GFP_NOIO 比 GFP_NOFS 更严格，因为它不仅禁止文件系统相关的操作，还禁止所有的 I/O 操作。</span></a>
<a class="sourceLine" id="cb17-67" title="67"><span class="co">// GFP_NOFS 仅禁止文件系统相关的操作，但允许非文件系统的 I/O 操作。</span></a>
<a class="sourceLine" id="cb17-68" title="68"><span class="pp">#define GFP_NOFS        (__GFP_RECLAIM | __GFP_IO)</span></a>
<a class="sourceLine" id="cb17-69" title="69"><span class="pp">#define GFP_USER        (__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL)</span></a>
<a class="sourceLine" id="cb17-70" title="70"><span class="pp">#define GFP_DMA         __GFP_DMA</span></a>
<a class="sourceLine" id="cb17-71" title="71"><span class="pp">#define GFP_DMA32       __GFP_DMA32</span></a>
<a class="sourceLine" id="cb17-72" title="72"><span class="pp">#define GFP_HIGHUSER    (GFP_USER | __GFP_HIGHMEM)</span></a>
<a class="sourceLine" id="cb17-73" title="73"><span class="pp">#define GFP_HIGHUSER_MOVABLE    (GFP_HIGHUSER | __GFP_MOVABLE | __GFP_SKIP_KASAN)</span></a>
<a class="sourceLine" id="cb17-74" title="74"><span class="pp">#define GFP_TRANSHUGE_LIGHT     ((GFP_HIGHUSER_MOVABLE | __GFP_COMP | \</span></a>
<a class="sourceLine" id="cb17-75" title="75"><span class="pp">                         __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM)</span></a>
<a class="sourceLine" id="cb17-76" title="76"><span class="pp">#define GFP_TRANSHUGE   (GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM)</span></a></code></pre></div>
<h1 id="slab"><span class="header-section-number">4</span> slab</h1>
<p>slab的字面意思是指“板”或“平板”。一个高速缓存包含多个slab，slab由一个或多个物理上连续的页组成，每个slab包含被缓存的数据结构。</p>
<p>高速缓存使用结构体<code>struct kmem_cache</code>表示，其中包含多个<code>struct kmem_cache_node</code>对象，这个结构体中有3个重要的成员:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">struct</span> kmem_cache_node {</a>
<a class="sourceLine" id="cb18-2" title="2">        ...</a>
<a class="sourceLine" id="cb18-3" title="3">        <span class="kw">struct</span> list_head slabs_partial; <span class="co">// 部分满</span></a>
<a class="sourceLine" id="cb18-4" title="4">        <span class="kw">struct</span> list_head slabs_full;    <span class="co">// 满</span></a>
<a class="sourceLine" id="cb18-5" title="5">        <span class="kw">struct</span> list_head slabs_free;    <span class="co">// 空</span></a>
<a class="sourceLine" id="cb18-6" title="6">        ...</a>
<a class="sourceLine" id="cb18-7" title="7">};</a></code></pre></div>
<p>这3个链表包含高速缓存中的所有slab，<code>struct slab</code>用于描述每个slab:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="co">/* 重用 struct page 中的位 */</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="kw">struct</span> slab {</a>
<a class="sourceLine" id="cb19-3" title="3">        <span class="dt">unsigned</span> <span class="dt">long</span> __page_flags;</a>
<a class="sourceLine" id="cb19-4" title="4"></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="pp">#if defined(CONFIG_SLAB)</span></a>
<a class="sourceLine" id="cb19-6" title="6"></a>
<a class="sourceLine" id="cb19-7" title="7">        <span class="kw">struct</span> kmem_cache *slab_cache;</a>
<a class="sourceLine" id="cb19-8" title="8">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb19-9" title="9">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb19-10" title="10">                        <span class="kw">struct</span> list_head slab_list; <span class="co">// 满、部分满或空链表</span></a>
<a class="sourceLine" id="cb19-11" title="11">                        <span class="dt">void</span> *freelist; <span class="co">/* 空闲对象索引数组 */</span></a>
<a class="sourceLine" id="cb19-12" title="12">                        <span class="dt">void</span> *s_mem;    <span class="co">/* 在slab中的第一个对象 */</span></a>
<a class="sourceLine" id="cb19-13" title="13">                };</a>
<a class="sourceLine" id="cb19-14" title="14">                <span class="kw">struct</span> rcu_head rcu_head;</a>
<a class="sourceLine" id="cb19-15" title="15">        };</a>
<a class="sourceLine" id="cb19-16" title="16">        <span class="dt">unsigned</span> <span class="dt">int</span> active;</a>
<a class="sourceLine" id="cb19-17" title="17"></a>
<a class="sourceLine" id="cb19-18" title="18"><span class="pp">#elif defined(CONFIG_SLUB)</span></a>
<a class="sourceLine" id="cb19-19" title="19"></a>
<a class="sourceLine" id="cb19-20" title="20">        <span class="kw">struct</span> kmem_cache *slab_cache;</a>
<a class="sourceLine" id="cb19-21" title="21">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb19-22" title="22">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb19-23" title="23">                        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb19-24" title="24">                                <span class="kw">struct</span> list_head slab_list;</a>
<a class="sourceLine" id="cb19-25" title="25"><span class="pp">#ifdef CONFIG_SLUB_CPU_PARTIAL</span></a>
<a class="sourceLine" id="cb19-26" title="26">                                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb19-27" title="27">                                        <span class="kw">struct</span> slab *next;</a>
<a class="sourceLine" id="cb19-28" title="28">                                        <span class="dt">int</span> slabs;      <span class="co">/* 剩余的slab数量 */</span></a>
<a class="sourceLine" id="cb19-29" title="29">                                };</a>
<a class="sourceLine" id="cb19-30" title="30"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb19-31" title="31">                        };</a>
<a class="sourceLine" id="cb19-32" title="32">                        <span class="co">/* 双字边界 */</span></a>
<a class="sourceLine" id="cb19-33" title="33">                        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb19-34" title="34">                                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb19-35" title="35">                                        <span class="dt">void</span> *freelist;         <span class="co">/* 第一个空闲对象 */</span></a>
<a class="sourceLine" id="cb19-36" title="36">                                        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb19-37" title="37">                                                <span class="dt">unsigned</span> <span class="dt">long</span> counters;</a>
<a class="sourceLine" id="cb19-38" title="38">                                                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb19-39" title="39">                                                        <span class="dt">unsigned</span> inuse:<span class="dv">16</span>; <span class="co">// slab中已分配的对象数</span></a>
<a class="sourceLine" id="cb19-40" title="40">                                                        <span class="dt">unsigned</span> objects:<span class="dv">15</span>;</a>
<a class="sourceLine" id="cb19-41" title="41">                                                        <span class="dt">unsigned</span> frozen:<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb19-42" title="42">                                                };</a>
<a class="sourceLine" id="cb19-43" title="43">                                        };</a>
<a class="sourceLine" id="cb19-44" title="44">                                };</a>
<a class="sourceLine" id="cb19-45" title="45"><span class="pp">#ifdef system_has_freelist_aba</span></a>
<a class="sourceLine" id="cb19-46" title="46">                                freelist_aba_t freelist_counter;</a>
<a class="sourceLine" id="cb19-47" title="47"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb19-48" title="48">                        };</a>
<a class="sourceLine" id="cb19-49" title="49">                };</a>
<a class="sourceLine" id="cb19-50" title="50">                <span class="kw">struct</span> rcu_head rcu_head;</a>
<a class="sourceLine" id="cb19-51" title="51">        };</a>
<a class="sourceLine" id="cb19-52" title="52">        <span class="dt">unsigned</span> <span class="dt">int</span> __unused;</a>
<a class="sourceLine" id="cb19-53" title="53"></a>
<a class="sourceLine" id="cb19-54" title="54"><span class="pp">#else</span></a>
<a class="sourceLine" id="cb19-55" title="55"><span class="pp">#error &quot;Unexpected slab allocator configured&quot;</span></a>
<a class="sourceLine" id="cb19-56" title="56"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb19-57" title="57"></a>
<a class="sourceLine" id="cb19-58" title="58">        atomic_t __page_refcount;</a>
<a class="sourceLine" id="cb19-59" title="59"><span class="pp">#ifdef CONFIG_MEMCG</span></a>
<a class="sourceLine" id="cb19-60" title="60">        <span class="dt">unsigned</span> <span class="dt">long</span> memcg_data;</a>
<a class="sourceLine" id="cb19-61" title="61"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb19-62" title="62">};</a></code></pre></div>
<p>slab分配器的接口:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="co"> * kmem_cache_create - 创建一个缓存。可能休眠，不能在中断上下文中使用</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="co"> * </span><span class="an">@name</span><span class="do">:</span><span class="co"> </span><span class="do">用于在</span><span class="co"> </span><span class="do">/proc/slabinfo</span><span class="co"> </span><span class="do">中标识此缓存的字符串。</span></a>
<a class="sourceLine" id="cb20-4" title="4"><span class="co"> * </span><span class="an">@size:</span><span class="co"> 在此缓存中创建的对象的大小。</span></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="co"> * </span><span class="an">@align:</span><span class="co"> 对象所需的对齐方式。</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="co"> * </span><span class="an">@flags:</span><span class="co"> SLAB 标志</span></a>
<a class="sourceLine" id="cb20-7" title="7"><span class="co"> * </span><span class="an">@ctor:</span><span class="co"> 对象的构造函数。大部分都设置为NULL</span></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="co"> * </span></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="co"> * 不能在中断内调用，但可以被中断。</span></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="co"> * 当缓存分配新的页面时，@ctor 会运行。</span></a>
<a class="sourceLine" id="cb20-11" title="11"><span class="co"> * </span></a>
<a class="sourceLine" id="cb20-12" title="12"><span class="co"> * 标志包括</span></a>
<a class="sourceLine" id="cb20-13" title="13"><span class="co"> * </span></a>
<a class="sourceLine" id="cb20-14" title="14"><span class="co"> * %SLAB_POISON - 用已知的测试模式（a5a5a5a5）填充 slab，以捕捉对未初始化内存的引用。</span></a>
<a class="sourceLine" id="cb20-15" title="15"><span class="co"> * </span></a>
<a class="sourceLine" id="cb20-16" title="16"><span class="co"> * %SLAB_RED_ZONE - 在分配的内存周围插入“红色”区域，以检查缓冲区溢出。</span></a>
<a class="sourceLine" id="cb20-17" title="17"><span class="co"> * </span></a>
<a class="sourceLine" id="cb20-18" title="18"><span class="co"> * %SLAB_HWCACHE_ALIGN - 将此缓存中的对象对齐到硬件缓存行。如果您像 davem 一样仔细计算周期，这可能会有好处。</span></a>
<a class="sourceLine" id="cb20-19" title="19"><span class="co"> *</span></a>
<a class="sourceLine" id="cb20-20" title="20"><span class="co"> * 还有其他的标志，请查看上述宏定义附近的代码</span></a>
<a class="sourceLine" id="cb20-21" title="21"><span class="co"> * </span></a>
<a class="sourceLine" id="cb20-22" title="22"><span class="co"> * 返回: 成功时返回指向缓存的指针，失败时返回 NULL。</span></a>
<a class="sourceLine" id="cb20-23" title="23"><span class="co"> */</span></a>
<a class="sourceLine" id="cb20-24" title="24"><span class="kw">struct</span> kmem_cache *</a>
<a class="sourceLine" id="cb20-25" title="25">kmem_cache_create(<span class="dt">const</span> <span class="dt">char</span> *name, <span class="dt">unsigned</span> <span class="dt">int</span> size, <span class="dt">unsigned</span> <span class="dt">int</span> align,</a>
<a class="sourceLine" id="cb20-26" title="26">                slab_flags_t flags, <span class="dt">void</span> (*ctor)(<span class="dt">void</span> *))</a>
<a class="sourceLine" id="cb20-27" title="27"></a>
<a class="sourceLine" id="cb20-28" title="28"><span class="co">/* 销毁高速缓存，也可能睡眠 */</span></a>
<a class="sourceLine" id="cb20-29" title="29"><span class="dt">void</span> kmem_cache_destroy(<span class="kw">struct</span> kmem_cache *s)</a>
<a class="sourceLine" id="cb20-30" title="30"></a>
<a class="sourceLine" id="cb20-31" title="31"><span class="co">/* 获取对象 */</span></a>
<a class="sourceLine" id="cb20-32" title="32"><span class="dt">void</span> *kmem_cache_alloc(<span class="kw">struct</span> kmem_cache *cachep, gfp_t flags)</a>
<a class="sourceLine" id="cb20-33" title="33"></a>
<a class="sourceLine" id="cb20-34" title="34"><span class="co">/**</span></a>
<a class="sourceLine" id="cb20-35" title="35"><span class="co"> * kmem_cache_free - 释放一个对象</span></a>
<a class="sourceLine" id="cb20-36" title="36"><span class="co"> * </span><span class="an">@cachep:</span><span class="co"> 分配对象时使用的缓存。</span></a>
<a class="sourceLine" id="cb20-37" title="37"><span class="co"> * </span><span class="an">@objp:</span><span class="co"> 之前分配的对象。</span></a>
<a class="sourceLine" id="cb20-38" title="38"><span class="co"> * </span></a>
<a class="sourceLine" id="cb20-39" title="39"><span class="co"> * 释放之前从该缓存中分配的对象。</span></a>
<a class="sourceLine" id="cb20-40" title="40"><span class="co"> */</span></a>
<a class="sourceLine" id="cb20-41" title="41"><span class="dt">void</span> kmem_cache_free(<span class="kw">struct</span> kmem_cache *cachep, <span class="dt">void</span> *objp)</a></code></pre></div>
<p>目前内核中已经引入SLUB (Unqueued Allocator)，旧的SLAB将被弃用，请查看<code>SLAB_DEPRECATED</code>配置。SLUB 是一种改进版的 slab 分配器，它通过最小化缓存行使用来代替管理缓存对象队列（SLAB 方法）。每个 CPU 的缓存通过对象的 slabs 而不是对象的队列来实现。SLUB 可以有效地使用内存并具有增强的诊断功能。</p>
<p>Linux内核曾经有过slob分配器，已经移除了，具体请查看<a href="https://lore.kernel.org/all/20230310103210.22372-1-vbabka@suse.cz/"><code>remove SLOB and allow kfree() with kmem_cache_alloc()</code></a>。</p>
<h1 id="高端内存"><span class="header-section-number">5</span> 高端内存</h1>
<p>用<code>struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)</code>分配的page，如果指定了<code>__GFP_HIGHMEM</code>，就没有逻辑地址，如果是映射到内核地址空间，可以使用:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="co">// 高端内存就建立永久映射，可能休眠</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="dt">void</span> *kmap(<span class="kw">struct</span> page *page)</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="co">// 解除映射</span></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="dt">void</span> kunmap(<span class="kw">struct</span> page *page)</a></code></pre></div>
<p>当不能休眠时，使用临时映射（原子映射）:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="co">// 建立临时映射，禁止内核抢占</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="dt">void</span> *kmap_atomic(<span class="kw">struct</span> page *page)</a>
<a class="sourceLine" id="cb22-3" title="3"><span class="co">/**</span></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="co"> * kunmap_atomic - 解除由 kmap_atomic() 映射的虚拟地址 - 已弃用！</span></a>
<a class="sourceLine" id="cb22-5" title="5"><span class="co"> * </span><span class="an">@__addr:</span><span class="co">       要解除映射的虚拟地址</span></a>
<a class="sourceLine" id="cb22-6" title="6"><span class="co"> * </span></a>
<a class="sourceLine" id="cb22-7" title="7"><span class="co"> * 解除先前由 kmap_atomic() 映射的地址并重新启用页面错误处理。</span></a>
<a class="sourceLine" id="cb22-8" title="8"><span class="co"> * 根据 PREEMP_RT 配置，还可能重新启用迁移和抢占。用户不应该依赖这些副作用。</span></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="co"> * </span></a>
<a class="sourceLine" id="cb22-10" title="10"><span class="co"> * 映射应按照它们映射的相反顺序解除映射。</span></a>
<a class="sourceLine" id="cb22-11" title="11"><span class="co"> * 有关嵌套的详细信息，请参见 kmap_local_page()。</span></a>
<a class="sourceLine" id="cb22-12" title="12"><span class="co"> * </span></a>
<a class="sourceLine" id="cb22-13" title="13"><span class="co"> * </span><span class="an">@__addr</span><span class="co"> 可以是映射页面内的任何地址，因此不需要减去添加的任何偏移量。</span></a>
<a class="sourceLine" id="cb22-14" title="14"><span class="co"> * 与 kunmap() 相反，此函数接受从 kmap_atomic() 返回的地址，而不是传递给它的页面。</span></a>
<a class="sourceLine" id="cb22-15" title="15"><span class="co"> * 如果传递页面，编译器会发出警告。</span></a>
<a class="sourceLine" id="cb22-16" title="16"><span class="co"> */</span></a>
<a class="sourceLine" id="cb22-17" title="17">kunmap_atomic(__addr)</a></code></pre></div>
<h1 id="每cpu变量"><span class="header-section-number">6</span> 每CPU变量</h1>
<p>为每一个cpu分配一个变量可以减少数据锁定，也可以减少缓存失效（也叫缓存抖动，会影响系统性能）。</p>
<h2 id="老的方法"><span class="header-section-number">6.1</span> 老的方法</h2>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="dt">unsigned</span> <span class="dt">long</span> data[NR_CPUS];</a>
<a class="sourceLine" id="cb23-2" title="2"><span class="dt">int</span> cpu;</a>
<a class="sourceLine" id="cb23-3" title="3">cpu = get_cpu(); <span class="co">// 禁止内核抢占</span></a>
<a class="sourceLine" id="cb23-4" title="4">data[cpu]++;</a>
<a class="sourceLine" id="cb23-5" title="5">put_cpu(); <span class="co">// 激活内核抢占</span></a></code></pre></div>
<h2 id="新的接口"><span class="header-section-number">6.2</span> 新的接口</h2>
<p>编译时创建，注意不能在动态插入的模块中使用:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="co">// 定义</span></a>
<a class="sourceLine" id="cb24-2" title="2">DEFINE_PER_CPU(type, name)</a>
<a class="sourceLine" id="cb24-3" title="3"><span class="co">// 声明</span></a>
<a class="sourceLine" id="cb24-4" title="4">DECLARE_PER_CPU(type, name)</a>
<a class="sourceLine" id="cb24-5" title="5"><span class="co">// 获取并操作当前cpu变量，禁止抢占</span></a>
<a class="sourceLine" id="cb24-6" title="6">get_cpu_var(name)++</a>
<a class="sourceLine" id="cb24-7" title="7"><span class="co">// 完成，激活抢占</span></a>
<a class="sourceLine" id="cb24-8" title="8">put_cpu_var(name)</a>
<a class="sourceLine" id="cb24-9" title="9"><span class="co">// 获取并操作其他cpu上的变量，不会禁止抢占，也没有锁保护，不建议这样用</span></a>
<a class="sourceLine" id="cb24-10" title="10">per_cpu(name, cpunum)++</a></code></pre></div>
<p>动态创建:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="co">// 调用__alloc_percpu实现</span></a>
<a class="sourceLine" id="cb25-2" title="2">alloc_percpu(type) <span class="co">// __alloc_percpu(sizeof(type), __alignof__(type))</span></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="co">/**                                                           </span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="co"> * __alloc_percpu - 分配动态每CPU区域              </span></a>
<a class="sourceLine" id="cb25-5" title="5"><span class="co"> * </span><span class="an">@size:</span><span class="co"> 要分配的区域大小，以字节为单位                   </span></a>
<a class="sourceLine" id="cb25-6" title="6"><span class="co"> * </span><span class="an">@align:</span><span class="co"> 区域的对齐方式（最大为 PAGE_SIZE）                  </span></a>
<a class="sourceLine" id="cb25-7" title="7"><span class="co"> *                                                            </span></a>
<a class="sourceLine" id="cb25-8" title="8"><span class="co"> * 等效于 __alloc_percpu_gfp(size, align, %GFP_KERNEL)。</span></a>
<a class="sourceLine" id="cb25-9" title="9"><span class="co"> */</span>                                                           </a>
<a class="sourceLine" id="cb25-10" title="10"><span class="dt">void</span> __percpu *__alloc_percpu(<span class="dt">size_t</span> size, <span class="dt">size_t</span> align)      </a>
<a class="sourceLine" id="cb25-11" title="11"><span class="co">/**                                  </span></a>
<a class="sourceLine" id="cb25-12" title="12"><span class="co"> * free_percpu - 释放每CPU区域    </span></a>
<a class="sourceLine" id="cb25-13" title="13"><span class="co"> * </span><span class="an">@ptr:</span><span class="co"> 指向要释放的区域的指针     </span></a>
<a class="sourceLine" id="cb25-14" title="14"><span class="co"> *                                   </span></a>
<a class="sourceLine" id="cb25-15" title="15"><span class="co"> * 释放每CPU区域 </span><span class="an">@ptr。</span><span class="co">            </span></a>
<a class="sourceLine" id="cb25-16" title="16"><span class="co"> *                                   </span></a>
<a class="sourceLine" id="cb25-17" title="17"><span class="co"> * 上下文:                          </span></a>
<a class="sourceLine" id="cb25-18" title="18"><span class="co"> * 可以从原子上下文中调用。</span></a>
<a class="sourceLine" id="cb25-19" title="19"><span class="co"> */</span>                                  </a>
<a class="sourceLine" id="cb25-20" title="20"><span class="dt">void</span> free_percpu(<span class="dt">void</span> __percpu *ptr) </a>
<a class="sourceLine" id="cb25-21" title="21"><span class="co">// 获取并操作当前cpu变量，禁止抢占，和编译时创建的用法一样</span></a>
<a class="sourceLine" id="cb25-22" title="22">get_cpu_var(name)++</a>
<a class="sourceLine" id="cb25-23" title="23"><span class="co">// 完成，激活抢占，和编译时创建的用法一样</span></a>
<a class="sourceLine" id="cb25-24" title="24">put_cpu_var(name)</a></code></pre></div>
<h1 id="进程地址空间"><span class="header-section-number">7</span> 进程地址空间</h1>
<h2 id="内存描述符"><span class="header-section-number">7.1</span> 内存描述符</h2>
<p>内核使用内存描述符表示进程的地址空间。<code>struct task_struct</code>结构体中的<code>mm</code>成员指向进程使用的内存描述符，内核线程的没有内存描述符所以<code>mm</code>为空（可使用前一个用户空间进程的<code>mm</code>，用<code>active_mm</code>指向）。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">struct</span> mm_struct {</a>
<a class="sourceLine" id="cb26-2" title="2">        <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb26-3" title="3">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-4" title="4"><span class="co">                 * 经常被写入的字段被放置在一个单独的缓存行中。</span></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-6" title="6">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb26-7" title="7">                        <span class="co">/**</span></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="co">                         * </span><span class="an">@mm_count:</span><span class="co"> 对 &amp;struct mm_struct 的引用数量</span></a>
<a class="sourceLine" id="cb26-9" title="9"><span class="co">                         * (</span><span class="an">@mm_users</span><span class="co"> 计数为 1)。</span></a>
<a class="sourceLine" id="cb26-10" title="10"><span class="co">                         *</span></a>
<a class="sourceLine" id="cb26-11" title="11"><span class="co">                         * 使用 mmgrab()/mmdrop() 来修改。当该值降为 0 时，</span></a>
<a class="sourceLine" id="cb26-12" title="12"><span class="co">                         * 释放 &amp;struct mm_struct。</span></a>
<a class="sourceLine" id="cb26-13" title="13"><span class="co">                         */</span></a>
<a class="sourceLine" id="cb26-14" title="14">                        atomic_t mm_count;</a>
<a class="sourceLine" id="cb26-15" title="15">                } ____cacheline_aligned_in_smp;</a>
<a class="sourceLine" id="cb26-16" title="16"></a>
<a class="sourceLine" id="cb26-17" title="17">                <span class="kw">struct</span> maple_tree mm_mt;</a>
<a class="sourceLine" id="cb26-18" title="18"><span class="pp">#ifdef CONFIG_MMU</span></a>
<a class="sourceLine" id="cb26-19" title="19">                <span class="dt">unsigned</span> <span class="dt">long</span> (*get_unmapped_area) (<span class="kw">struct</span> file *filp,</a>
<a class="sourceLine" id="cb26-20" title="20">                                <span class="dt">unsigned</span> <span class="dt">long</span> addr, <span class="dt">unsigned</span> <span class="dt">long</span> len,</a>
<a class="sourceLine" id="cb26-21" title="21">                                <span class="dt">unsigned</span> <span class="dt">long</span> pgoff, <span class="dt">unsigned</span> <span class="dt">long</span> flags);</a>
<a class="sourceLine" id="cb26-22" title="22"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-23" title="23">                <span class="dt">unsigned</span> <span class="dt">long</span> mmap_base;        <span class="co">/* mmap 区域的基址 */</span></a>
<a class="sourceLine" id="cb26-24" title="24">                <span class="dt">unsigned</span> <span class="dt">long</span> mmap_legacy_base; <span class="co">/* 自下而上分配的 mmap 区域的基址 */</span></a>
<a class="sourceLine" id="cb26-25" title="25"><span class="pp">#ifdef CONFIG_HAVE_ARCH_COMPAT_MMAP_BASES</span></a>
<a class="sourceLine" id="cb26-26" title="26">                <span class="co">/* 兼容 mmap() 的基址 */</span></a>
<a class="sourceLine" id="cb26-27" title="27">                <span class="dt">unsigned</span> <span class="dt">long</span> mmap_compat_base;</a>
<a class="sourceLine" id="cb26-28" title="28">                <span class="dt">unsigned</span> <span class="dt">long</span> mmap_compat_legacy_base;</a>
<a class="sourceLine" id="cb26-29" title="29"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-30" title="30">                <span class="dt">unsigned</span> <span class="dt">long</span> task_size;        <span class="co">/* 任务虚拟内存空间的大小 */</span></a>
<a class="sourceLine" id="cb26-31" title="31">                pgd_t * pgd; <span class="co">// 页全局目录，由 page_table_lock 保护 </span></a>
<a class="sourceLine" id="cb26-32" title="32"></a>
<a class="sourceLine" id="cb26-33" title="33"><span class="pp">#ifdef CONFIG_MEMBARRIER</span></a>
<a class="sourceLine" id="cb26-34" title="34">                <span class="co">/**</span></a>
<a class="sourceLine" id="cb26-35" title="35"><span class="co">                 * </span><span class="an">@membarrier_state:</span><span class="co"> 控制 membarrier 行为的标志。</span></a>
<a class="sourceLine" id="cb26-36" title="36"><span class="co">                 *</span></a>
<a class="sourceLine" id="cb26-37" title="37"><span class="co">                 * 该字段靠近 </span><span class="an">@pgd，希望能在相同的缓存行中，以便在</span><span class="co"> switch_mm()</span></a>
<a class="sourceLine" id="cb26-38" title="38"><span class="co">                 * 中减少缓存失效。</span></a>
<a class="sourceLine" id="cb26-39" title="39"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-40" title="40">                atomic_t membarrier_state;</a>
<a class="sourceLine" id="cb26-41" title="41"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-42" title="42"></a>
<a class="sourceLine" id="cb26-43" title="43">                <span class="co">/**</span></a>
<a class="sourceLine" id="cb26-44" title="44"><span class="co">                 * </span><span class="an">@mm_users:</span><span class="co"> 包括用户空间在内的用户数量。</span></a>
<a class="sourceLine" id="cb26-45" title="45"><span class="co">                 *</span></a>
<a class="sourceLine" id="cb26-46" title="46"><span class="co">                 * 使用 mmget()/mmget_not_zero()/mmput() 来修改。当该值降为 0 时</span></a>
<a class="sourceLine" id="cb26-47" title="47"><span class="co">                 * (即任务退出且没有其他临时引用持有者时)，我们也会释放对</span></a>
<a class="sourceLine" id="cb26-48" title="48"><span class="co">                 * </span><span class="an">@mm_count</span><span class="co"> 的引用(如果 </span><span class="an">@mm_count</span><span class="co"> 也降为 0，则可能会释放 &amp;struct mm_struct)。</span></a>
<a class="sourceLine" id="cb26-49" title="49"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-50" title="50">                atomic_t mm_users; <span class="co">// 使用该地址的进程数目</span></a>
<a class="sourceLine" id="cb26-51" title="51"></a>
<a class="sourceLine" id="cb26-52" title="52"><span class="pp">#ifdef CONFIG_SCHED_MM_CID</span></a>
<a class="sourceLine" id="cb26-53" title="53">                <span class="co">/**</span></a>
<a class="sourceLine" id="cb26-54" title="54"><span class="co">                 * </span><span class="an">@pcpu_cid:</span><span class="co"> 每个 CPU 当前的 cid。</span></a>
<a class="sourceLine" id="cb26-55" title="55"><span class="co">                 *</span></a>
<a class="sourceLine" id="cb26-56" title="56"><span class="co">                 * 跟踪每个 CPU 当前分配的 mm_cid。每个 CPU 的 mm_cid 值由其各自的</span></a>
<a class="sourceLine" id="cb26-57" title="57"><span class="co">                 * 运行队列锁序列化。</span></a>
<a class="sourceLine" id="cb26-58" title="58"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-59" title="59">                <span class="kw">struct</span> mm_cid __percpu *pcpu_cid;</a>
<a class="sourceLine" id="cb26-60" title="60">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-61" title="61"><span class="co">                 * @mm_cid_next_scan: 下一次 mm_cid 扫描的时间（以 jiffies 为单位）。</span></a>
<a class="sourceLine" id="cb26-62" title="62"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-63" title="63">                <span class="dt">unsigned</span> <span class="dt">long</span> mm_cid_next_scan;</a>
<a class="sourceLine" id="cb26-64" title="64"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-65" title="65"><span class="pp">#ifdef CONFIG_MMU</span></a>
<a class="sourceLine" id="cb26-66" title="66">                atomic_long_t pgtables_bytes;   <span class="co">/* 所有页表的大小 */</span></a>
<a class="sourceLine" id="cb26-67" title="67"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-68" title="68">                <span class="dt">int</span> map_count;                  <span class="co">/* VMAs 的数量 */</span></a>
<a class="sourceLine" id="cb26-69" title="69"></a>
<a class="sourceLine" id="cb26-70" title="70">                spinlock_t page_table_lock; <span class="co">/* 保护页表和某些计数器 */</span></a>
<a class="sourceLine" id="cb26-71" title="71">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-72" title="72"><span class="co">                 * 在某些内核配置下，当前 mmap_lock 在 &#39;mm_struct&#39; 内的偏移量</span></a>
<a class="sourceLine" id="cb26-73" title="73"><span class="co">                 * 是 0x120，这是非常优化的，因为它的两个热字段 &#39;count&#39; 和 &#39;owner&#39;</span></a>
<a class="sourceLine" id="cb26-74" title="74"><span class="co">                 * 位于两个不同的缓存行中，当 mmap_lock 竞争激烈时，这两个字段都</span></a>
<a class="sourceLine" id="cb26-75" title="75"><span class="co">                 * 会被频繁访问，当前布局有助于减少缓存争用。</span></a>
<a class="sourceLine" id="cb26-76" title="76"><span class="co">                 *</span></a>
<a class="sourceLine" id="cb26-77" title="77"><span class="co">                 * 因此，在 mmap_lock 之前添加新字段时请小心，这很容易将这两个</span></a>
<a class="sourceLine" id="cb26-78" title="78"><span class="co">                 * 字段推入一个缓存行中。</span></a>
<a class="sourceLine" id="cb26-79" title="79"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-80" title="80">                <span class="kw">struct</span> rw_semaphore mmap_lock;</a>
<a class="sourceLine" id="cb26-81" title="81"></a>
<a class="sourceLine" id="cb26-82" title="82">                <span class="co">// 所有的mm_struct对象通过mmlist域连接在双链表中</span></a>
<a class="sourceLine" id="cb26-83" title="83">                <span class="kw">struct</span> list_head mmlist; <span class="co">/* 可能交换的 mm 的列表。这些</span></a>
<a class="sourceLine" id="cb26-84" title="84"><span class="co">                                          * 全局串联在 init_mm.mmlist 上，</span></a>
<a class="sourceLine" id="cb26-85" title="85"><span class="co">                                          * 由 mmlist_lock 保护。</span></a>
<a class="sourceLine" id="cb26-86" title="86"><span class="co">                                          */</span></a>
<a class="sourceLine" id="cb26-87" title="87"><span class="pp">#ifdef CONFIG_PER_VMA_LOCK</span></a>
<a class="sourceLine" id="cb26-88" title="88">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-89" title="89"><span class="co">                 * 该字段具有类似锁的语义，这意味着它有时会以 ACQUIRE/RELEASE 语义访问。</span></a>
<a class="sourceLine" id="cb26-90" title="90"><span class="co">                 * 大致而言，递增序列号等同于释放 VMAs 上的锁；读取序列号可以是获取</span></a>
<a class="sourceLine" id="cb26-91" title="91"><span class="co">                 * VMA 读锁的一部分。</span></a>
<a class="sourceLine" id="cb26-92" title="92"><span class="co">                 *</span></a>
<a class="sourceLine" id="cb26-93" title="93"><span class="co">                 * 在使用 RELEASE 语义的写 mmap_lock 下可以修改。</span></a>
<a class="sourceLine" id="cb26-94" title="94"><span class="co">                 * 当持有写 mmap_lock 时，可以在没有其他保护的情况下读取。</span></a>
<a class="sourceLine" id="cb26-95" title="95"><span class="co">                 * 如果不持有写 mmap_lock，则可以使用 ACQUIRE 语义读取。</span></a>
<a class="sourceLine" id="cb26-96" title="96"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-97" title="97">                <span class="dt">int</span> mm_lock_seq;</a>
<a class="sourceLine" id="cb26-98" title="98"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-99" title="99"></a>
<a class="sourceLine" id="cb26-100" title="100">                <span class="dt">unsigned</span> <span class="dt">long</span> hiwater_rss; <span class="co">/* RSS 使用的高水位标记 */</span></a>
<a class="sourceLine" id="cb26-101" title="101">                <span class="dt">unsigned</span> <span class="dt">long</span> hiwater_vm;  <span class="co">/* 虚拟内存使用的高水位标记 */</span></a>
<a class="sourceLine" id="cb26-102" title="102"></a>
<a class="sourceLine" id="cb26-103" title="103">                <span class="dt">unsigned</span> <span class="dt">long</span> total_vm;    <span class="co">/* 映射的总页数 */</span></a>
<a class="sourceLine" id="cb26-104" title="104">                <span class="dt">unsigned</span> <span class="dt">long</span> locked_vm;   <span class="co">/* 设置了 PG_mlocked 的页数 */</span></a>
<a class="sourceLine" id="cb26-105" title="105">                atomic64_t    pinned_vm;   <span class="co">/* 永久增加引用计数 */</span></a>
<a class="sourceLine" id="cb26-106" title="106">                <span class="dt">unsigned</span> <span class="dt">long</span> data_vm;     <span class="co">/* VM_WRITE &amp; ~VM_SHARED &amp; ~VM_STACK */</span></a>
<a class="sourceLine" id="cb26-107" title="107">                <span class="dt">unsigned</span> <span class="dt">long</span> exec_vm;     <span class="co">/* VM_EXEC &amp; ~VM_WRITE &amp; ~VM_STACK */</span></a>
<a class="sourceLine" id="cb26-108" title="108">                <span class="dt">unsigned</span> <span class="dt">long</span> stack_vm;    <span class="co">/* VM_STACK */</span></a>
<a class="sourceLine" id="cb26-109" title="109">                <span class="dt">unsigned</span> <span class="dt">long</span> def_flags;</a>
<a class="sourceLine" id="cb26-110" title="110"></a>
<a class="sourceLine" id="cb26-111" title="111">                <span class="co">/**</span></a>
<a class="sourceLine" id="cb26-112" title="112"><span class="co">                 * </span><span class="an">@write_protect_seq:</span><span class="co"> 当任何线程写保护此 mm 映射的页以强制稍后 COW 时锁定，</span></a>
<a class="sourceLine" id="cb26-113" title="113"><span class="co">                 * 例如在为 fork() 复制页表期间。</span></a>
<a class="sourceLine" id="cb26-114" title="114"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-115" title="115">                seqcount_t write_protect_seq;</a>
<a class="sourceLine" id="cb26-116" title="116"></a>
<a class="sourceLine" id="cb26-117" title="117">                spinlock_t arg_lock; <span class="co">/* 保护以下字段 */</span></a>
<a class="sourceLine" id="cb26-118" title="118"></a>
<a class="sourceLine" id="cb26-119" title="119">                <span class="dt">unsigned</span> <span class="dt">long</span> start_code, end_code, start_data, end_data;</a>
<a class="sourceLine" id="cb26-120" title="120">                <span class="dt">unsigned</span> <span class="dt">long</span> start_brk, brk, start_stack;</a>
<a class="sourceLine" id="cb26-121" title="121">                <span class="dt">unsigned</span> <span class="dt">long</span> arg_start, arg_end, env_start, env_end;</a>
<a class="sourceLine" id="cb26-122" title="122"></a>
<a class="sourceLine" id="cb26-123" title="123">                <span class="dt">unsigned</span> <span class="dt">long</span> saved_auxv[AT_VECTOR_SIZE]; <span class="co">/* 用于 /proc/PID/auxv */</span></a>
<a class="sourceLine" id="cb26-124" title="124"></a>
<a class="sourceLine" id="cb26-125" title="125">                <span class="kw">struct</span> percpu_counter rss_stat[NR_MM_COUNTERS];</a>
<a class="sourceLine" id="cb26-126" title="126"></a>
<a class="sourceLine" id="cb26-127" title="127">                <span class="kw">struct</span> linux_binfmt *binfmt;</a>
<a class="sourceLine" id="cb26-128" title="128"></a>
<a class="sourceLine" id="cb26-129" title="129">                <span class="co">/* 特定架构的 MM 上下文 */</span></a>
<a class="sourceLine" id="cb26-130" title="130">                mm_context_t context;</a>
<a class="sourceLine" id="cb26-131" title="131"></a>
<a class="sourceLine" id="cb26-132" title="132">                <span class="dt">unsigned</span> <span class="dt">long</span> flags; <span class="co">/* 必须使用原子位操作访问 */</span></a>
<a class="sourceLine" id="cb26-133" title="133"></a>
<a class="sourceLine" id="cb26-134" title="134"><span class="pp">#ifdef CONFIG_AIO</span></a>
<a class="sourceLine" id="cb26-135" title="135">                spinlock_t                      ioctx_lock;</a>
<a class="sourceLine" id="cb26-136" title="136">                <span class="kw">struct</span> kioctx_table __rcu       *ioctx_table;</a>
<a class="sourceLine" id="cb26-137" title="137"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-138" title="138"><span class="pp">#ifdef CONFIG_MEMCG</span></a>
<a class="sourceLine" id="cb26-139" title="139">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-140" title="140"><span class="co">                 * &quot;owner&quot; 指向被视为此 mm 的规范用户/所有者的任务。必须同时满足以下</span></a>
<a class="sourceLine" id="cb26-141" title="141"><span class="co">                 * 条件才能更改它:</span></a>
<a class="sourceLine" id="cb26-142" title="142"><span class="co">                 *</span></a>
<a class="sourceLine" id="cb26-143" title="143"><span class="co">                 * current == mm-&gt;owner</span></a>
<a class="sourceLine" id="cb26-144" title="144"><span class="co">                 * current-&gt;mm != mm</span></a>
<a class="sourceLine" id="cb26-145" title="145"><span class="co">                 * new_owner-&gt;mm == mm</span></a>
<a class="sourceLine" id="cb26-146" title="146"><span class="co">                 * 持有 new_owner-&gt;alloc_lock</span></a>
<a class="sourceLine" id="cb26-147" title="147"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-148" title="148">                <span class="kw">struct</span> task_struct __rcu *owner;</a>
<a class="sourceLine" id="cb26-149" title="149"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-150" title="150">                <span class="kw">struct</span> user_namespace *user_ns;</a>
<a class="sourceLine" id="cb26-151" title="151"></a>
<a class="sourceLine" id="cb26-152" title="152">                <span class="co">/* 存储指向 /proc/&lt;pid&gt;/exe 符号链接的文件引用 */</span></a>
<a class="sourceLine" id="cb26-153" title="153">                <span class="kw">struct</span> file __rcu *exe_file;</a>
<a class="sourceLine" id="cb26-154" title="154"><span class="pp">#ifdef CONFIG_MMU_NOTIFIER</span></a>
<a class="sourceLine" id="cb26-155" title="155">                <span class="kw">struct</span> mmu_notifier_subscriptions *notifier_subscriptions;</a>
<a class="sourceLine" id="cb26-156" title="156"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-157" title="157"><span class="pp">#if defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; !USE_SPLIT_PMD_PTLOCKS</span></a>
<a class="sourceLine" id="cb26-158" title="158">                pgtable_t pmd_huge_pte; <span class="co">/* 由 page_table_lock 保护 */</span></a>
<a class="sourceLine" id="cb26-159" title="159"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-160" title="160"><span class="pp">#ifdef CONFIG_NUMA_BALANCING</span></a>
<a class="sourceLine" id="cb26-161" title="161">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-162" title="162"><span class="co">                 * numa_next_scan 是下一次 PTE 重新映射为 PROT_NONE 以触发 NUMA 提示</span></a>
<a class="sourceLine" id="cb26-163" title="163"><span class="co">                 * 故障的时间；此类故障收集统计数据并在必要时将页迁移到新节点。</span></a>
<a class="sourceLine" id="cb26-164" title="164"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-165" title="165">                <span class="dt">unsigned</span> <span class="dt">long</span> numa_next_scan;</a>
<a class="sourceLine" id="cb26-166" title="166"></a>
<a class="sourceLine" id="cb26-167" title="167">                <span class="co">/* 扫描和重新映射 PTEs 的重新启动点。 */</span></a>
<a class="sourceLine" id="cb26-168" title="168">                <span class="dt">unsigned</span> <span class="dt">long</span> numa_scan_offset;</a>
<a class="sourceLine" id="cb26-169" title="169"></a>
<a class="sourceLine" id="cb26-170" title="170">                <span class="co">/* numa_scan_seq 防止两个线程重新映射 PTEs。 */</span></a>
<a class="sourceLine" id="cb26-171" title="171">                <span class="dt">int</span> numa_scan_seq;</a>
<a class="sourceLine" id="cb26-172" title="172"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-173" title="173">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-174" title="174"><span class="co">                 * 正在进行带有批处理 TLB 刷新的操作。移动进程内存的任何操作都需要</span></a>
<a class="sourceLine" id="cb26-175" title="175"><span class="co">                 * 在移动 PROT_NONE 映射页时刷新 TLB。</span></a>
<a class="sourceLine" id="cb26-176" title="176"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-177" title="177">                atomic_t tlb_flush_pending;</a>
<a class="sourceLine" id="cb26-178" title="178"><span class="pp">#ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span></a>
<a class="sourceLine" id="cb26-179" title="179">                <span class="co">/* 参见 flush_tlb_batched_pending() */</span></a>
<a class="sourceLine" id="cb26-180" title="180">                atomic_t tlb_flush_batched;</a>
<a class="sourceLine" id="cb26-181" title="181"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-182" title="182">                <span class="kw">struct</span> uprobes_state uprobes_state;</a>
<a class="sourceLine" id="cb26-183" title="183"><span class="pp">#ifdef CONFIG_PREEMPT_RT</span></a>
<a class="sourceLine" id="cb26-184" title="184">                <span class="kw">struct</span> rcu_head delayed_drop;</a>
<a class="sourceLine" id="cb26-185" title="185"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-186" title="186"><span class="pp">#ifdef CONFIG_HUGETLB_PAGE</span></a>
<a class="sourceLine" id="cb26-187" title="187">                atomic_long_t hugetlb_usage;</a>
<a class="sourceLine" id="cb26-188" title="188"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-189" title="189">                <span class="kw">struct</span> work_struct async_put_work;</a>
<a class="sourceLine" id="cb26-190" title="190"></a>
<a class="sourceLine" id="cb26-191" title="191"><span class="pp">#ifdef CONFIG_IOMMU_SVA</span></a>
<a class="sourceLine" id="cb26-192" title="192">                u32 pasid;</a>
<a class="sourceLine" id="cb26-193" title="193"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-194" title="194"><span class="pp">#ifdef CONFIG_KSM</span></a>
<a class="sourceLine" id="cb26-195" title="195">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-196" title="196"><span class="co">                 * 表示此进程中有多少页参与 KSM 合并（不包括 ksm_zero_pages）。</span></a>
<a class="sourceLine" id="cb26-197" title="197"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-198" title="198">                <span class="dt">unsigned</span> <span class="dt">long</span> ksm_merging_pages;</a>
<a class="sourceLine" id="cb26-199" title="199">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-200" title="200"><span class="co">                 * 表示检查是否进行 KSM 合并的页数，包括已合并和未合并的。</span></a>
<a class="sourceLine" id="cb26-201" title="201"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-202" title="202">                <span class="dt">unsigned</span> <span class="dt">long</span> ksm_rmap_items;</a>
<a class="sourceLine" id="cb26-203" title="203">                <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-204" title="204"><span class="co">                 * 表示启用 KSM use_zero_pages 时，有多少空页与内核零页合并。</span></a>
<a class="sourceLine" id="cb26-205" title="205"><span class="co">                 */</span></a>
<a class="sourceLine" id="cb26-206" title="206">                <span class="dt">unsigned</span> <span class="dt">long</span> ksm_zero_pages;</a>
<a class="sourceLine" id="cb26-207" title="207"><span class="pp">#endif </span><span class="co">/* CONFIG_KSM */</span></a>
<a class="sourceLine" id="cb26-208" title="208"><span class="pp">#ifdef CONFIG_LRU_GEN</span></a>
<a class="sourceLine" id="cb26-209" title="209">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb26-210" title="210">                        <span class="co">/* 此 mm_struct 位于 lru_gen_mm_list 上 */</span></a>
<a class="sourceLine" id="cb26-211" title="211">                        <span class="kw">struct</span> list_head list;</a>
<a class="sourceLine" id="cb26-212" title="212">                        <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-213" title="213"><span class="co">                         * 切换到此 mm_struct 时设置，作为自上次每节点页表遍历清除相应</span></a>
<a class="sourceLine" id="cb26-214" title="214"><span class="co">                         * 位以来是否使用过的提示。</span></a>
<a class="sourceLine" id="cb26-215" title="215"><span class="co">                         */</span></a>
<a class="sourceLine" id="cb26-216" title="216">                        <span class="dt">unsigned</span> <span class="dt">long</span> bitmap;</a>
<a class="sourceLine" id="cb26-217" title="217"><span class="pp">#ifdef CONFIG_MEMCG</span></a>
<a class="sourceLine" id="cb26-218" title="218">                        <span class="co">/* 指向上面 &quot;owner&quot; 的 memcg */</span></a>
<a class="sourceLine" id="cb26-219" title="219">                        <span class="kw">struct</span> mem_cgroup *memcg;</a>
<a class="sourceLine" id="cb26-220" title="220"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb26-221" title="221">                } lru_gen;</a>
<a class="sourceLine" id="cb26-222" title="222"><span class="pp">#endif </span><span class="co">/* CONFIG_LRU_GEN */</span></a>
<a class="sourceLine" id="cb26-223" title="223">        } __randomize_layout;</a>
<a class="sourceLine" id="cb26-224" title="224"></a>
<a class="sourceLine" id="cb26-225" title="225">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb26-226" title="226"><span class="co">         * mm_cpumask 需要位于 mm_struct 的末尾，因为它是基于 nr_cpu_ids 动态调整大小的。</span></a>
<a class="sourceLine" id="cb26-227" title="227"><span class="co">         */</span></a>
<a class="sourceLine" id="cb26-228" title="228">        <span class="dt">unsigned</span> <span class="dt">long</span> cpu_bitmap[];</a>
<a class="sourceLine" id="cb26-229" title="229">};</a></code></pre></div>
<h2 id="相关函数"><span class="header-section-number">7.2</span> 相关函数</h2>
<p>进程创建时:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1">fork</a>
<a class="sourceLine" id="cb27-2" title="2">  copy_mm</a>
<a class="sourceLine" id="cb27-3" title="3">    mm = oldmm <span class="co">// if (clone_flags &amp; CLONE_VM)</span></a>
<a class="sourceLine" id="cb27-4" title="4">    dup_mm</a>
<a class="sourceLine" id="cb27-5" title="5">      allocate_mm</a>
<a class="sourceLine" id="cb27-6" title="6">        kmem_cache_alloc</a></code></pre></div>
<p>进程退出时:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1">exit_mm</a>
<a class="sourceLine" id="cb28-2" title="2">  mmput <span class="co">// 减少 mm_users</span></a>
<a class="sourceLine" id="cb28-3" title="3">    __mmput</a>
<a class="sourceLine" id="cb28-4" title="4">      mmdrop <span class="co">// 减少mm_count</span></a>
<a class="sourceLine" id="cb28-5" title="5">        mm_count</a>
<a class="sourceLine" id="cb28-6" title="6">          free_mm</a>
<a class="sourceLine" id="cb28-7" title="7">            kmem_cache_free</a></code></pre></div>
<h2 id="虚拟内存区域"><span class="header-section-number">7.3</span> 虚拟内存区域</h2>
<p>可被进程合法访问的地址空间称为内存区域（memory area），内存区域也称为虚拟内存区域（Virtual Memory Areas, VMAs）。如果两个独立的进程将同一个文件映射到各自的地址空间，不会共享<code>vm_area_struct</code>；如果两个线程共享一个地址空间，则共享<code>vm_area_struct</code>。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="co"> * 这个结构体描述了一个虚拟内存区域。每个 VM 区域/任务有一个这样的结构体。</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="co"> * 一个 VM 区域是指进程虚拟内存空间中具有特定页错误处理规则的部分</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="co"> * （例如共享库、可执行区域等）。</span></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="kw">struct</span> vm_area_struct {</a>
<a class="sourceLine" id="cb29-7" title="7">        <span class="co">/* 第一缓存行包含用于 VMA 树遍历的信息。 */</span></a>
<a class="sourceLine" id="cb29-8" title="8"></a>
<a class="sourceLine" id="cb29-9" title="9">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb29-10" title="10">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb29-11" title="11">                        <span class="co">/* VMA 覆盖 mm 内的 [vm_start; vm_end) 地址 */</span></a>
<a class="sourceLine" id="cb29-12" title="12">                        <span class="dt">unsigned</span> <span class="dt">long</span> vm_start;</a>
<a class="sourceLine" id="cb29-13" title="13">                        <span class="dt">unsigned</span> <span class="dt">long</span> vm_end;</a>
<a class="sourceLine" id="cb29-14" title="14">                };</a>
<a class="sourceLine" id="cb29-15" title="15"><span class="pp">#ifdef CONFIG_PER_VMA_LOCK</span></a>
<a class="sourceLine" id="cb29-16" title="16">                <span class="kw">struct</span> rcu_head vm_rcu; <span class="co">/* 用于延迟释放。 */</span></a>
<a class="sourceLine" id="cb29-17" title="17"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb29-18" title="18">        };</a>
<a class="sourceLine" id="cb29-19" title="19"></a>
<a class="sourceLine" id="cb29-20" title="20">        <span class="kw">struct</span> mm_struct *vm_mm;        <span class="co">/* 我们所属的地址空间。 */</span></a>
<a class="sourceLine" id="cb29-21" title="21">        pgprot_t vm_page_prot;    <span class="co">/* 该 VMA 的访问权限。 */</span></a>
<a class="sourceLine" id="cb29-22" title="22"></a>
<a class="sourceLine" id="cb29-23" title="23">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb29-24" title="24"><span class="co">         * 标志，参见 mm.h。</span></a>
<a class="sourceLine" id="cb29-25" title="25"><span class="co">         * 查看 VM_READ 等宏定义。</span></a>
<a class="sourceLine" id="cb29-26" title="26"><span class="co">         * 其中VM_SEQ_READ和VM_RAND_READ可通过系统调用madvise(behavior)设置，behavior可以是MADV_SEQUENTIAL或MADV_RANDOM</span></a>
<a class="sourceLine" id="cb29-27" title="27"><span class="co">         * 要修改请使用 vm_flags_{init|reset|set|clear|mod} 函数。</span></a>
<a class="sourceLine" id="cb29-28" title="28"><span class="co">         */</span></a>
<a class="sourceLine" id="cb29-29" title="29">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb29-30" title="30">                <span class="dt">const</span> vm_flags_t vm_flags;</a>
<a class="sourceLine" id="cb29-31" title="31">                vm_flags_t __private __vm_flags;</a>
<a class="sourceLine" id="cb29-32" title="32">        };</a>
<a class="sourceLine" id="cb29-33" title="33"></a>
<a class="sourceLine" id="cb29-34" title="34"><span class="pp">#ifdef CONFIG_PER_VMA_LOCK</span></a>
<a class="sourceLine" id="cb29-35" title="35">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb29-36" title="36"><span class="co">         * 只能在同时持有以下两者时写入（使用 WRITE_ONCE()）:</span></a>
<a class="sourceLine" id="cb29-37" title="37"><span class="co">         *  - mmap_lock（写模式）</span></a>
<a class="sourceLine" id="cb29-38" title="38"><span class="co">         *  - vm_lock-&gt;lock（写模式）</span></a>
<a class="sourceLine" id="cb29-39" title="39"><span class="co">         * 在持有以下任一时可以可靠读取:</span></a>
<a class="sourceLine" id="cb29-40" title="40"><span class="co">         *  - mmap_lock（读或写模式）</span></a>
<a class="sourceLine" id="cb29-41" title="41"><span class="co">         *  - vm_lock-&gt;lock（读或写模式）</span></a>
<a class="sourceLine" id="cb29-42" title="42"><span class="co">         * 可以在不持有任何锁时不可靠地读取（使用 READ_ONCE()），</span></a>
<a class="sourceLine" id="cb29-43" title="43"><span class="co">         * 这种情况下只有 RCU 可以保持 VMA 结构体已分配。</span></a>
<a class="sourceLine" id="cb29-44" title="44"><span class="co">         *</span></a>
<a class="sourceLine" id="cb29-45" title="45"><span class="co">         * 该序列计数器明确允许溢出；序列计数器重用只会导致偶尔</span></a>
<a class="sourceLine" id="cb29-46" title="46"><span class="co">         * 采用慢路径。</span></a>
<a class="sourceLine" id="cb29-47" title="47"><span class="co">         */</span></a>
<a class="sourceLine" id="cb29-48" title="48">        <span class="dt">int</span> vm_lock_seq;</a>
<a class="sourceLine" id="cb29-49" title="49">        <span class="kw">struct</span> vma_lock *vm_lock;</a>
<a class="sourceLine" id="cb29-50" title="50"></a>
<a class="sourceLine" id="cb29-51" title="51">        <span class="co">/* 指示从 mm-&gt;mm_mt 树分离的区域的标志 */</span></a>
<a class="sourceLine" id="cb29-52" title="52">        <span class="dt">bool</span> detached;</a>
<a class="sourceLine" id="cb29-53" title="53"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb29-54" title="54"></a>
<a class="sourceLine" id="cb29-55" title="55">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb29-56" title="56"><span class="co">         * 对于具有地址空间和后备存储的区域，</span></a>
<a class="sourceLine" id="cb29-57" title="57"><span class="co">         * 链接到 address_space-&gt;i_mmap 区间树。</span></a>
<a class="sourceLine" id="cb29-58" title="58"><span class="co">         *</span></a>
<a class="sourceLine" id="cb29-59" title="59"><span class="co">         */</span></a>
<a class="sourceLine" id="cb29-60" title="60">        <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb29-61" title="61">                <span class="kw">struct</span> rb_node rb;</a>
<a class="sourceLine" id="cb29-62" title="62">                <span class="dt">unsigned</span> <span class="dt">long</span> rb_subtree_last;</a>
<a class="sourceLine" id="cb29-63" title="63">        } shared;</a>
<a class="sourceLine" id="cb29-64" title="64"></a>
<a class="sourceLine" id="cb29-65" title="65">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb29-66" title="66"><span class="co">         * 一个文件的 MAP_PRIVATE vma 可以同时在 i_mmap 树和 anon_vma</span></a>
<a class="sourceLine" id="cb29-67" title="67"><span class="co">         * 列表中，发生 COW 后。MAP_SHARED vma 只能在 i_mmap 树中。</span></a>
<a class="sourceLine" id="cb29-68" title="68"><span class="co">         * 匿名 MAP_PRIVATE、栈或 brk vma（文件指针为 NULL）只能在</span></a>
<a class="sourceLine" id="cb29-69" title="69"><span class="co">         * anon_vma 列表中。</span></a>
<a class="sourceLine" id="cb29-70" title="70"><span class="co">         */</span></a>
<a class="sourceLine" id="cb29-71" title="71">        <span class="kw">struct</span> list_head anon_vma_chain; <span class="co">/* 由 mmap_lock 和 page_table_lock</span></a>
<a class="sourceLine" id="cb29-72" title="72"><span class="co">                                                                          * 序列化 */</span></a>
<a class="sourceLine" id="cb29-73" title="73">        <span class="kw">struct</span> anon_vma *anon_vma;         <span class="co">/* 由 page_table_lock 序列化 */</span></a>
<a class="sourceLine" id="cb29-74" title="74"></a>
<a class="sourceLine" id="cb29-75" title="75">        <span class="co">/* 处理该结构体的函数指针。 */</span></a>
<a class="sourceLine" id="cb29-76" title="76">        <span class="dt">const</span> <span class="kw">struct</span> vm_operations_struct *vm_ops;</a>
<a class="sourceLine" id="cb29-77" title="77"></a>
<a class="sourceLine" id="cb29-78" title="78">        <span class="co">/* 我们后备存储的信息: */</span></a>
<a class="sourceLine" id="cb29-79" title="79">        <span class="dt">unsigned</span> <span class="dt">long</span> vm_pgoff;  <span class="co">/* 在 PAGE_SIZE 单位内的 vm_file 偏移 */</span></a>
<a class="sourceLine" id="cb29-80" title="80">        <span class="kw">struct</span> file *vm_file;      <span class="co">/* 我们映射的文件（可以为 NULL）。 */</span></a>
<a class="sourceLine" id="cb29-81" title="81">        <span class="dt">void</span> *vm_private_data;    <span class="co">/* 曾经是 vm_pte（共享内存） */</span></a>
<a class="sourceLine" id="cb29-82" title="82"></a>
<a class="sourceLine" id="cb29-83" title="83"><span class="pp">#ifdef CONFIG_ANON_VMA_NAME</span></a>
<a class="sourceLine" id="cb29-84" title="84">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb29-85" title="85"><span class="co">         * 对于私有和共享匿名映射，一个指向包含 vma 名称的以空字符结尾的字符串的指针，</span></a>
<a class="sourceLine" id="cb29-86" title="86"><span class="co">         * 如果未命名则为 NULL。由 mmap_lock 序列化。使用 anon_vma_name 访问。</span></a>
<a class="sourceLine" id="cb29-87" title="87"><span class="co">         */</span></a>
<a class="sourceLine" id="cb29-88" title="88">        <span class="kw">struct</span> anon_vma_name *anon_name;</a>
<a class="sourceLine" id="cb29-89" title="89"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb29-90" title="90"><span class="pp">#ifdef CONFIG_SWAP</span></a>
<a class="sourceLine" id="cb29-91" title="91">        atomic_long_t swap_readahead_info;</a>
<a class="sourceLine" id="cb29-92" title="92"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb29-93" title="93"><span class="pp">#ifndef CONFIG_MMU</span></a>
<a class="sourceLine" id="cb29-94" title="94">        <span class="kw">struct</span> vm_region *vm_region;    <span class="co">/* NOMMU 映射区域 */</span></a>
<a class="sourceLine" id="cb29-95" title="95"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb29-96" title="96"><span class="pp">#ifdef CONFIG_NUMA</span></a>
<a class="sourceLine" id="cb29-97" title="97">        <span class="kw">struct</span> mempolicy *vm_policy;    <span class="co">/* 该 VMA 的 NUMA 策略 */</span></a>
<a class="sourceLine" id="cb29-98" title="98"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb29-99" title="99"><span class="pp">#ifdef CONFIG_NUMA_BALANCING</span></a>
<a class="sourceLine" id="cb29-100" title="100">        <span class="kw">struct</span> vma_numab_state *numab_state;    <span class="co">/* NUMA 平衡状态 */</span></a>
<a class="sourceLine" id="cb29-101" title="101"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb29-102" title="102">        <span class="kw">struct</span> vm_userfaultfd_ctx vm_userfaultfd_ctx;</a>
<a class="sourceLine" id="cb29-103" title="103">} __randomize_layout;</a></code></pre></div>
<p>常见的段（这里的“段”英文是“section”）:</p>
<ul>
<li>TEXT段: 程序代码段，<code>vm_flags</code>字段为<code>VM_EXEC</code>和<code>VM_READ</code>，<code>vm_file</code>字段不为<code>NULL</code>。</li>
<li>DATA段: 静态初始化的数据，所以有初值的全局变量（不为0）和static变量在data区。<code>vm_flags</code>为<code>VM_READ</code>和<code>VM_WRITE</code>。</li>
<li>BSS段: Block Started by Symbol，通常是指用来存放程序中<strong>未初始化或初始化为0</strong>的全局变量的一块内存区域，在程序载入时由内核清0。<code>vm_flags</code>为<code>VM_READ</code>和<code>VM_WRITE</code>。</li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="dt">int</span> global_var = <span class="dv">100</span>;           <span class="co">// 已初始化的全局变量 -&gt; .data段</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="dt">static</span> <span class="dt">int</span> static_global = <span class="dv">200</span>; <span class="co">// 已初始化的静态全局变量 -&gt; .data段</span></a>
<a class="sourceLine" id="cb30-3" title="3"></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="dt">int</span> uninit_global;              <span class="co">// 未初始化的全局变量，默认为0 -&gt; .bss段</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="dt">static</span> <span class="dt">int</span> static_uninit;       <span class="co">// 未初始化的静态全局变量，默认为0 -&gt; .bss段</span></a>
<a class="sourceLine" id="cb30-6" title="6"><span class="dt">int</span> zero_global = <span class="dv">0</span>;            <span class="co">// 初始化为0的全局变量 -&gt; .bss段</span></a>
<a class="sourceLine" id="cb30-7" title="7"></a>
<a class="sourceLine" id="cb30-8" title="8"><span class="dt">void</span> func()</a>
<a class="sourceLine" id="cb30-9" title="9">{</a>
<a class="sourceLine" id="cb30-10" title="10">        <span class="dt">static</span> <span class="dt">int</span> static_local_uninit;    <span class="co">// 未初始化的静态局部变量，默认为0 -&gt; .bss段</span></a>
<a class="sourceLine" id="cb30-11" title="11">        <span class="dt">static</span> <span class="dt">int</span> static_zero_local = <span class="dv">0</span>;  <span class="co">// 初始化为0的静态局部变量 -&gt; .bss段</span></a>
<a class="sourceLine" id="cb30-12" title="12"></a>
<a class="sourceLine" id="cb30-13" title="13">        <span class="dt">static</span> <span class="dt">int</span> static_local = <span class="dv">300</span>;     <span class="co">// 已初始化的静态局部变量 -&gt; .data段</span></a>
<a class="sourceLine" id="cb30-14" title="14">}</a></code></pre></div>
<h2 id="vma操作"><span class="header-section-number">7.4</span> VMA操作</h2>
<p><code>vm_area_struct</code>中的<code>vm_ops</code>字段:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="co"> * 这些是虚拟内存管理函数 - 打开一个区域、关闭和取消映射它</span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="co"> * （需要保持磁盘上的文件最新等），当发生无页异常或写保护页异常时</span></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="co"> * 调用的函数指针。</span></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb31-6" title="6"><span class="kw">struct</span> vm_operations_struct {</a>
<a class="sourceLine" id="cb31-7" title="7">        <span class="co">// 指定的内存区域被加到地址空间时，open被调用</span></a>
<a class="sourceLine" id="cb31-8" title="8">        <span class="dt">void</span> (*open)(<span class="kw">struct</span> vm_area_struct * area);</a>
<a class="sourceLine" id="cb31-9" title="9">        <span class="co">/**</span></a>
<a class="sourceLine" id="cb31-10" title="10"><span class="co">         * </span><span class="an">@close:</span><span class="co"> 当 VMA 从内存管理中移除时调用。</span></a>
<a class="sourceLine" id="cb31-11" title="11"><span class="co">         * 上下文: 用户上下文。可能会休眠。调用者持有 mmap_lock。</span></a>
<a class="sourceLine" id="cb31-12" title="12"><span class="co">         */</span></a>
<a class="sourceLine" id="cb31-13" title="13">        <span class="dt">void</span> (*close)(<span class="kw">struct</span> vm_area_struct * area);</a>
<a class="sourceLine" id="cb31-14" title="14">        <span class="co">/* 在拆分前的任何时间调用以检查是否允许拆分 */</span></a>
<a class="sourceLine" id="cb31-15" title="15">        <span class="dt">int</span> (*may_split)(<span class="kw">struct</span> vm_area_struct *area, <span class="dt">unsigned</span> <span class="dt">long</span> addr);</a>
<a class="sourceLine" id="cb31-16" title="16">        <span class="dt">int</span> (*mremap)(<span class="kw">struct</span> vm_area_struct *area);</a>
<a class="sourceLine" id="cb31-17" title="17">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb31-18" title="18"><span class="co">         * 由 mprotect() 调用以在 mprotect() 完成之前进行特定于驱动程序的权限检查。</span></a>
<a class="sourceLine" id="cb31-19" title="19"><span class="co">         * VMA 不能被修改。如果 mprotect() 可以继续则返回 0。</span></a>
<a class="sourceLine" id="cb31-20" title="20"><span class="co">         */</span></a>
<a class="sourceLine" id="cb31-21" title="21">        <span class="dt">int</span> (*mprotect)(<span class="kw">struct</span> vm_area_struct *vma, <span class="dt">unsigned</span> <span class="dt">long</span> start,</a>
<a class="sourceLine" id="cb31-22" title="22">                        <span class="dt">unsigned</span> <span class="dt">long</span> end, <span class="dt">unsigned</span> <span class="dt">long</span> newflags);</a>
<a class="sourceLine" id="cb31-23" title="23">        vm_fault_t (*fault)(<span class="kw">struct</span> vm_fault *vmf);</a>
<a class="sourceLine" id="cb31-24" title="24">        vm_fault_t (*huge_fault)(<span class="kw">struct</span> vm_fault *vmf, <span class="dt">unsigned</span> <span class="dt">int</span> order);</a>
<a class="sourceLine" id="cb31-25" title="25">        vm_fault_t (*map_pages)(<span class="kw">struct</span> vm_fault *vmf,</a>
<a class="sourceLine" id="cb31-26" title="26">                        pgoff_t start_pgoff, pgoff_t end_pgoff);</a>
<a class="sourceLine" id="cb31-27" title="27">        <span class="dt">unsigned</span> <span class="dt">long</span> (*pagesize)(<span class="kw">struct</span> vm_area_struct * area);</a>
<a class="sourceLine" id="cb31-28" title="28"></a>
<a class="sourceLine" id="cb31-29" title="29">        <span class="co">/* 通知一个以前只读的页面即将变为可写，如果返回错误将导致 SIGBUS */</span></a>
<a class="sourceLine" id="cb31-30" title="30">        vm_fault_t (*page_mkwrite)(<span class="kw">struct</span> vm_fault *vmf);</a>
<a class="sourceLine" id="cb31-31" title="31"></a>
<a class="sourceLine" id="cb31-32" title="32">        <span class="co">/* 当使用 VM_PFNMAP|VM_MIXEDMAP 时与 page_mkwrite 相同 */</span></a>
<a class="sourceLine" id="cb31-33" title="33">        vm_fault_t (*pfn_mkwrite)(<span class="kw">struct</span> vm_fault *vmf);</a>
<a class="sourceLine" id="cb31-34" title="34"></a>
<a class="sourceLine" id="cb31-35" title="35">        <span class="co">/* 当 get_user_pages() 失败时由 access_process_vm 调用，通常用于特殊的 VMA。</span></a>
<a class="sourceLine" id="cb31-36" title="36"><span class="co">         * 另请参见 generic_access_phys()，它是一个适用于任何 iomem 映射的通用实现。</span></a>
<a class="sourceLine" id="cb31-37" title="37"><span class="co">         */</span></a>
<a class="sourceLine" id="cb31-38" title="38">        <span class="dt">int</span> (*access)(<span class="kw">struct</span> vm_area_struct *vma, <span class="dt">unsigned</span> <span class="dt">long</span> addr,</a>
<a class="sourceLine" id="cb31-39" title="39">                      <span class="dt">void</span> *buf, <span class="dt">int</span> len, <span class="dt">int</span> write);</a>
<a class="sourceLine" id="cb31-40" title="40"></a>
<a class="sourceLine" id="cb31-41" title="41">        <span class="co">/* 由 /proc/PID/maps 代码调用，以询问 VMA 是否有特殊名称。</span></a>
<a class="sourceLine" id="cb31-42" title="42"><span class="co">         * 返回非 NULL 还会导致此 VMA 无条件地被转储。</span></a>
<a class="sourceLine" id="cb31-43" title="43"><span class="co">         */</span></a>
<a class="sourceLine" id="cb31-44" title="44">        <span class="dt">const</span> <span class="dt">char</span> *(*name)(<span class="kw">struct</span> vm_area_struct *vma);</a>
<a class="sourceLine" id="cb31-45" title="45"></a>
<a class="sourceLine" id="cb31-46" title="46"><span class="pp">#ifdef CONFIG_NUMA</span></a>
<a class="sourceLine" id="cb31-47" title="47">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb31-48" title="48"><span class="co">         * set_policy() 操作必须在返回时为任何非 NULL 的 @new mempolicy 添加引用</span></a>
<a class="sourceLine" id="cb31-49" title="49"><span class="co">         * 以保持策略。调用者应传递 NULL @new 以移除策略并回退到周围的上下文</span></a>
<a class="sourceLine" id="cb31-50" title="50"><span class="co">         * ——即不要安装 MPOL_DEFAULT 策略，也不要安装任务或系统默认的 mempolicy。</span></a>
<a class="sourceLine" id="cb31-51" title="51"><span class="co">         */</span></a>
<a class="sourceLine" id="cb31-52" title="52">        <span class="dt">int</span> (*set_policy)(<span class="kw">struct</span> vm_area_struct *vma, <span class="kw">struct</span> mempolicy *new);</a>
<a class="sourceLine" id="cb31-53" title="53"></a>
<a class="sourceLine" id="cb31-54" title="54">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb31-55" title="55"><span class="co">         * get_policy() 操作必须为标记为 MPOL_SHARED 的任何 (vma,addr) 处的策略添加引用 [mpol_get()]。</span></a>
<a class="sourceLine" id="cb31-56" title="56"><span class="co">         * mm/mempolicy.c 中的共享策略基础设施将自动执行此操作。</span></a>
<a class="sourceLine" id="cb31-57" title="57"><span class="co">         * 如果 (vma,addr) 处的策略未标记为 MPOL_SHARED，则 get_policy() 不得添加引用。</span></a>
<a class="sourceLine" id="cb31-58" title="58"><span class="co">         * vma 策略受 mmap_lock 保护。如果在该地址处没有 [共享/vma] mempolicy，</span></a>
<a class="sourceLine" id="cb31-59" title="59"><span class="co">         * 则 get_policy() 操作必须返回 NULL——即不要“回退”到任务或系统默认策略。</span></a>
<a class="sourceLine" id="cb31-60" title="60"><span class="co">         */</span></a>
<a class="sourceLine" id="cb31-61" title="61">        <span class="kw">struct</span> mempolicy *(*get_policy)(<span class="kw">struct</span> vm_area_struct *vma,</a>
<a class="sourceLine" id="cb31-62" title="62">                                        <span class="dt">unsigned</span> <span class="dt">long</span> addr);</a>
<a class="sourceLine" id="cb31-63" title="63"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb31-64" title="64">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb31-65" title="65"><span class="co">         * 由 vm_normal_page() 调用，用于特殊的 PTEs 以查找 @addr 的页面。</span></a>
<a class="sourceLine" id="cb31-66" title="66"><span class="co">         * 如果默认行为（使用 pte_page()）找不到正确的页面，这很有用。</span></a>
<a class="sourceLine" id="cb31-67" title="67"><span class="co">         */</span></a>
<a class="sourceLine" id="cb31-68" title="68">        <span class="kw">struct</span> page *(*find_special_page)(<span class="kw">struct</span> vm_area_struct *vma,</a>
<a class="sourceLine" id="cb31-69" title="69">                                          <span class="dt">unsigned</span> <span class="dt">long</span> addr);</a>
<a class="sourceLine" id="cb31-70" title="70">};</a></code></pre></div>
<h2 id="查看内存区域"><span class="header-section-number">7.5</span> 查看内存区域</h2>
<p>我们看一个最简单的程序<code>test.c</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> *argv[]) {</a>
<a class="sourceLine" id="cb32-4" title="4">        printf(<span class="st">&quot;Hello, World!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb32-5" title="5">        <span class="cf">while</span> (<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb32-6" title="6">                <span class="co">// 在循环中可以执行其他操作，这里我们只让它一直循环</span></a>
<a class="sourceLine" id="cb32-7" title="7">        }</a>
<a class="sourceLine" id="cb32-8" title="8">        <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb32-9" title="9">}</a></code></pre></div>
<p>然后编译运行:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb33-1" title="1"><span class="fu">gcc</span> -o test test.c</a>
<a class="sourceLine" id="cb33-2" title="2"><span class="ex">./test</span> <span class="kw">&amp;</span> <span class="co"># 后台运行，会打印出进程号</span></a></code></pre></div>
<p>查看内存区域:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb34-1" title="1"><span class="fu">cat</span> /proc/2985/maps</a>
<a class="sourceLine" id="cb34-2" title="2"><span class="ex">00400000-00401000</span> r--p 00000000 fd:02 806031960                          /root/test</a>
<a class="sourceLine" id="cb34-3" title="3"><span class="ex">00401000-00402000</span> r-xp 00001000 fd:02 806031960                          /root/test</a>
<a class="sourceLine" id="cb34-4" title="4"><span class="ex">00402000-00403000</span> r--p 00002000 fd:02 806031960                          /root/test</a>
<a class="sourceLine" id="cb34-5" title="5"><span class="ex">00403000-00404000</span> r--p 00002000 fd:02 806031960                          /root/test</a>
<a class="sourceLine" id="cb34-6" title="6"><span class="ex">00404000-00405000</span> rw-p 00003000 fd:02 806031960                          /root/test</a>
<a class="sourceLine" id="cb34-7" title="7"><span class="ex">36732000-36753000</span> rw-p 00000000 00:00 0                                  [heap]</a>
<a class="sourceLine" id="cb34-8" title="8"><span class="ex">7f4ed4e61000-7f4ed4e64000</span> rw-p 00000000 00:00 0 </a>
<a class="sourceLine" id="cb34-9" title="9"><span class="ex">7f4ed4e64000-7f4ed4e8c000</span> r--p 00000000 fd:02 268556763                  /usr/lib64/libc.so.6</a>
<a class="sourceLine" id="cb34-10" title="10"><span class="ex">7f4ed4e8c000-7f4ed4ff5000</span> r-xp 00028000 fd:02 268556763                  /usr/lib64/libc.so.6</a>
<a class="sourceLine" id="cb34-11" title="11"><span class="ex">7f4ed4ff5000-7f4ed5043000</span> r--p 00191000 fd:02 268556763                  /usr/lib64/libc.so.6</a>
<a class="sourceLine" id="cb34-12" title="12"><span class="ex">7f4ed5043000-7f4ed5047000</span> r--p 001de000 fd:02 268556763                  /usr/lib64/libc.so.6</a>
<a class="sourceLine" id="cb34-13" title="13"><span class="ex">7f4ed5047000-7f4ed5049000</span> rw-p 001e2000 fd:02 268556763                  /usr/lib64/libc.so.6</a>
<a class="sourceLine" id="cb34-14" title="14"><span class="ex">7f4ed5049000-7f4ed5053000</span> rw-p 00000000 00:00 0 </a>
<a class="sourceLine" id="cb34-15" title="15"><span class="ex">7f4ed505b000-7f4ed505f000</span> r--p 00000000 00:00 0                          [vvar]</a>
<a class="sourceLine" id="cb34-16" title="16"><span class="ex">7f4ed505f000-7f4ed5061000</span> r-xp 00000000 00:00 0                          [vdso]</a>
<a class="sourceLine" id="cb34-17" title="17"><span class="ex">7f4ed5061000-7f4ed5062000</span> r--p 00000000 fd:02 268556760                  /usr/lib64/ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb34-18" title="18"><span class="ex">7f4ed5062000-7f4ed5089000</span> r-xp 00001000 fd:02 268556760                  /usr/lib64/ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb34-19" title="19"><span class="ex">7f4ed5089000-7f4ed5093000</span> r--p 00028000 fd:02 268556760                  /usr/lib64/ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb34-20" title="20"><span class="ex">7f4ed5093000-7f4ed5095000</span> r--p 00032000 fd:02 268556760                  /usr/lib64/ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb34-21" title="21"><span class="ex">7f4ed5095000-7f4ed5097000</span> rw-p 00034000 fd:02 268556760                  /usr/lib64/ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb34-22" title="22"><span class="ex">7ffc36b1b000-7ffc36b3c000</span> rw-p 00000000 00:00 0                          [stack]</a>
<a class="sourceLine" id="cb34-23" title="23"><span class="ex">ffffffffff600000-ffffffffff601000</span> --xp 00000000 00:00 0                  [vsyscall]</a></code></pre></div>
<p>还可以用更方便阅读的形式输出:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb35-1" title="1"><span class="ex">pmap</span> 2985</a>
<a class="sourceLine" id="cb35-2" title="2"><span class="ex">3090</span>:   ./test</a>
<a class="sourceLine" id="cb35-3" title="3"><span class="ex">0000000000400000</span>      4K r---- test</a>
<a class="sourceLine" id="cb35-4" title="4"><span class="ex">0000000000401000</span>      4K r-x-- test <span class="co"># 可读和可执行，代码段</span></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="ex">0000000000402000</span>      4K r---- test</a>
<a class="sourceLine" id="cb35-6" title="6"><span class="ex">0000000000403000</span>      4K r---- test</a>
<a class="sourceLine" id="cb35-7" title="7"><span class="ex">0000000000404000</span>      4K rw--- test <span class="co"># 可读和可写，数据段</span></a>
<a class="sourceLine" id="cb35-8" title="8"><span class="ex">0000000036732000</span>    132K rw---   [ anon ] <span class="co"># 匿名映射，通常用于堆或其他动态分配的内存</span></a>
<a class="sourceLine" id="cb35-9" title="9"><span class="ex">00007f4ed4e61000</span>     12K rw---   [ anon ]</a>
<a class="sourceLine" id="cb35-10" title="10"><span class="ex">00007f4ed4e64000</span>    160K r---- libc.so.6</a>
<a class="sourceLine" id="cb35-11" title="11"><span class="ex">00007f4ed4e8c000</span>   1444K r-x-- libc.so.6</a>
<a class="sourceLine" id="cb35-12" title="12"><span class="ex">00007f4ed4ff5000</span>    312K r---- libc.so.6</a>
<a class="sourceLine" id="cb35-13" title="13"><span class="ex">00007f4ed5043000</span>     16K r---- libc.so.6</a>
<a class="sourceLine" id="cb35-14" title="14"><span class="ex">00007f4ed5047000</span>      8K rw--- libc.so.6 <span class="co"># 数据段</span></a>
<a class="sourceLine" id="cb35-15" title="15"><span class="ex">00007f4ed5049000</span>     40K rw---   [ anon ]</a>
<a class="sourceLine" id="cb35-16" title="16"><span class="ex">00007f4ed505b000</span>     16K r----   [ anon ]</a>
<a class="sourceLine" id="cb35-17" title="17"><span class="ex">00007f4ed505f000</span>      8K r-x--   [ anon ]</a>
<a class="sourceLine" id="cb35-18" title="18"><span class="ex">00007f4ed5061000</span>      4K r---- ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb35-19" title="19"><span class="ex">00007f4ed5062000</span>    156K r-x-- ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb35-20" title="20"><span class="ex">00007f4ed5089000</span>     40K r---- ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb35-21" title="21"><span class="ex">00007f4ed5093000</span>      8K r---- ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb35-22" title="22"><span class="ex">00007f4ed5095000</span>      8K rw--- ld-linux-x86-64.so.2</a>
<a class="sourceLine" id="cb35-23" title="23"><span class="ex">00007ffc36b1b000</span>    132K rw---   [ stack ] <span class="co"># 栈内存区域</span></a>
<a class="sourceLine" id="cb35-24" title="24"><span class="ex">ffffffffff600000</span>      4K --x--   [ anon ]</a>
<a class="sourceLine" id="cb35-25" title="25"> <span class="ex">total</span>             2520K</a></code></pre></div>
<h2 id="内存区域操作函数"><span class="header-section-number">7.6</span> 内存区域操作函数</h2>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co"> * find_vma() - 查找给定地址的 VMA，或下一个 VMA。</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co"> * </span><span class="an">@mm:</span><span class="co"> 要检查的 mm_struct</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co"> * </span><span class="an">@addr:</span><span class="co"> 地址</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co"> *</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="co"> * 返回值: 与 addr 关联的 VMA，或下一个 VMA。</span></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="co"> * 在 addr 及其以上没有 VMA 的情况下，可能返回 %NULL。</span></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="co"> */</span></a>
<a class="sourceLine" id="cb36-9" title="9"><span class="kw">struct</span> vm_area_struct *find_vma(<span class="kw">struct</span> mm_struct *mm, <span class="dt">unsigned</span> <span class="dt">long</span> addr)</a>
<a class="sourceLine" id="cb36-10" title="10"></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="co">/**</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="co"> * find_vma_prev() - 查找给定地址的 VMA，或下一个 VMA，并将 %pprev 设置为前一个 VMA（如果有的话）。</span></a>
<a class="sourceLine" id="cb36-13" title="13"><span class="co"> * 与 find_vma() 相同，但也在 *pprev 中返回指向前一个 VMA 的指针。</span></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="co"> * </span><span class="an">@mm:</span><span class="co"> 要检查的 mm_struct</span></a>
<a class="sourceLine" id="cb36-15" title="15"><span class="co"> * </span><span class="an">@addr:</span><span class="co"> 地址</span></a>
<a class="sourceLine" id="cb36-16" title="16"><span class="co"> * </span><span class="an">@pprev:</span><span class="co"> 指向前一个 VMA 的指针</span></a>
<a class="sourceLine" id="cb36-17" title="17"><span class="co"> *</span></a>
<a class="sourceLine" id="cb36-18" title="18"><span class="co"> * 注意，这里缺少 RCU 锁，因为使用了外部的 mmap_lock()。</span></a>
<a class="sourceLine" id="cb36-19" title="19"><span class="co"> *</span></a>
<a class="sourceLine" id="cb36-20" title="20"><span class="co"> * 返回值: 与 </span><span class="an">@addr</span><span class="co"> 关联的 VMA，或下一个 VMA。</span></a>
<a class="sourceLine" id="cb36-21" title="21"><span class="co"> * 在 addr 及其以上没有 VMA 的情况下，可能返回 %NULL。</span></a>
<a class="sourceLine" id="cb36-22" title="22"><span class="co"> */</span></a>
<a class="sourceLine" id="cb36-23" title="23"><span class="kw">struct</span> vm_area_struct *</a>
<a class="sourceLine" id="cb36-24" title="24">find_vma_prev(<span class="kw">struct</span> mm_struct *mm, <span class="dt">unsigned</span> <span class="dt">long</span> addr,</a>
<a class="sourceLine" id="cb36-25" title="25">              <span class="kw">struct</span> vm_area_struct **pprev)</a>
<a class="sourceLine" id="cb36-26" title="26"></a>
<a class="sourceLine" id="cb36-27" title="27"><span class="co">/**</span></a>
<a class="sourceLine" id="cb36-28" title="28"><span class="co"> * find_vma_intersection() - 查找第一个与区间相交的 VMA</span></a>
<a class="sourceLine" id="cb36-29" title="29"><span class="co"> * </span><span class="an">@mm:</span><span class="co"> 进程地址空间</span></a>
<a class="sourceLine" id="cb36-30" title="30"><span class="co"> * </span><span class="an">@start_addr:</span><span class="co"> 包含的起始用户地址</span></a>
<a class="sourceLine" id="cb36-31" title="31"><span class="co"> * </span><span class="an">@end_addr:</span><span class="co"> 排除的结束用户地址</span></a>
<a class="sourceLine" id="cb36-32" title="32"><span class="co"> *</span></a>
<a class="sourceLine" id="cb36-33" title="33"><span class="co"> * 返回值: 区间内的第一个 VMA，否则为 %NULL。假设 start_addr &lt; end_addr。</span></a>
<a class="sourceLine" id="cb36-34" title="34"><span class="co"> */</span></a>
<a class="sourceLine" id="cb36-35" title="35"><span class="kw">struct</span> vm_area_struct *find_vma_intersection(<span class="kw">struct</span> mm_struct *mm,</a>
<a class="sourceLine" id="cb36-36" title="36">                                             <span class="dt">unsigned</span> <span class="dt">long</span> start_addr,</a>
<a class="sourceLine" id="cb36-37" title="37">                                             <span class="dt">unsigned</span> <span class="dt">long</span> end_addr)</a>
<a class="sourceLine" id="cb36-38" title="38"></a>
<a class="sourceLine" id="cb36-39" title="39"><span class="co">// 将一个地址区间加入到进程的地址空间，扩展已存在的内存区域域创建新的区域，调用者必须持有 current-&gt;mm-&gt;mmap_lock 的写锁</span></a>
<a class="sourceLine" id="cb36-40" title="40"><span class="co">// file为NULL或offset为0称为匿名映射（anonymous mapping），否则称为文件映射（file-backed mapping）</span></a>
<a class="sourceLine" id="cb36-41" title="41"><span class="co">// prot: 请查看 PROT_READ 等定义</span></a>
<a class="sourceLine" id="cb36-42" title="42"><span class="co">// flag: 请查看 MAP_SHARED 和 MAP_GROWSDOWN 等定义</span></a>
<a class="sourceLine" id="cb36-43" title="43"><span class="dt">unsigned</span> <span class="dt">long</span> do_mmap(<span class="kw">struct</span> file *file, <span class="dt">unsigned</span> <span class="dt">long</span> addr,</a>
<a class="sourceLine" id="cb36-44" title="44">                      <span class="dt">unsigned</span> <span class="dt">long</span> len, <span class="dt">unsigned</span> <span class="dt">long</span> prot,</a>
<a class="sourceLine" id="cb36-45" title="45">                      <span class="dt">unsigned</span> <span class="dt">long</span> flags, vm_flags_t vm_flags,</a>
<a class="sourceLine" id="cb36-46" title="46">                      <span class="dt">unsigned</span> <span class="dt">long</span> pgoff, <span class="dt">unsigned</span> <span class="dt">long</span> *populate,</a>
<a class="sourceLine" id="cb36-47" title="47">                      <span class="kw">struct</span> list_head *uf)</a>
<a class="sourceLine" id="cb36-48" title="48"></a>
<a class="sourceLine" id="cb36-49" title="49"><span class="co">// 最终调用到 do_mmap()</span></a>
<a class="sourceLine" id="cb36-50" title="50">SYSCALL_DEFINE6(mmap_pgoff, <span class="dt">unsigned</span> <span class="dt">long</span>, addr, <span class="dt">unsigned</span> <span class="dt">long</span>, len,</a>
<a class="sourceLine" id="cb36-51" title="51">                <span class="dt">unsigned</span> <span class="dt">long</span>, prot, <span class="dt">unsigned</span> <span class="dt">long</span>, flags,          </a>
<a class="sourceLine" id="cb36-52" title="52">                <span class="dt">unsigned</span> <span class="dt">long</span>, fd, <span class="dt">unsigned</span> <span class="dt">long</span>, pgoff)            </a>
<a class="sourceLine" id="cb36-53" title="53"></a>
<a class="sourceLine" id="cb36-54" title="54"><span class="co">/* do_munmap() - 取消映射给定地址范围，非maple tree感知的do_munmap()调用的包装函数</span></a>
<a class="sourceLine" id="cb36-55" title="55"><span class="co"> * @mm: mm_struct结构体                                                         </span></a>
<a class="sourceLine" id="cb36-56" title="56"><span class="co"> * @start: 要munmap的起始地址                                        </span></a>
<a class="sourceLine" id="cb36-57" title="57"><span class="co"> * @len: 要munmap的长度                                          </span></a>
<a class="sourceLine" id="cb36-58" title="58"><span class="co"> * @uf: userfaultfd的list_head                                             </span></a>
<a class="sourceLine" id="cb36-59" title="59"><span class="co"> *                                                                            </span></a>
<a class="sourceLine" id="cb36-60" title="60"><span class="co"> * 返回: 成功返回0，否则返回错误                                     </span></a>
<a class="sourceLine" id="cb36-61" title="61"><span class="co"> */</span></a>
<a class="sourceLine" id="cb36-62" title="62"><span class="dt">int</span> do_munmap(<span class="kw">struct</span> mm_struct *mm, <span class="dt">unsigned</span> <span class="dt">long</span> start, <span class="dt">size_t</span> len,</a>
<a class="sourceLine" id="cb36-63" title="63">              <span class="kw">struct</span> list_head *uf)</a>
<a class="sourceLine" id="cb36-64" title="64"></a>
<a class="sourceLine" id="cb36-65" title="65"><span class="co">// 最终调用到 do_munmap()</span></a>
<a class="sourceLine" id="cb36-66" title="66">SYSCALL_DEFINE2(munmap, <span class="dt">unsigned</span> <span class="dt">long</span>, addr, <span class="dt">size_t</span>, len)</a></code></pre></div>
<h2 id="页表"><span class="header-section-number">7.7</span> 页表</h2>
<p>应用程序操作的是虚拟内存，但处理器操作的是物理内存。举个例子，32位x86 PAE模式下（Physical Address Extension，物理地址扩展，32位线性地址可以访问64G物理内存，处理器管脚36个），Linux内核使用三级页表完成地址转换:</p>
<ul>
<li>顶级页表 - 页全局目录: PGD，Page Global Directory，<code>pgd_t</code>类型的数组。</li>
<li>二级页表 - 页中间目录: PMD，Page Middle Directory，<code>pmd_t</code>类型的数组。</li>
<li>三级页表 - 页表项: PTE，Page Table Entry，包含<code>pte_t</code>类型的页表项，指向物理页面。</li>
</ul>
<p>其他体系结构下的使用的页表级数不一样，如<code>arm64</code>采用四级页表。<code>struct mm_struct</code>中的<code>pgd</code>成员指向进程的页全局目录，由<code>page_table_lock</code>保护。内核正确的设置了页表后，搜索页表的工作由硬件完成。</p>
<p>为了加快搜索物理地址的速度，多数体系结构实现了 Translation Lookaside Buffer，翻译为: 转译后备缓冲器（又叫页表缓存、转址旁路缓存）。90%命中TLB，10%需要访问页表。</p>
<h1 id="伙伴算法"><span class="header-section-number">8</span> 伙伴算法</h1>
<p><code>struct zone</code>中有一个<code>free_area[MAX_ORDER + 1]</code>的数组:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">struct</span> free_area {                                       </a>
<a class="sourceLine" id="cb37-2" title="2">        <span class="kw">struct</span> list_head        free_list[MIGRATE_TYPES];</a>
<a class="sourceLine" id="cb37-3" title="3">        <span class="dt">unsigned</span> <span class="dt">long</span>           nr_free;                 </a>
<a class="sourceLine" id="cb37-4" title="4">};                                                       </a></code></pre></div>
<p>其中<code>free_area[0]</code>中的链表中的内存块单位是<code>2^0=1</code>个page，<code>free_area[1]</code>的单位是<code>2^1</code>个page，以此类推。这种内存块称为“页块”或简称“块”，大小相同且物理地址连续的两个页块称为“伙伴”（Buddy）。</p>
<p>伙伴算法的工作原理: 先在大小满足要求的块链表中查找是否有空闲块，如果有就直接分配内存，否则在更大的块链表中查找，逆过程就是块的释放，把满足伙伴关系的块合并。</p>
<p>要分配<code>2^3=8</code>个page，<code>free_area[3]</code>（8个page的页块大小）、<code>free_area[4]</code>（16个page的页块大小）中的链表都找不到空闲块，只有<code>free_area[5]</code>（32个page的页块大小）中有空闲块，先把32 page的页块分成2个16 page的页块，其中一个16 page的页块插入<code>free_area[4]</code>的链表中，另一个16 page的页块再分成2个8 page的页块，一个8 page的页块插入<code>free_area[3]</code>的链表中，另一个8 page的页块用于最终分配。具体请查看<code>__rmqueue_smallest()</code>和<code>expand()</code>函数。访问虚拟内存时，如果物理内存还没分配，会发生缺页异常，内核将从磁盘或交换文件（SWAP）中将要访问的页装入物理内存，最终调用<code>alloc_pages()</code>为进程分配page，并将虚拟内存和物理内存的映射关系写入页表。内核总是<strong>尽量延后</strong>分配用户空间的内存。</p>
</body>
</html>
