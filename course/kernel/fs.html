<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>文件系统</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://chenxiaosong.com/stylesheet.css" />
</head>
<body>
<header id="title-block-header">
<!-- sign begin -->
<ul>
<li>作者: 陈孝松</li>
<li><a href="https://chenxiaosong.com/">中文主页: chenxiaosong.com</a></li>
<li><a href="https://chenxiaosong.com/en">英文主页: chenxiaosong.com/en</a></li>
<li><a href="https://chenxiaosong.com/video.html">哔哩哔哩教学视频: 陈孝松</a></li>
<li><a href="https://chenxiaosong.com/course.html">课程: chenxiaosong.com/course</a></li>
<li><a href="https://chenxiaosong.com/blog.html">博客: chenxiaosong.com/blog</a></li>
<li><a href="https://chenxiaosong.com/contribution.html">贡献: chenxiaosong.com/contribution</a></li>
<li>邮箱: <a href="mailto:chenxiaosong@chenxiaosong.com" class="email">chenxiaosong@chenxiaosong.com</a></li>
<li><a href="https://chenxiaosong.com/q.html">QQ交流群: 544216206, 点击查看群介绍</a></li>
</ul>
<!-- sign end -->
<h1 class="title">文件系统</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#什么是文件系统"><span class="toc-section-number">1</span> 什么是文件系统</a></li>
<li><a href="#虚拟文件系统"><span class="toc-section-number">2</span> 虚拟文件系统</a><ul>
<li><a href="#超级块对象"><span class="toc-section-number">2.1</span> 超级块对象</a></li>
<li><a href="#超级块操作"><span class="toc-section-number">2.2</span> 超级块操作</a></li>
<li><a href="#索引节点对象"><span class="toc-section-number">2.3</span> 索引节点对象</a></li>
<li><a href="#索引节点操作"><span class="toc-section-number">2.4</span> 索引节点操作</a></li>
<li><a href="#目录项对象"><span class="toc-section-number">2.5</span> 目录项对象</a></li>
<li><a href="#目录项操作"><span class="toc-section-number">2.6</span> 目录项操作</a></li>
<li><a href="#文件对象"><span class="toc-section-number">2.7</span> 文件对象</a></li>
<li><a href="#文件操作"><span class="toc-section-number">2.8</span> 文件操作</a></li>
<li><a href="#地址空间"><span class="toc-section-number">2.9</span> 地址空间</a></li>
<li><a href="#其他数据结构"><span class="toc-section-number">2.10</span> 其他数据结构</a></li>
<li><a href="#举几个例子"><span class="toc-section-number">2.11</span> 举几个例子</a><ul>
<li><a href="#inode的i_nlink"><span class="toc-section-number">2.11.1</span> <code>inode</code>的<code>i_nlink</code></a></li>
<li><a href="#super_block的s_mounts"><span class="toc-section-number">2.11.2</span> <code>super_block</code>的<code>s_mounts</code></a></li>
<li><a href="#通过inode得到完整路径"><span class="toc-section-number">2.11.3</span> 通过<code>inode</code>得到完整路径</a></li>
</ul></li>
</ul></li>
<li><a href="#ext2文件系统"><span class="toc-section-number">3</span> ext2文件系统</a><ul>
<li><a href="#磁盘数据结构"><span class="toc-section-number">3.1</span> 磁盘数据结构</a><ul>
<li><a href="#块组"><span class="toc-section-number">3.1.1</span> 块组</a></li>
<li><a href="#超级块"><span class="toc-section-number">3.1.2</span> 超级块</a></li>
<li><a href="#组描述符"><span class="toc-section-number">3.1.3</span> 组描述符</a></li>
<li><a href="#inode表"><span class="toc-section-number">3.1.4</span> inode表</a></li>
<li><a href="#各种文件类型的存储"><span class="toc-section-number">3.1.5</span> 各种文件类型的存储</a></li>
</ul></li>
<li><a href="#内存数据结构"><span class="toc-section-number">3.2</span> 内存数据结构</a><ul>
<li><a href="#超级块-1"><span class="toc-section-number">3.2.1</span> 超级块</a></li>
<li><a href="#索引节点"><span class="toc-section-number">3.2.2</span> 索引节点</a></li>
</ul></li>
<li><a href="#管理磁盘空间"><span class="toc-section-number">3.3</span> 管理磁盘空间</a></li>
<li><a href="#调试ext2磁盘布局"><span class="toc-section-number">3.4</span> 调试ext2磁盘布局</a></li>
<li><a href="#工具软件"><span class="toc-section-number">3.5</span> 工具软件</a></li>
<li><a href="#开发一个新文件系统的步骤"><span class="toc-section-number">3.6</span> 开发一个新文件系统的步骤</a></li>
</ul></li>
<li><a href="#minix文件系统"><span class="toc-section-number">4</span> minix文件系统</a><ul>
<li><a href="#使用"><span class="toc-section-number">4.1</span> 使用</a></li>
<li><a href="#独立模块编译"><span class="toc-section-number">4.2</span> 独立模块编译</a></li>
<li><a href="#util-linux"><span class="toc-section-number">4.3</span> <code>util-linux</code></a></li>
<li><a href="#数据结构"><span class="toc-section-number">4.4</span> 数据结构</a></li>
<li><a href="#函数流程"><span class="toc-section-number">4.5</span> 函数流程</a></li>
<li><a href="#支持长文件名"><span class="toc-section-number">4.6</span> 支持长文件名</a></li>
</ul></li>
<li><a href="#lazy-umount"><span class="toc-section-number">5</span> 文件系统延迟卸载</a><ul>
<li><a href="#描述"><span class="toc-section-number">5.1</span> 描述</a></li>
<li><a href="#调试"><span class="toc-section-number">5.2</span> 调试</a><ul>
<li><a href="#未执行umount---lazy"><span class="toc-section-number">5.2.1</span> 未执行<code>umount --lazy</code></a></li>
<li><a href="#执行umount---lazy后"><span class="toc-section-number">5.2.2</span> 执行<code>umount --lazy</code>后</a></li>
</ul></li>
<li><a href="#代码分析"><span class="toc-section-number">5.3</span> 代码分析</a></li>
<li><a href="#openeuler-overlayfs"><span class="toc-section-number">5.4</span> openeuler overlayfs</a><ul>
<li><a href="#使用-1"><span class="toc-section-number">5.4.1</span> 使用</a></li>
<li><a href="#代码分析-1"><span class="toc-section-number">5.4.2</span> 代码分析</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<p><a href="https://chenxiaosong.com/course/kernel/kernel.html">点击跳转到内核课程所有目录</a>。</p>
<p><a href="https://chenxiaosong.com/course/kernel/video.html">点击这里查看配套的教学视频</a>。</p>
<p>一般的Linux书籍都是先讲解进程和内存相关的知识，但我想先讲解文件系统。 第一，因为我就是做文件系统的，更擅长这一块，其他模块的内容我还要再去好好看看书，毕竟不能误人子弟嘛；第二，是 因为文件系统模块更接近于用户态，是相对比较好理解的内容（当然想深入还是要下大功夫的），由文件系统入手比较适合初学者。</p>
<h1 id="什么是文件系统"><span class="header-section-number">1</span> 什么是文件系统</h1>
<p>我们先来看一下什么是文件系统？我们买电脑时，肯定会配一块硬盘（现在一般是固态硬盘），硬盘是用来存储数据资料的。比如要存储一句话:“我爱操作系统”，一个汉字占用2个字节，存储这一句话要占用12个字节（不包括结束符），我们可以用2种方法来存储。第一种方法是从硬盘第一个字节开始存储，前两个字节存储“我”，第三四个字节存储“爱”，以此类推。第二种方法是先创建一个文件，在这个文件里存储这句话，我们打开硬盘时，只需要找到这个文件的位置，就能找到这句话。第一种方法数据管理起来很不方便，所以一般都用第二种方法，第二种方法管理数据的规则就称为文件系统。</p>
<p>文件系统可以分为3类:</p>
<ul>
<li>磁盘文件系统，如ext2、ext4、xfs、ntfs等。</li>
<li>网络文件系统，如nfs、cifs等。</li>
<li>特殊文件系统，如procfs、sysfs等。</li>
</ul>
<p>我们来实际操作一下，虚拟机中的<code>${HOME}/qemu-kernel/start.sh</code>文件中增加以下内容（如果已有就不用增加）:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="ex">-drive</span> file=1,if=none,format=raw,cache=writeback,file.locking=off,id=dd_1 \</a>
<a class="sourceLine" id="cb1-2" title="2">-device scsi-hd,drive=dd_1,id=disk_1,logical_block_size=512,physical_block_size=512 \</a></code></pre></div>
<p>然后在<code>${HOME}/qemu-kernel/</code>目录下创建一个文件:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">fallocate</span> -l 1G 1</a></code></pre></div>
<p>进入虚拟机后，可以使用上面提到的第一种方法，直接从磁盘的第一个字节开始存:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="bu">echo</span> <span class="st">&quot;我爱操作系统&quot;</span> <span class="op">&gt;</span> /dev/sda</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="fu">cat</span> /dev/sda <span class="co"># 从磁盘的第一个字节开始输出</span></a></code></pre></div>
<p>也可以用上面提到的第二种方法，也就是我们要学的文件系统:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">mkfs.ext4</span> -F /dev/sda <span class="co"># 格式化文件系统</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="fu">mount</span> -t ext4 /dev/sda /mnt <span class="co"># 把磁盘挂载到某个目录</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="fu">df</span> /dev/sda <span class="co"># 查看是否已经挂载上</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="bu">echo</span> <span class="st">&quot;我爱操作系统&quot;</span> <span class="op">&gt;</span> /mnt/file <span class="co"># 存到挂载点下的某个文件中</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="fu">cat</span> /mnt/file <span class="co"># 输出文件内容</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="ex">debugfs</span> /dev/sda</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co"># debugfs:  stats # Block size: 1024</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co"># debugfs:  stat file # BLOCKS: (0):7169</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="fu">dd</span> if=/dev/sda of=./data bs=1 skip=7341056 count=20</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="fu">cat</span> data</a>
<a class="sourceLine" id="cb4-11" title="11"><span class="fu">umount</span> /mnt <span class="co"># 卸载文件系统</span></a></code></pre></div>
<h1 id="虚拟文件系统"><span class="header-section-number">2</span> 虚拟文件系统</h1>
<p>虚拟文件系统英文全称Virtual file system，缩写为VFS，又称为虚拟文件切换系统（virtual filesystem switch）。所有的文件系统都要先经过虚拟文件系统层，虚拟文件系统相当于制定了一套规则，如果你想写一个新的文件系统，只需要遵守这套规则就可以了。</p>
<p>VFS虽然是用C语言写的，但使用了面向对象的设计思路。</p>
<h2 id="超级块对象"><span class="header-section-number">2.1</span> 超级块对象</h2>
<p>超级块英文全称是super block，存储特定文件系统的信息。如果是基于磁盘的文件系统，通常对应磁盘上特定扇区中的数据。如果不是基于磁盘的文件系统（如procfs或sysfs），会在使用时创建超级块，只保留在内存中。</p>
<p>超级块对象结构体定义在文件<code>include/linux/fs.h</code>中，比较长，不用背，用到时查一下就好，我会在这里加一些中文注释。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">struct</span> super_block {</a>
<a class="sourceLine" id="cb5-2" title="2">        <span class="kw">struct</span> list_head        s_list;         <span class="co">/* 放在最开头，指向 super_blocks，使用list_add_tail加到super_blocks链表中 */</span></a>
<a class="sourceLine" id="cb5-3" title="3">        dev_t                   s_dev;          <span class="co">/* 设备标识符 */</span></a>
<a class="sourceLine" id="cb5-4" title="4">        <span class="dt">unsigned</span> <span class="dt">char</span>           s_blocksize_bits; <span class="co">// 块大小，单位: bit</span></a>
<a class="sourceLine" id="cb5-5" title="5">        <span class="dt">unsigned</span> <span class="dt">long</span>           s_blocksize; <span class="co">// 块大小，单位: 字节</span></a>
<a class="sourceLine" id="cb5-6" title="6">        loff_t                  s_maxbytes;     <span class="co">/* 文件大小上限 */</span></a>
<a class="sourceLine" id="cb5-7" title="7">        <span class="kw">struct</span> file_system_type *s_type; <span class="co">// 文件系统类型</span></a>
<a class="sourceLine" id="cb5-8" title="8">        <span class="dt">const</span> <span class="kw">struct</span> super_operations   *s_op; <span class="co">// 超级块方法</span></a>
<a class="sourceLine" id="cb5-9" title="9">        <span class="dt">const</span> <span class="kw">struct</span> dquot_operations   *dq_op; <span class="co">// 磁盘限额方法</span></a>
<a class="sourceLine" id="cb5-10" title="10">        <span class="dt">const</span> <span class="kw">struct</span> quotactl_ops       *s_qcop; <span class="co">// 限额控制方法</span></a>
<a class="sourceLine" id="cb5-11" title="11">        <span class="dt">const</span> <span class="kw">struct</span> export_operations *s_export_op; <span class="co">// 导出方法</span></a>
<a class="sourceLine" id="cb5-12" title="12">        <span class="dt">unsigned</span> <span class="dt">long</span>           s_flags; <span class="co">// 挂载标志</span></a>
<a class="sourceLine" id="cb5-13" title="13">        <span class="dt">unsigned</span> <span class="dt">long</span>           s_iflags;       <span class="co">/* 内部 SB_I_* 标志 */</span></a>
<a class="sourceLine" id="cb5-14" title="14">        <span class="dt">unsigned</span> <span class="dt">long</span>           s_magic; <span class="co">// 文件系统幻数</span></a>
<a class="sourceLine" id="cb5-15" title="15">        <span class="kw">struct</span> dentry           *s_root; <span class="co">// 目录挂载点</span></a>
<a class="sourceLine" id="cb5-16" title="16">        <span class="kw">struct</span> rw_semaphore     s_umount; <span class="co">// 卸载信号量</span></a>
<a class="sourceLine" id="cb5-17" title="17">        <span class="dt">int</span>                     s_count; <span class="co">// 超级块引用计数</span></a>
<a class="sourceLine" id="cb5-18" title="18">        atomic_t                s_active; <span class="co">// 活动引用计数</span></a>
<a class="sourceLine" id="cb5-19" title="19"><span class="pp">#ifdef CONFIG_SECURITY</span></a>
<a class="sourceLine" id="cb5-20" title="20">        <span class="dt">void</span>                    *s_security; <span class="co">// 安全模块</span></a>
<a class="sourceLine" id="cb5-21" title="21"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb5-22" title="22">        <span class="dt">const</span> <span class="kw">struct</span> xattr_handler **s_xattr; <span class="co">// 扩展的属性操作</span></a>
<a class="sourceLine" id="cb5-23" title="23"><span class="pp">#ifdef CONFIG_FS_ENCRYPTION</span></a>
<a class="sourceLine" id="cb5-24" title="24">        <span class="dt">const</span> <span class="kw">struct</span> fscrypt_operations *s_cop;</a>
<a class="sourceLine" id="cb5-25" title="25">        <span class="kw">struct</span> fscrypt_keyring  *s_master_keys; <span class="co">/* 主加密密钥正在使用 */</span></a>
<a class="sourceLine" id="cb5-26" title="26"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb5-27" title="27"><span class="pp">#ifdef CONFIG_FS_VERITY</span></a>
<a class="sourceLine" id="cb5-28" title="28">        <span class="dt">const</span> <span class="kw">struct</span> fsverity_operations *s_vop;</a>
<a class="sourceLine" id="cb5-29" title="29"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb5-30" title="30"><span class="pp">#if IS_ENABLED(CONFIG_UNICODE)</span></a>
<a class="sourceLine" id="cb5-31" title="31">        <span class="kw">struct</span> unicode_map *s_encoding;</a>
<a class="sourceLine" id="cb5-32" title="32">        __u16 s_encoding_flags;</a>
<a class="sourceLine" id="cb5-33" title="33"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb5-34" title="34">        <span class="kw">struct</span> hlist_bl_head    s_roots;        <span class="co">/* NFS 的备用根目录项 */</span></a>
<a class="sourceLine" id="cb5-35" title="35">        <span class="kw">struct</span> list_head        s_mounts;       <span class="co">/* 挂载点列表；_不_用于文件系统，struct mount的mnt_instance加到这个链表中 */</span></a>
<a class="sourceLine" id="cb5-36" title="36">        <span class="kw">struct</span> block_device     *s_bdev; <span class="co">// 相关的块设备</span></a>
<a class="sourceLine" id="cb5-37" title="37">        <span class="kw">struct</span> backing_dev_info *s_bdi;</a>
<a class="sourceLine" id="cb5-38" title="38">        <span class="kw">struct</span> mtd_info         *s_mtd; <span class="co">// 存储磁盘信息</span></a>
<a class="sourceLine" id="cb5-39" title="39">        <span class="kw">struct</span> hlist_node       s_instances; <span class="co">// 这种类型的所有文件系统</span></a>
<a class="sourceLine" id="cb5-40" title="40">        <span class="dt">unsigned</span> <span class="dt">int</span>            s_quota_types;  <span class="co">/* 支持的配额类型的位掩码 */</span></a>
<a class="sourceLine" id="cb5-41" title="41">        <span class="kw">struct</span> quota_info       s_dquot;        <span class="co">/* 限额相关选项 */</span></a>
<a class="sourceLine" id="cb5-42" title="42"></a>
<a class="sourceLine" id="cb5-43" title="43">        <span class="kw">struct</span> sb_writers       s_writers;</a>
<a class="sourceLine" id="cb5-44" title="44"></a>
<a class="sourceLine" id="cb5-45" title="45">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb5-46" title="46"><span class="co">         * 将 s_fs_info, s_time_gran, s_fsnotify_mask 和</span></a>
<a class="sourceLine" id="cb5-47" title="47"><span class="co">         * s_fsnotify_marks 放在一起以提高缓存效率。</span></a>
<a class="sourceLine" id="cb5-48" title="48"><span class="co">         * 它们经常被访问但很少被修改。</span></a>
<a class="sourceLine" id="cb5-49" title="49"><span class="co">         */</span></a>
<a class="sourceLine" id="cb5-50" title="50">        <span class="dt">void</span>                    *s_fs_info;     <span class="co">/* 文件系统私有信息 */</span></a>
<a class="sourceLine" id="cb5-51" title="51"></a>
<a class="sourceLine" id="cb5-52" title="52">        <span class="co">/* c/m/atime 的精度（以纳秒为单位，不能超过一秒） */</span></a>
<a class="sourceLine" id="cb5-53" title="53">        u32                     s_time_gran; <span class="co">// 时间戳粒度</span></a>
<a class="sourceLine" id="cb5-54" title="54">        <span class="co">/* c/m/atime 的时间限制（以秒为单位） */</span></a>
<a class="sourceLine" id="cb5-55" title="55">        time64_t                   s_time_min;</a>
<a class="sourceLine" id="cb5-56" title="56">        time64_t                   s_time_max;</a>
<a class="sourceLine" id="cb5-57" title="57"><span class="pp">#ifdef CONFIG_FSNOTIFY</span></a>
<a class="sourceLine" id="cb5-58" title="58">        __u32                   s_fsnotify_mask;</a>
<a class="sourceLine" id="cb5-59" title="59">        <span class="kw">struct</span> fsnotify_mark_connector __rcu    *s_fsnotify_marks;</a>
<a class="sourceLine" id="cb5-60" title="60"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb5-61" title="61"></a>
<a class="sourceLine" id="cb5-62" title="62">        <span class="dt">char</span>                    s_id[<span class="dv">32</span>];       <span class="co">/* 信息性名称，文本名字 */</span></a>
<a class="sourceLine" id="cb5-63" title="63">        uuid_t                  s_uuid;         <span class="co">/* Universally Unique Identifier&quot;（全局唯一标识符） */</span></a>
<a class="sourceLine" id="cb5-64" title="64"></a>
<a class="sourceLine" id="cb5-65" title="65">        <span class="dt">unsigned</span> <span class="dt">int</span>            s_max_links;</a>
<a class="sourceLine" id="cb5-66" title="66"></a>
<a class="sourceLine" id="cb5-67" title="67">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb5-68" title="68"><span class="co">         * 下一个字段仅供 VFS 使用。任何文件系统都没有权利查看它。</span></a>
<a class="sourceLine" id="cb5-69" title="69"><span class="co">         * 你已经被警告过了。</span></a>
<a class="sourceLine" id="cb5-70" title="70"><span class="co">         */</span></a>
<a class="sourceLine" id="cb5-71" title="71">        <span class="kw">struct</span> mutex s_vfs_rename_mutex;        <span class="co">/* Kludge，重命名锁 */</span></a>
<a class="sourceLine" id="cb5-72" title="72"></a>
<a class="sourceLine" id="cb5-73" title="73">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb5-74" title="74"><span class="co">         * 文件系统子类型。如果非空，/proc/mounts 中的文件系统类型字段</span></a>
<a class="sourceLine" id="cb5-75" title="75"><span class="co">         * 将是 &quot;type.subtype&quot;</span></a>
<a class="sourceLine" id="cb5-76" title="76"><span class="co">         */</span></a>
<a class="sourceLine" id="cb5-77" title="77">        <span class="dt">const</span> <span class="dt">char</span> *s_subtype; <span class="co">// 子类型名称</span></a>
<a class="sourceLine" id="cb5-78" title="78"></a>
<a class="sourceLine" id="cb5-79" title="79">        <span class="dt">const</span> <span class="kw">struct</span> dentry_operations *s_d_op; <span class="co">/* 目录项的默认 d_op */</span></a>
<a class="sourceLine" id="cb5-80" title="80"></a>
<a class="sourceLine" id="cb5-81" title="81">        <span class="kw">struct</span> shrinker s_shrink;       <span class="co">/* 每个超级块的收缩器句柄 */</span></a>
<a class="sourceLine" id="cb5-82" title="82"></a>
<a class="sourceLine" id="cb5-83" title="83">        <span class="co">/* nlink == 0 但仍被引用的 inode 数量 */</span></a>
<a class="sourceLine" id="cb5-84" title="84">        atomic_long_t s_remove_count;</a>
<a class="sourceLine" id="cb5-85" title="85"></a>
<a class="sourceLine" id="cb5-86" title="86">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb5-87" title="87"><span class="co">         * 被监视的 inode/mount/sb 对象的数量，注意 inode 对象目前被双重计算。</span></a>
<a class="sourceLine" id="cb5-88" title="88"><span class="co">         */</span></a>
<a class="sourceLine" id="cb5-89" title="89">        atomic_long_t s_fsnotify_connectors;</a>
<a class="sourceLine" id="cb5-90" title="90"></a>
<a class="sourceLine" id="cb5-91" title="91">        <span class="co">/* 超级块的只读状态正在被更改 */</span></a>
<a class="sourceLine" id="cb5-92" title="92">        <span class="dt">int</span> s_readonly_remount;</a>
<a class="sourceLine" id="cb5-93" title="93"></a>
<a class="sourceLine" id="cb5-94" title="94">        <span class="co">/* 每个超级块的 errseq_t 用于通过 syncfs 报告回写错误 */</span></a>
<a class="sourceLine" id="cb5-95" title="95">        errseq_t s_wb_err;</a>
<a class="sourceLine" id="cb5-96" title="96"></a>
<a class="sourceLine" id="cb5-97" title="97">        <span class="co">/* 从中断上下文推迟的 AIO 完成 */</span></a>
<a class="sourceLine" id="cb5-98" title="98">        <span class="kw">struct</span> workqueue_struct *s_dio_done_wq;</a>
<a class="sourceLine" id="cb5-99" title="99">        <span class="kw">struct</span> hlist_head s_pins;</a>
<a class="sourceLine" id="cb5-100" title="100"></a>
<a class="sourceLine" id="cb5-101" title="101">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb5-102" title="102"><span class="co">         * 拥有的用户命名空间和默认上下文，用于解释文件系统的 uid、gid、配额、</span></a>
<a class="sourceLine" id="cb5-103" title="103"><span class="co">         * 设备节点、xattrs 和安全标签。</span></a>
<a class="sourceLine" id="cb5-104" title="104"><span class="co">         */</span></a>
<a class="sourceLine" id="cb5-105" title="105">        <span class="kw">struct</span> user_namespace *s_user_ns;</a>
<a class="sourceLine" id="cb5-106" title="106"></a>
<a class="sourceLine" id="cb5-107" title="107">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb5-108" title="108"><span class="co">         * list_lru 结构本质上只是指向每个节点 lru 列表表格的指针，</span></a>
<a class="sourceLine" id="cb5-109" title="109"><span class="co">         * 每个节点都有自己的自旋锁。没有必要将它们放入不同的缓存行。</span></a>
<a class="sourceLine" id="cb5-110" title="110"><span class="co">         */</span></a>
<a class="sourceLine" id="cb5-111" title="111">        <span class="kw">struct</span> list_lru         s_dentry_lru; <span class="co">// 未被使用目录项链表</span></a>
<a class="sourceLine" id="cb5-112" title="112">        <span class="kw">struct</span> list_lru         s_inode_lru;</a>
<a class="sourceLine" id="cb5-113" title="113">        <span class="kw">struct</span> rcu_head         rcu;</a>
<a class="sourceLine" id="cb5-114" title="114">        <span class="kw">struct</span> work_struct      destroy_work;</a>
<a class="sourceLine" id="cb5-115" title="115"></a>
<a class="sourceLine" id="cb5-116" title="116">        <span class="kw">struct</span> mutex            s_sync_lock;    <span class="co">/* 同步序列化锁 */</span></a>
<a class="sourceLine" id="cb5-117" title="117"></a>
<a class="sourceLine" id="cb5-118" title="118">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb5-119" title="119"><span class="co">         * 指示该超级块在文件系统栈中的深度</span></a>
<a class="sourceLine" id="cb5-120" title="120"><span class="co">         */</span></a>
<a class="sourceLine" id="cb5-121" title="121">        <span class="dt">int</span> s_stack_depth;</a>
<a class="sourceLine" id="cb5-122" title="122"></a>
<a class="sourceLine" id="cb5-123" title="123">        <span class="co">/* s_inode_list_lock 保护 s_inodes */</span></a>
<a class="sourceLine" id="cb5-124" title="124">        spinlock_t              s_inode_list_lock ____cacheline_aligned_in_smp;</a>
<a class="sourceLine" id="cb5-125" title="125">        <span class="kw">struct</span> list_head        s_inodes;       <span class="co">/* 索引节点链表 */</span></a>
<a class="sourceLine" id="cb5-126" title="126"></a>
<a class="sourceLine" id="cb5-127" title="127">        spinlock_t              s_inode_wblist_lock;</a>
<a class="sourceLine" id="cb5-128" title="128">        <span class="kw">struct</span> list_head        s_inodes_wb;    <span class="co">/* 回写的 inode */</span></a>
<a class="sourceLine" id="cb5-129" title="129">} __randomize_layout;</a></code></pre></div>
<p>超级块对象通过<code>alloc_super()</code>函数创建和初始化，具体的文件系统如ext2文件系统的流程如下:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1">mount <span class="co">// 系统调用</span></a>
<a class="sourceLine" id="cb6-2" title="2">  do_mount</a>
<a class="sourceLine" id="cb6-3" title="3">    path_mount</a>
<a class="sourceLine" id="cb6-4" title="4">      do_new_mount</a>
<a class="sourceLine" id="cb6-5" title="5">        vfs_get_tree</a>
<a class="sourceLine" id="cb6-6" title="6">          legacy_get_tree</a>
<a class="sourceLine" id="cb6-7" title="7">            ext2_mount <span class="co">// ext2_fs_type的.mount方法</span></a>
<a class="sourceLine" id="cb6-8" title="8">              mount_bdev</a>
<a class="sourceLine" id="cb6-9" title="9">                sget</a>
<a class="sourceLine" id="cb6-10" title="10">                  alloc_super</a></code></pre></div>
<h2 id="超级块操作"><span class="header-section-number">2.2</span> 超级块操作</h2>
<p>超级块对象中最重要的一个成员是<code>s_op</code>，也是面向对象思想的一个体现，超级块操作函数表结构体也是定义在文件<code>include/linux/fs.h</code>中。也不需要背，用到时查一下就可以。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">struct</span> super_operations {</a>
<a class="sourceLine" id="cb7-2" title="2">        <span class="kw">struct</span> inode *(*alloc_inode)(<span class="kw">struct</span> super_block *sb); <span class="co">// 创建和初始化一个新的索引节点对象</span></a>
<a class="sourceLine" id="cb7-3" title="3">        <span class="dt">void</span> (*destroy_inode)(<span class="kw">struct</span> inode *); <span class="co">// 销毁索引节点</span></a>
<a class="sourceLine" id="cb7-4" title="4">        <span class="dt">void</span> (*free_inode)(<span class="kw">struct</span> inode *); <span class="co">// 释放索引节点</span></a>
<a class="sourceLine" id="cb7-5" title="5"></a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="dt">void</span> (*dirty_inode) (<span class="kw">struct</span> inode *, <span class="dt">int</span> flags); <span class="co">// 索引节点脏（也就是数据被修改了）时调用，日志更新（如ext4的jbd2）</span></a>
<a class="sourceLine" id="cb7-7" title="7">        <span class="dt">int</span> (*write_inode) (<span class="kw">struct</span> inode *, <span class="kw">struct</span> writeback_control *wbc); <span class="co">// 将索引节点写入磁盘</span></a>
<a class="sourceLine" id="cb7-8" title="8">        <span class="dt">int</span> (*drop_inode) (<span class="kw">struct</span> inode *); <span class="co">// 最后一个索引节点的引用释放后调用，普通unix文件系统不会定义这个函数</span></a>
<a class="sourceLine" id="cb7-9" title="9">        <span class="dt">void</span> (*evict_inode) (<span class="kw">struct</span> inode *); <span class="co">// 从磁盘删除索引节点</span></a>
<a class="sourceLine" id="cb7-10" title="10">        <span class="dt">void</span> (*put_super) (<span class="kw">struct</span> super_block *); <span class="co">// 释放超级块，要持有超级块锁</span></a>
<a class="sourceLine" id="cb7-11" title="11">        <span class="dt">int</span> (*sync_fs)(<span class="kw">struct</span> super_block *sb, <span class="dt">int</span> wait); <span class="co">// 文件系统的元数据与磁盘同步</span></a>
<a class="sourceLine" id="cb7-12" title="12">        <span class="dt">int</span> (*freeze_super) (<span class="kw">struct</span> super_block *, <span class="kw">enum</span> freeze_holder who);</a>
<a class="sourceLine" id="cb7-13" title="13">        <span class="dt">int</span> (*freeze_fs) (<span class="kw">struct</span> super_block *);</a>
<a class="sourceLine" id="cb7-14" title="14">        <span class="dt">int</span> (*thaw_super) (<span class="kw">struct</span> super_block *, <span class="kw">enum</span> freeze_holder who);</a>
<a class="sourceLine" id="cb7-15" title="15">        <span class="dt">int</span> (*unfreeze_fs) (<span class="kw">struct</span> super_block *);</a>
<a class="sourceLine" id="cb7-16" title="16">        <span class="dt">int</span> (*statfs) (<span class="kw">struct</span> dentry *, <span class="kw">struct</span> kstatfs *); <span class="co">// 获取文件系统状态</span></a>
<a class="sourceLine" id="cb7-17" title="17">        <span class="dt">int</span> (*remount_fs) (<span class="kw">struct</span> super_block *, <span class="dt">int</span> *, <span class="dt">char</span> *); <span class="co">// 指定新的选项重新安装文件系统</span></a>
<a class="sourceLine" id="cb7-18" title="18">        <span class="dt">void</span> (*umount_begin) (<span class="kw">struct</span> super_block *); <span class="co">// 中断安装操作，目前只有网络相关的文件系统以及fuse实现了</span></a>
<a class="sourceLine" id="cb7-19" title="19"></a>
<a class="sourceLine" id="cb7-20" title="20">        <span class="dt">int</span> (*show_options)(<span class="kw">struct</span> seq_file *, <span class="kw">struct</span> dentry *);</a>
<a class="sourceLine" id="cb7-21" title="21">        <span class="dt">int</span> (*show_devname)(<span class="kw">struct</span> seq_file *, <span class="kw">struct</span> dentry *);</a>
<a class="sourceLine" id="cb7-22" title="22">        <span class="dt">int</span> (*show_path)(<span class="kw">struct</span> seq_file *, <span class="kw">struct</span> dentry *);</a>
<a class="sourceLine" id="cb7-23" title="23">        <span class="dt">int</span> (*show_stats)(<span class="kw">struct</span> seq_file *, <span class="kw">struct</span> dentry *);</a>
<a class="sourceLine" id="cb7-24" title="24"><span class="pp">#ifdef CONFIG_QUOTA</span></a>
<a class="sourceLine" id="cb7-25" title="25">        <span class="dt">ssize_t</span> (*quota_read)(<span class="kw">struct</span> super_block *, <span class="dt">int</span>, <span class="dt">char</span> *, <span class="dt">size_t</span>, loff_t);</a>
<a class="sourceLine" id="cb7-26" title="26">        <span class="dt">ssize_t</span> (*quota_write)(<span class="kw">struct</span> super_block *, <span class="dt">int</span>, <span class="dt">const</span> <span class="dt">char</span> *, <span class="dt">size_t</span>, loff_t);</a>
<a class="sourceLine" id="cb7-27" title="27">        <span class="kw">struct</span> dquot **(*get_dquots)(<span class="kw">struct</span> inode *);</a>
<a class="sourceLine" id="cb7-28" title="28"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb7-29" title="29">        <span class="dt">long</span> (*nr_cached_objects)(<span class="kw">struct</span> super_block *,</a>
<a class="sourceLine" id="cb7-30" title="30">                                  <span class="kw">struct</span> shrink_control *);</a>
<a class="sourceLine" id="cb7-31" title="31">        <span class="dt">long</span> (*free_cached_objects)(<span class="kw">struct</span> super_block *,</a>
<a class="sourceLine" id="cb7-32" title="32">                                    <span class="kw">struct</span> shrink_control *);</a>
<a class="sourceLine" id="cb7-33" title="33">        <span class="dt">void</span> (*shutdown)(<span class="kw">struct</span> super_block *sb);</a>
<a class="sourceLine" id="cb7-34" title="34">};</a></code></pre></div>
<p>注意在C语言的实现中，如果要获取<code>struct super_block *</code>父对象，必须要传入指针。</p>
<h2 id="索引节点对象"><span class="header-section-number">2.3</span> 索引节点对象</h2>
<p>索引节点包含了操作文件和目录时的全部信息，也定义在<code>include/linux/fs.h</code>。也不需要背，用到时查一下就可以。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co"> * 将“struct inode”中的大多数已读字段和经常访问的字段（特别是用于RCU路径查找和“stat”数据的字段）放在前面。</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">struct</span> inode {</a>
<a class="sourceLine" id="cb8-5" title="5">        umode_t                 i_mode; <span class="co">// 访问权限</span></a>
<a class="sourceLine" id="cb8-6" title="6">        <span class="dt">unsigned</span> <span class="dt">short</span>          i_opflags;</a>
<a class="sourceLine" id="cb8-7" title="7">        kuid_t                  i_uid; <span class="co">// 使用者的id</span></a>
<a class="sourceLine" id="cb8-8" title="8">        kgid_t                  i_gid; <span class="co">// 使用组的id</span></a>
<a class="sourceLine" id="cb8-9" title="9">        <span class="dt">unsigned</span> <span class="dt">int</span>            i_flags; <span class="co">// 文件系统标志</span></a>
<a class="sourceLine" id="cb8-10" title="10"></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="pp">#ifdef CONFIG_FS_POSIX_ACL</span></a>
<a class="sourceLine" id="cb8-12" title="12">        <span class="kw">struct</span> posix_acl        *i_acl;</a>
<a class="sourceLine" id="cb8-13" title="13">        <span class="kw">struct</span> posix_acl        *i_default_acl;</a>
<a class="sourceLine" id="cb8-14" title="14"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16">        <span class="dt">const</span> <span class="kw">struct</span> inode_operations   *i_op; <span class="co">// 索引节点操作表</span></a>
<a class="sourceLine" id="cb8-17" title="17">        <span class="kw">struct</span> super_block      *i_sb; <span class="co">// 相关的超级块</span></a>
<a class="sourceLine" id="cb8-18" title="18">        <span class="kw">struct</span> address_space    *i_mapping; <span class="co">// 相关的地址映射</span></a>
<a class="sourceLine" id="cb8-19" title="19"></a>
<a class="sourceLine" id="cb8-20" title="20"><span class="pp">#ifdef CONFIG_SECURITY</span></a>
<a class="sourceLine" id="cb8-21" title="21">        <span class="dt">void</span>                    *i_security; <span class="co">// 安全模块</span></a>
<a class="sourceLine" id="cb8-22" title="22"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-23" title="23"></a>
<a class="sourceLine" id="cb8-24" title="24">        <span class="co">/* 统计数据，不在路径遍历中访问 */</span></a>
<a class="sourceLine" id="cb8-25" title="25">        <span class="dt">unsigned</span> <span class="dt">long</span>           i_ino; <span class="co">// 索引节点号</span></a>
<a class="sourceLine" id="cb8-26" title="26">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb8-27" title="27"><span class="co">         * 文件系统只能直接读取 i_nlink。它们应该使用以下函数进行修改:</span></a>
<a class="sourceLine" id="cb8-28" title="28"><span class="co">         *</span></a>
<a class="sourceLine" id="cb8-29" title="29"><span class="co">         *    (set|clear|inc|drop)_nlink</span></a>
<a class="sourceLine" id="cb8-30" title="30"><span class="co">         *    inode_(inc|dec)_link_count</span></a>
<a class="sourceLine" id="cb8-31" title="31"><span class="co">         */</span></a>
<a class="sourceLine" id="cb8-32" title="32">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb8-33" title="33">                <span class="dt">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> i_nlink; <span class="co">// 硬链接数</span></a>
<a class="sourceLine" id="cb8-34" title="34">                <span class="dt">unsigned</span> <span class="dt">int</span> __i_nlink;</a>
<a class="sourceLine" id="cb8-35" title="35">        };</a>
<a class="sourceLine" id="cb8-36" title="36">        dev_t                   i_rdev; <span class="co">// 实际设备标识符</span></a>
<a class="sourceLine" id="cb8-37" title="37">        loff_t                  i_size; <span class="co">// 大小，单位: 字节</span></a>
<a class="sourceLine" id="cb8-38" title="38">        <span class="kw">struct</span> timespec64       i_atime; <span class="co">// 最后访问时间</span></a>
<a class="sourceLine" id="cb8-39" title="39">        <span class="kw">struct</span> timespec64       i_mtime; <span class="co">// 最后修改时间</span></a>
<a class="sourceLine" id="cb8-40" title="40">        <span class="kw">struct</span> timespec64       __i_ctime; <span class="co">/* 使用 inode_*_ctime accessors ! 最后改变时间 */</span></a>
<a class="sourceLine" id="cb8-41" title="41">        spinlock_t              i_lock; <span class="co">/* 保护 i_blocks, i_bytes, 还有 i_size，自旋锁 */</span></a>
<a class="sourceLine" id="cb8-42" title="42">        <span class="dt">unsigned</span> <span class="dt">short</span>          i_bytes; <span class="co">// 使用的字节数</span></a>
<a class="sourceLine" id="cb8-43" title="43">        u8                      i_blkbits; <span class="co">// 以位为单位的块大小</span></a>
<a class="sourceLine" id="cb8-44" title="44">        u8                      i_write_hint;</a>
<a class="sourceLine" id="cb8-45" title="45">        blkcnt_t                i_blocks; <span class="co">// 文件的块数</span></a>
<a class="sourceLine" id="cb8-46" title="46"></a>
<a class="sourceLine" id="cb8-47" title="47"><span class="pp">#ifdef __NEED_I_SIZE_ORDERED</span></a>
<a class="sourceLine" id="cb8-48" title="48">        seqcount_t              i_size_seqcount; <span class="co">// 对 i_size 进行串行计数</span></a>
<a class="sourceLine" id="cb8-49" title="49"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-50" title="50"></a>
<a class="sourceLine" id="cb8-51" title="51">        <span class="co">/* Miscellaneous 杂项 */</span></a>
<a class="sourceLine" id="cb8-52" title="52">        <span class="dt">unsigned</span> <span class="dt">long</span>           i_state; <span class="co">// 状态标志</span></a>
<a class="sourceLine" id="cb8-53" title="53">        <span class="kw">struct</span> rw_semaphore     i_rwsem;</a>
<a class="sourceLine" id="cb8-54" title="54"></a>
<a class="sourceLine" id="cb8-55" title="55">        <span class="dt">unsigned</span> <span class="dt">long</span>           dirtied_when;   <span class="co">/* 第一次弄脏时的 jiffies 值，第一次弄脏数据的时间 */</span></a>
<a class="sourceLine" id="cb8-56" title="56">        <span class="dt">unsigned</span> <span class="dt">long</span>           dirtied_time_when;</a>
<a class="sourceLine" id="cb8-57" title="57"></a>
<a class="sourceLine" id="cb8-58" title="58">        <span class="kw">struct</span> hlist_node       i_hash; <span class="co">// 散列表</span></a>
<a class="sourceLine" id="cb8-59" title="59">        <span class="kw">struct</span> list_head        i_io_list;      <span class="co">/* 后备设备 IO 列表 */</span></a>
<a class="sourceLine" id="cb8-60" title="60"><span class="pp">#ifdef CONFIG_CGROUP_WRITEBACK</span></a>
<a class="sourceLine" id="cb8-61" title="61">        <span class="kw">struct</span> bdi_writeback    *i_wb;          <span class="co">/* 关联的 cgroup wb */</span></a>
<a class="sourceLine" id="cb8-62" title="62"></a>
<a class="sourceLine" id="cb8-63" title="63">        <span class="co">/* 外来 inode 检测，参见 wbc_detach_inode() */</span></a>
<a class="sourceLine" id="cb8-64" title="64">        <span class="dt">int</span>                     i_wb_frn_winner;</a>
<a class="sourceLine" id="cb8-65" title="65">        u16                     i_wb_frn_avg_time;</a>
<a class="sourceLine" id="cb8-66" title="66">        u16                     i_wb_frn_history;</a>
<a class="sourceLine" id="cb8-67" title="67"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-68" title="68">        <span class="kw">struct</span> list_head        i_lru;          <span class="co">/* inode LRU list，Least Recently Used 最近最少使用链表 */</span></a>
<a class="sourceLine" id="cb8-69" title="69">        <span class="kw">struct</span> list_head        i_sb_list; <span class="co">// 超级块链表</span></a>
<a class="sourceLine" id="cb8-70" title="70">        <span class="kw">struct</span> list_head        i_wb_list;      <span class="co">/* 后备设备回写列表 */</span></a>
<a class="sourceLine" id="cb8-71" title="71">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb8-72" title="72">                <span class="kw">struct</span> hlist_head       i_dentry; <span class="co">// 目录项链表</span></a>
<a class="sourceLine" id="cb8-73" title="73">                <span class="kw">struct</span> rcu_head         i_rcu;</a>
<a class="sourceLine" id="cb8-74" title="74">        };</a>
<a class="sourceLine" id="cb8-75" title="75">        atomic64_t              i_version; <span class="co">// 版本号</span></a>
<a class="sourceLine" id="cb8-76" title="76">        atomic64_t              i_sequence; <span class="co">/* see futex */</span></a>
<a class="sourceLine" id="cb8-77" title="77">        atomic_t                i_count; <span class="co">// 引用计数</span></a>
<a class="sourceLine" id="cb8-78" title="78">        atomic_t                i_dio_count;</a>
<a class="sourceLine" id="cb8-79" title="79">        atomic_t                i_writecount; <span class="co">// 写者计数</span></a>
<a class="sourceLine" id="cb8-80" title="80"><span class="pp">#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)</span></a>
<a class="sourceLine" id="cb8-81" title="81">        atomic_t                i_readcount; <span class="co">/* struct files open RO */</span></a>
<a class="sourceLine" id="cb8-82" title="82"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-83" title="83">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb8-84" title="84">                <span class="dt">const</span> <span class="kw">struct</span> file_operations    *i_fop; <span class="co">/* former -&gt;i_op-&gt;default_file_ops，默认的索引节点操作 */</span></a>
<a class="sourceLine" id="cb8-85" title="85">                <span class="dt">void</span> (*free_inode)(<span class="kw">struct</span> inode *);</a>
<a class="sourceLine" id="cb8-86" title="86">        };</a>
<a class="sourceLine" id="cb8-87" title="87">        <span class="kw">struct</span> file_lock_context        *i_flctx;</a>
<a class="sourceLine" id="cb8-88" title="88">        <span class="kw">struct</span> address_space    i_data; <span class="co">// 设备地址映射</span></a>
<a class="sourceLine" id="cb8-89" title="89">        <span class="kw">struct</span> list_head        i_devices; <span class="co">// 块设备链表</span></a>
<a class="sourceLine" id="cb8-90" title="90">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb8-91" title="91">                <span class="kw">struct</span> pipe_inode_info  *i_pipe; <span class="co">// 管道信息</span></a>
<a class="sourceLine" id="cb8-92" title="92">                <span class="kw">struct</span> cdev             *i_cdev; <span class="co">// 字符设备驱动</span></a>
<a class="sourceLine" id="cb8-93" title="93">                <span class="dt">char</span>                    *i_link;</a>
<a class="sourceLine" id="cb8-94" title="94">                <span class="dt">unsigned</span>                i_dir_seq;</a>
<a class="sourceLine" id="cb8-95" title="95">        };</a>
<a class="sourceLine" id="cb8-96" title="96"></a>
<a class="sourceLine" id="cb8-97" title="97">        __u32                   i_generation;</a>
<a class="sourceLine" id="cb8-98" title="98"></a>
<a class="sourceLine" id="cb8-99" title="99"><span class="pp">#ifdef CONFIG_FSNOTIFY</span></a>
<a class="sourceLine" id="cb8-100" title="100">        __u32                   i_fsnotify_mask; <span class="co">/* 该 inode 关心的所有事件 */</span></a>
<a class="sourceLine" id="cb8-101" title="101">        <span class="kw">struct</span> fsnotify_mark_connector __rcu    *i_fsnotify_marks;</a>
<a class="sourceLine" id="cb8-102" title="102"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-103" title="103"></a>
<a class="sourceLine" id="cb8-104" title="104"><span class="pp">#ifdef CONFIG_FS_ENCRYPTION</span></a>
<a class="sourceLine" id="cb8-105" title="105">        <span class="kw">struct</span> fscrypt_info     *i_crypt_info;</a>
<a class="sourceLine" id="cb8-106" title="106"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-107" title="107"></a>
<a class="sourceLine" id="cb8-108" title="108"><span class="pp">#ifdef CONFIG_FS_VERITY</span></a>
<a class="sourceLine" id="cb8-109" title="109">        <span class="kw">struct</span> fsverity_info    *i_verity_info;</a>
<a class="sourceLine" id="cb8-110" title="110"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb8-111" title="111"></a>
<a class="sourceLine" id="cb8-112" title="112">        <span class="dt">void</span>                    *i_private; <span class="co">/* 文件系统或设备的私有指针 */</span></a>
<a class="sourceLine" id="cb8-113" title="113">} __randomize_layout;</a></code></pre></div>
<h2 id="索引节点操作"><span class="header-section-number">2.4</span> 索引节点操作</h2>
<p>索引节点对象中最重要的一个成员是<code>i_op</code>，也是面向对象思想的一个体现，索引节点操作函数表结构体也是定义在文件<code>include/linux/fs.h</code>中。还是不需要背，用到什么查什么就好。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">struct</span> inode_operations {</a>
<a class="sourceLine" id="cb9-2" title="2">        <span class="kw">struct</span> dentry * (*lookup) (<span class="kw">struct</span> inode *,<span class="kw">struct</span> dentry *, <span class="dt">unsigned</span> <span class="dt">int</span>); <span class="co">// 寻找索引节点，对应dentry中的文件名</span></a>
<a class="sourceLine" id="cb9-3" title="3">        <span class="dt">const</span> <span class="dt">char</span> * (*get_link) (<span class="kw">struct</span> dentry *, <span class="kw">struct</span> inode *, <span class="kw">struct</span> delayed_call *);</a>
<a class="sourceLine" id="cb9-4" title="4">        <span class="dt">int</span> (*permission) (<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> inode *, <span class="dt">int</span>); <span class="co">// 检查访问模式</span></a>
<a class="sourceLine" id="cb9-5" title="5">        <span class="kw">struct</span> posix_acl * (*get_inode_acl)(<span class="kw">struct</span> inode *, <span class="dt">int</span>, <span class="dt">bool</span>);</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7">        <span class="dt">int</span> (*readlink) (<span class="kw">struct</span> dentry *, <span class="dt">char</span> __user *,<span class="dt">int</span>); <span class="co">// 复制符号链接中的数据</span></a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9">        <span class="dt">int</span> (*create) (<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> inode *,<span class="kw">struct</span> dentry *, <span class="co">// 为dentry创建一个新的索引节点</span></a>
<a class="sourceLine" id="cb9-10" title="10">                       umode_t, <span class="dt">bool</span>);</a>
<a class="sourceLine" id="cb9-11" title="11">        <span class="dt">int</span> (*link) (<span class="kw">struct</span> dentry *,<span class="kw">struct</span> inode *,<span class="kw">struct</span> dentry *); <span class="co">// 创建硬链接</span></a>
<a class="sourceLine" id="cb9-12" title="12">        <span class="dt">int</span> (*unlink) (<span class="kw">struct</span> inode *,<span class="kw">struct</span> dentry *); <span class="co">// 删除索引节点对象</span></a>
<a class="sourceLine" id="cb9-13" title="13">        <span class="dt">int</span> (*symlink) (<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> inode *,<span class="kw">struct</span> dentry *, <span class="co">// 创建符号链接</span></a>
<a class="sourceLine" id="cb9-14" title="14">                        <span class="dt">const</span> <span class="dt">char</span> *);</a>
<a class="sourceLine" id="cb9-15" title="15">        <span class="dt">int</span> (*mkdir) (<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> inode *,<span class="kw">struct</span> dentry *, <span class="co">// 创建新目录</span></a>
<a class="sourceLine" id="cb9-16" title="16">                      umode_t);</a>
<a class="sourceLine" id="cb9-17" title="17">        <span class="dt">int</span> (*rmdir) (<span class="kw">struct</span> inode *,<span class="kw">struct</span> dentry *); <span class="co">// 删除目录</span></a>
<a class="sourceLine" id="cb9-18" title="18">        <span class="dt">int</span> (*mknod) (<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> inode *,<span class="kw">struct</span> dentry *, <span class="co">// 创建特殊文件（设备文件、命名管道、套接字）</span></a>
<a class="sourceLine" id="cb9-19" title="19">                      umode_t,dev_t);</a>
<a class="sourceLine" id="cb9-20" title="20">        <span class="dt">int</span> (*rename) (<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> inode *, <span class="kw">struct</span> dentry *, <span class="co">// 移动文件</span></a>
<a class="sourceLine" id="cb9-21" title="21">                        <span class="kw">struct</span> inode *, <span class="kw">struct</span> dentry *, <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb9-22" title="22">        <span class="dt">int</span> (*setattr) (<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> dentry *, <span class="kw">struct</span> iattr *); <span class="co">// 被notify_change()调用，修改索引节点后，通知</span></a>
<a class="sourceLine" id="cb9-23" title="23">        <span class="dt">int</span> (*getattr) (<span class="kw">struct</span> mnt_idmap *, <span class="dt">const</span> <span class="kw">struct</span> path *, <span class="co">// 从磁盘更新时调用</span></a>
<a class="sourceLine" id="cb9-24" title="24">                        <span class="kw">struct</span> kstat *, u32, <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb9-25" title="25">        <span class="dt">ssize_t</span> (*listxattr) (<span class="kw">struct</span> dentry *, <span class="dt">char</span> *, <span class="dt">size_t</span>); <span class="co">// 将所有属性列表复制到缓冲列表中</span></a>
<a class="sourceLine" id="cb9-26" title="26">        <span class="dt">int</span> (*fiemap)(<span class="kw">struct</span> inode *, <span class="kw">struct</span> fiemap_extent_info *, u64 start,</a>
<a class="sourceLine" id="cb9-27" title="27">                      u64 len);</a>
<a class="sourceLine" id="cb9-28" title="28">        <span class="dt">int</span> (*update_time)(<span class="kw">struct</span> inode *, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb9-29" title="29">        <span class="dt">int</span> (*atomic_open)(<span class="kw">struct</span> inode *, <span class="kw">struct</span> dentry *,</a>
<a class="sourceLine" id="cb9-30" title="30">                           <span class="kw">struct</span> file *, <span class="dt">unsigned</span> open_flag,</a>
<a class="sourceLine" id="cb9-31" title="31">                           umode_t create_mode);</a>
<a class="sourceLine" id="cb9-32" title="32">        <span class="dt">int</span> (*tmpfile) (<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> inode *,</a>
<a class="sourceLine" id="cb9-33" title="33">                        <span class="kw">struct</span> file *, umode_t);</a>
<a class="sourceLine" id="cb9-34" title="34">        <span class="kw">struct</span> posix_acl *(*get_acl)(<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> dentry *,</a>
<a class="sourceLine" id="cb9-35" title="35">                                     <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb9-36" title="36">        <span class="dt">int</span> (*set_acl)(<span class="kw">struct</span> mnt_idmap *, <span class="kw">struct</span> dentry *,</a>
<a class="sourceLine" id="cb9-37" title="37">                       <span class="kw">struct</span> posix_acl *, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb9-38" title="38">        <span class="dt">int</span> (*fileattr_set)(<span class="kw">struct</span> mnt_idmap *idmap,</a>
<a class="sourceLine" id="cb9-39" title="39">                            <span class="kw">struct</span> dentry *dentry, <span class="kw">struct</span> fileattr *fa);</a>
<a class="sourceLine" id="cb9-40" title="40">        <span class="dt">int</span> (*fileattr_get)(<span class="kw">struct</span> dentry *dentry, <span class="kw">struct</span> fileattr *fa);</a>
<a class="sourceLine" id="cb9-41" title="41">        <span class="kw">struct</span> offset_ctx *(*get_offset_ctx)(<span class="kw">struct</span> inode *inode);</a>
<a class="sourceLine" id="cb9-42" title="42">} ____cacheline_aligned;</a></code></pre></div>
<h2 id="目录项对象"><span class="header-section-number">2.5</span> 目录项对象</h2>
<p>需要注意目录项表示路径中的一个部分，如<code>/home/linux/file</code>路径中，<code>/</code>、<code>home</code>、<code>linux</code>是目录，属于目录项对象，<code>file</code>属于文件，也属于目录项对象。也就是说，目录项也能表示文件。目录项对象结构体定义在<code>include/linux/dcache.h</code>中，成员不多。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">struct</span> dentry {</a>
<a class="sourceLine" id="cb10-2" title="2">        <span class="co">/* RCU 查找涉及的字段 */</span></a>
<a class="sourceLine" id="cb10-3" title="3">        <span class="dt">unsigned</span> <span class="dt">int</span> d_flags;           <span class="co">/* 受 d_lock 保护，目录项标识 */</span></a>
<a class="sourceLine" id="cb10-4" title="4">        seqcount_spinlock_t d_seq;      <span class="co">/* 每个目录项的 seqlock */</span></a>
<a class="sourceLine" id="cb10-5" title="5">        <span class="kw">struct</span> hlist_bl_node d_hash;    <span class="co">/* 查找哈希列表 */</span></a>
<a class="sourceLine" id="cb10-6" title="6">        <span class="kw">struct</span> dentry *d_parent;        <span class="co">/* 父目录 */</span></a>
<a class="sourceLine" id="cb10-7" title="7">        <span class="kw">struct</span> qstr d_name;             <span class="co">// 目录项名，d_name.name是字符串数组</span></a>
<a class="sourceLine" id="cb10-8" title="8">        <span class="kw">struct</span> inode *d_inode;          <span class="co">/* 名称所属的位置 - NULL 表示negative， 关联的索引节点 */</span></a>
<a class="sourceLine" id="cb10-9" title="9">        <span class="dt">unsigned</span> <span class="dt">char</span> d_iname[DNAME_INLINE_LEN];        <span class="co">/* 短文件名 */</span></a>
<a class="sourceLine" id="cb10-10" title="10"></a>
<a class="sourceLine" id="cb10-11" title="11">        <span class="co">/* 引用查找也涉及以下内容 */</span></a>
<a class="sourceLine" id="cb10-12" title="12">        <span class="kw">struct</span> lockref d_lockref;       <span class="co">/* 每个目录项的锁和引用计数，用d_count()函数获取 */</span></a>
<a class="sourceLine" id="cb10-13" title="13">        <span class="dt">const</span> <span class="kw">struct</span> dentry_operations *d_op; <span class="co">// 目录项操作指针</span></a>
<a class="sourceLine" id="cb10-14" title="14">        <span class="kw">struct</span> super_block *d_sb;       <span class="co">/* 目录项树的根，文件的超级块 */</span></a>
<a class="sourceLine" id="cb10-15" title="15">        <span class="dt">unsigned</span> <span class="dt">long</span> d_time;           <span class="co">/* 由 d_revalidate 使用，重置时间 */</span></a>
<a class="sourceLine" id="cb10-16" title="16">        <span class="dt">void</span> *d_fsdata;                 <span class="co">/* 文件系统特有数据 */</span></a>
<a class="sourceLine" id="cb10-17" title="17"></a>
<a class="sourceLine" id="cb10-18" title="18">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb10-19" title="19">                <span class="kw">struct</span> list_head d_lru;         <span class="co">/* LRU list，Least Recently Used 最近最少使用链表 */</span></a>
<a class="sourceLine" id="cb10-20" title="20">                wait_queue_head_t *d_wait;      <span class="co">/* 仅用于查找中的项目 */</span></a>
<a class="sourceLine" id="cb10-21" title="21">        };</a>
<a class="sourceLine" id="cb10-22" title="22">        <span class="kw">struct</span> list_head d_child;       <span class="co">/* 父列表的子项，目录项内部形成的链表 */</span></a>
<a class="sourceLine" id="cb10-23" title="23">        <span class="kw">struct</span> list_head d_subdirs;     <span class="co">/* 子目录链表 */</span></a>
<a class="sourceLine" id="cb10-24" title="24">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb10-25" title="25"><span class="co">         * d_alias 和 d_rcu 可以共享内存</span></a>
<a class="sourceLine" id="cb10-26" title="26"><span class="co">         */</span></a>
<a class="sourceLine" id="cb10-27" title="27">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb10-28" title="28">                <span class="kw">struct</span> hlist_node d_alias;      <span class="co">/* inode alias list，索引节点别名链表，当有多个硬链接时，就有多个dentry指向同一个inode，多个dentry都放到d_alias链表中 */</span></a>
<a class="sourceLine" id="cb10-29" title="29">                <span class="kw">struct</span> hlist_bl_node d_in_lookup_hash;  <span class="co">/* 仅用于查找中的项目 */</span></a>
<a class="sourceLine" id="cb10-30" title="30">                <span class="kw">struct</span> rcu_head d_rcu; <span class="co">// RCU加锁</span></a>
<a class="sourceLine" id="cb10-31" title="31">        } d_u;</a>
<a class="sourceLine" id="cb10-32" title="32">} __randomize_layout;</a></code></pre></div>
<p>目录项有3种状态:</p>
<ul>
<li>被使用: <code>d_inode</code>不为空，<code>d_count()</code>大于等于<code>1</code></li>
<li>未被使用: <code>d_inode</code>不为空，<code>d_count()</code>为<code>0</code>，注意曾经可能使用过</li>
<li>无效状态: <code>d_inode</code>为空</li>
</ul>
<p>目录项缓存有3种:</p>
<ul>
<li>“被使用的”目录项链表: <code>inode-&gt;i_dentry</code>链表，一个<code>inode</code>可能有多个链接，一个<code>inode</code>可能有多个<code>dentry</code></li>
<li>“Least Recently Used 最近最少使用”链表: <code>d_lru</code>链表，包含未被使用和无效状态的<code>dentry</code></li>
<li>散列表: <code>dentry_hashtable</code>链表，散列值由<code>d_hash()</code>计算，<code>d_lookup()</code>查找散列表</li>
</ul>
<p>目录项让相应的索引节点的<code>i_count</code>为正，目录项被缓存了，索引节点肯定也被缓存了。</p>
<h2 id="目录项操作"><span class="header-section-number">2.6</span> 目录项操作</h2>
<p>目录项对象中最重要的一个成员是<code>d_op</code>，目录项操作结构体定义在<code>include/linux/dcache.h</code>中，方法不多。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">struct</span> dentry_operations {</a>
<a class="sourceLine" id="cb11-2" title="2">        <span class="dt">int</span> (*d_revalidate)(<span class="kw">struct</span> dentry *, <span class="dt">unsigned</span> <span class="dt">int</span>); <span class="co">// 判断目录项对象是否有效，从缓存中使用目录项时会调用，一般文件系统不实现这个方法</span></a>
<a class="sourceLine" id="cb11-3" title="3">        <span class="dt">int</span> (*d_weak_revalidate)(<span class="kw">struct</span> dentry *, <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb11-4" title="4">        <span class="dt">int</span> (*d_hash)(<span class="dt">const</span> <span class="kw">struct</span> dentry *, <span class="kw">struct</span> qstr *); <span class="co">// 生成散列值</span></a>
<a class="sourceLine" id="cb11-5" title="5">        <span class="dt">int</span> (*d_compare)(<span class="dt">const</span> <span class="kw">struct</span> dentry *, <span class="co">// 比较两个文件名，微软的文件系统需要实现，因为不区分大小写</span></a>
<a class="sourceLine" id="cb11-6" title="6">                        <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">const</span> <span class="dt">char</span> *, <span class="dt">const</span> <span class="kw">struct</span> qstr *);</a>
<a class="sourceLine" id="cb11-7" title="7">        <span class="dt">int</span> (*d_delete)(<span class="dt">const</span> <span class="kw">struct</span> dentry *); <span class="co">// d_count等于0时调用</span></a>
<a class="sourceLine" id="cb11-8" title="8">        <span class="dt">int</span> (*d_init)(<span class="kw">struct</span> dentry *);</a>
<a class="sourceLine" id="cb11-9" title="9">        <span class="dt">void</span> (*d_release)(<span class="kw">struct</span> dentry *); <span class="co">// 释放</span></a>
<a class="sourceLine" id="cb11-10" title="10">        <span class="dt">void</span> (*d_prune)(<span class="kw">struct</span> dentry *);</a>
<a class="sourceLine" id="cb11-11" title="11">        <span class="dt">void</span> (*d_iput)(<span class="kw">struct</span> dentry *, <span class="kw">struct</span> inode *); <span class="co">// dentry丢失相关的inode，也就是磁盘索引节点被删除了，调用此方法</span></a>
<a class="sourceLine" id="cb11-12" title="12">        <span class="dt">char</span> *(*d_dname)(<span class="kw">struct</span> dentry *, <span class="dt">char</span> *, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb11-13" title="13">        <span class="kw">struct</span> vfsmount *(*d_automount)(<span class="kw">struct</span> path *);</a>
<a class="sourceLine" id="cb11-14" title="14">        <span class="dt">int</span> (*d_manage)(<span class="dt">const</span> <span class="kw">struct</span> path *, <span class="dt">bool</span>);</a>
<a class="sourceLine" id="cb11-15" title="15">        <span class="kw">struct</span> dentry *(*d_real)(<span class="kw">struct</span> dentry *, <span class="dt">const</span> <span class="kw">struct</span> inode *);</a>
<a class="sourceLine" id="cb11-16" title="16">} ____cacheline_aligned;</a></code></pre></div>
<h2 id="文件对象"><span class="header-section-number">2.7</span> 文件对象</h2>
<p>站在用户角度，我们更关心的是文件对象。文件对象表示进程打开的文件，多个进程可能同时打开和操作同一个文件，同一个文件可能存在多个文件对象，最终指向同一个<code>dentry</code>。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co"> * f_{lock,count,pos_lock}成员可能存在高度争用，共享相同的缓存行。</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co"> * 而f_{lock,mode}经常一起使用，因此也共享相同的缓存行。</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co"> * 读取频率较高的f_{path,inode,op}被保存在单独的缓存行中。</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="kw">struct</span> file {</a>
<a class="sourceLine" id="cb12-7" title="7">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb12-8" title="8">                <span class="kw">struct</span> llist_node       f_llist; <span class="co">// 文件对象链表</span></a>
<a class="sourceLine" id="cb12-9" title="9">                <span class="kw">struct</span> rcu_head         f_rcuhead; <span class="co">// 释放之后的rcu链表</span></a>
<a class="sourceLine" id="cb12-10" title="10">                <span class="dt">unsigned</span> <span class="dt">int</span>            f_iocb_flags;</a>
<a class="sourceLine" id="cb12-11" title="11">        };</a>
<a class="sourceLine" id="cb12-12" title="12"></a>
<a class="sourceLine" id="cb12-13" title="13">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb12-14" title="14"><span class="co">         * 保护 f_ep 和 f_flags。</span></a>
<a class="sourceLine" id="cb12-15" title="15"><span class="co">         * 禁止在 IRQ 上下文中获取。</span></a>
<a class="sourceLine" id="cb12-16" title="16"><span class="co">         */</span></a>
<a class="sourceLine" id="cb12-17" title="17">        spinlock_t              f_lock; <span class="co">// 单个文件结构锁</span></a>
<a class="sourceLine" id="cb12-18" title="18">        fmode_t                 f_mode; <span class="co">// 访问模式</span></a>
<a class="sourceLine" id="cb12-19" title="19">        atomic_long_t           f_count; <span class="co">// 引用计数</span></a>
<a class="sourceLine" id="cb12-20" title="20">        <span class="kw">struct</span> mutex            f_pos_lock;</a>
<a class="sourceLine" id="cb12-21" title="21">        loff_t                  f_pos; <span class="co">// 当前位移量（文件指针）</span></a>
<a class="sourceLine" id="cb12-22" title="22">        <span class="dt">unsigned</span> <span class="dt">int</span>            f_flags; <span class="co">// 打开时指定的标志</span></a>
<a class="sourceLine" id="cb12-23" title="23">        <span class="kw">struct</span> fown_struct      f_owner; <span class="co">// 拥有者通过信号进行异步IO数据的传送</span></a>
<a class="sourceLine" id="cb12-24" title="24">        <span class="dt">const</span> <span class="kw">struct</span> cred       *f_cred; <span class="co">// 文件的信任状</span></a>
<a class="sourceLine" id="cb12-25" title="25">        <span class="kw">struct</span> file_ra_state    f_ra; <span class="co">// 预读状态</span></a>
<a class="sourceLine" id="cb12-26" title="26">        <span class="kw">struct</span> path             f_path; <span class="co">// 包含dentry和vfsmount</span></a>
<a class="sourceLine" id="cb12-27" title="27">        <span class="kw">struct</span> inode            *f_inode;       <span class="co">/* cached value */</span></a>
<a class="sourceLine" id="cb12-28" title="28">        <span class="dt">const</span> <span class="kw">struct</span> file_operations    *f_op; <span class="co">// 文件操作表</span></a>
<a class="sourceLine" id="cb12-29" title="29"></a>
<a class="sourceLine" id="cb12-30" title="30">        u64                     f_version; <span class="co">// 版本号</span></a>
<a class="sourceLine" id="cb12-31" title="31"><span class="pp">#ifdef CONFIG_SECURITY</span></a>
<a class="sourceLine" id="cb12-32" title="32">        <span class="dt">void</span>                    *f_security; <span class="co">// 安全模块</span></a>
<a class="sourceLine" id="cb12-33" title="33"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb12-34" title="34">        <span class="co">/* tty 驱动程序以及其他驱动程序可能需要 */</span></a>
<a class="sourceLine" id="cb12-35" title="35">        <span class="dt">void</span>                    *private_data; <span class="co">// tty设备驱动的钩子</span></a>
<a class="sourceLine" id="cb12-36" title="36"></a>
<a class="sourceLine" id="cb12-37" title="37"><span class="pp">#ifdef CONFIG_EPOLL</span></a>
<a class="sourceLine" id="cb12-38" title="38">        <span class="co">/* 由 fs/eventpoll.c 用于链接所有的钩子到这个file对象 */</span></a>
<a class="sourceLine" id="cb12-39" title="39">        <span class="kw">struct</span> hlist_head       *f_ep; <span class="co">// 事件池链表</span></a>
<a class="sourceLine" id="cb12-40" title="40"><span class="pp">#endif </span><span class="co">/* #ifdef CONFIG_EPOLL */</span></a>
<a class="sourceLine" id="cb12-41" title="41">        <span class="kw">struct</span> address_space    *f_mapping; <span class="co">// 页缓存映射</span></a>
<a class="sourceLine" id="cb12-42" title="42">        errseq_t                f_wb_err;</a>
<a class="sourceLine" id="cb12-43" title="43">        errseq_t                f_sb_err; <span class="co">/* for syncfs */</span></a>
<a class="sourceLine" id="cb12-44" title="44">} __randomize_layout</a>
<a class="sourceLine" id="cb12-45" title="45">  __attribute__((aligned(<span class="dv">4</span>)));  <span class="co">/* 防止某些奇怪的情况认为 2 是可以的 */</span></a></code></pre></div>
<h2 id="文件操作"><span class="header-section-number">2.8</span> 文件操作</h2>
<p>文件对象中最重要的一个成员是<code>f_op</code>，你会发现，文件操作方法名和很多系统调用很像。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">struct</span> file_operations {</a>
<a class="sourceLine" id="cb13-2" title="2">        <span class="kw">struct</span> module *owner;</a>
<a class="sourceLine" id="cb13-3" title="3">        loff_t (*llseek) (<span class="kw">struct</span> file *, loff_t, <span class="dt">int</span>); <span class="co">// 更新偏移量指针</span></a>
<a class="sourceLine" id="cb13-4" title="4">        <span class="dt">ssize_t</span> (*read) (<span class="kw">struct</span> file *, <span class="dt">char</span> __user *, <span class="dt">size_t</span>, loff_t *); <span class="co">// 读取数据，并更新文件指针</span></a>
<a class="sourceLine" id="cb13-5" title="5">        <span class="dt">ssize_t</span> (*write) (<span class="kw">struct</span> file *, <span class="dt">const</span> <span class="dt">char</span> __user *, <span class="dt">size_t</span>, loff_t *); <span class="co">// 写入数据并更新指针</span></a>
<a class="sourceLine" id="cb13-6" title="6">        <span class="dt">ssize_t</span> (*read_iter) (<span class="kw">struct</span> kiocb *, <span class="kw">struct</span> iov_iter *);</a>
<a class="sourceLine" id="cb13-7" title="7">        <span class="dt">ssize_t</span> (*write_iter) (<span class="kw">struct</span> kiocb *, <span class="kw">struct</span> iov_iter *);</a>
<a class="sourceLine" id="cb13-8" title="8">        <span class="dt">int</span> (*iopoll)(<span class="kw">struct</span> kiocb *kiocb, <span class="kw">struct</span> io_comp_batch *,</a>
<a class="sourceLine" id="cb13-9" title="9">                        <span class="dt">unsigned</span> <span class="dt">int</span> flags);</a>
<a class="sourceLine" id="cb13-10" title="10">        <span class="dt">int</span> (*iterate_shared) (<span class="kw">struct</span> file *, <span class="kw">struct</span> dir_context *); <span class="co">// v6.6在iterate_dir中加读锁，但在较早的版本（如v4.19）有些文件系统未实现此方法时加写锁</span></a>
<a class="sourceLine" id="cb13-11" title="11">        __poll_t (*poll) (<span class="kw">struct</span> file *, <span class="kw">struct</span> poll_table_struct *); <span class="co">// 睡眠等待给定文件活动</span></a>
<a class="sourceLine" id="cb13-12" title="12">        <span class="dt">long</span> (*unlocked_ioctl) (<span class="kw">struct</span> file *, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">long</span>); <span class="co">// 不需要持有BKL，相比compat_ioctl，优先实现此方法</span></a>
<a class="sourceLine" id="cb13-13" title="13">        <span class="dt">long</span> (*compat_ioctl) (<span class="kw">struct</span> file *, <span class="dt">unsigned</span> <span class="dt">int</span>, <span class="dt">unsigned</span> <span class="dt">long</span>); <span class="co">// 可移植变种，也不需要持有BKL</span></a>
<a class="sourceLine" id="cb13-14" title="14">        <span class="dt">int</span> (*mmap) (<span class="kw">struct</span> file *, <span class="kw">struct</span> vm_area_struct *); <span class="co">// 将文件映射到地址空间上</span></a>
<a class="sourceLine" id="cb13-15" title="15">        <span class="dt">unsigned</span> <span class="dt">long</span> mmap_supported_flags;</a>
<a class="sourceLine" id="cb13-16" title="16">        <span class="dt">int</span> (*open) (<span class="kw">struct</span> inode *, <span class="kw">struct</span> file *); <span class="co">// 创建新的文件对象，与inode关联</span></a>
<a class="sourceLine" id="cb13-17" title="17">        <span class="dt">int</span> (*flush) (<span class="kw">struct</span> file *, fl_owner_t id); <span class="co">// 已打开文件的引用计数减少时调用，作用取决于具体的文件系统</span></a>
<a class="sourceLine" id="cb13-18" title="18">        <span class="dt">int</span> (*release) (<span class="kw">struct</span> inode *, <span class="kw">struct</span> file *); <span class="co">// 当引用计数为0时调用，作用取决于具体的文件系统</span></a>
<a class="sourceLine" id="cb13-19" title="19">        <span class="dt">int</span> (*fsync) (<span class="kw">struct</span> file *, loff_t, loff_t, <span class="dt">int</span> datasync); <span class="co">// 所有文件的缓存数据写回磁盘</span></a>
<a class="sourceLine" id="cb13-20" title="20">        <span class="dt">int</span> (*fasync) (<span class="dt">int</span>, <span class="kw">struct</span> file *, <span class="dt">int</span>); <span class="co">// 打开或关闭异步IO的通告信号</span></a>
<a class="sourceLine" id="cb13-21" title="21">        <span class="dt">int</span> (*lock) (<span class="kw">struct</span> file *, <span class="dt">int</span>, <span class="kw">struct</span> file_lock *); <span class="co">// 给文件上锁</span></a>
<a class="sourceLine" id="cb13-22" title="22">        <span class="dt">unsigned</span> <span class="dt">long</span> (*get_unmapped_area)(<span class="kw">struct</span> file *, <span class="dt">unsigned</span> <span class="dt">long</span>, <span class="dt">unsigned</span> <span class="dt">long</span>, <span class="dt">unsigned</span> <span class="dt">long</span>, <span class="dt">unsigned</span> <span class="dt">long</span>); <span class="co">// 获取未使用的地址空间来映射给定的文件</span></a>
<a class="sourceLine" id="cb13-23" title="23">        <span class="dt">int</span> (*check_flags)(<span class="dt">int</span>); <span class="co">// 检查fcntl()系统调用的flags的有效性，只有nfs实现了</span></a>
<a class="sourceLine" id="cb13-24" title="24">        <span class="dt">int</span> (*flock) (<span class="kw">struct</span> file *, <span class="dt">int</span>, <span class="kw">struct</span> file_lock *); <span class="co">// 提供忠告锁</span></a>
<a class="sourceLine" id="cb13-25" title="25">        <span class="dt">ssize_t</span> (*splice_write)(<span class="kw">struct</span> pipe_inode_info *, <span class="kw">struct</span> file *, loff_t *, <span class="dt">size_t</span>, <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb13-26" title="26">        <span class="dt">ssize_t</span> (*splice_read)(<span class="kw">struct</span> file *, loff_t *, <span class="kw">struct</span> pipe_inode_info *, <span class="dt">size_t</span>, <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb13-27" title="27">        <span class="dt">void</span> (*splice_eof)(<span class="kw">struct</span> file *file);</a>
<a class="sourceLine" id="cb13-28" title="28">        <span class="dt">int</span> (*setlease)(<span class="kw">struct</span> file *, <span class="dt">int</span>, <span class="kw">struct</span> file_lock **, <span class="dt">void</span> **);</a>
<a class="sourceLine" id="cb13-29" title="29">        <span class="dt">long</span> (*fallocate)(<span class="kw">struct</span> file *file, <span class="dt">int</span> mode, loff_t offset,</a>
<a class="sourceLine" id="cb13-30" title="30">                          loff_t len);</a>
<a class="sourceLine" id="cb13-31" title="31">        <span class="dt">void</span> (*show_fdinfo)(<span class="kw">struct</span> seq_file *m, <span class="kw">struct</span> file *f);</a>
<a class="sourceLine" id="cb13-32" title="32"><span class="pp">#ifndef CONFIG_MMU</span></a>
<a class="sourceLine" id="cb13-33" title="33">        <span class="dt">unsigned</span> (*mmap_capabilities)(<span class="kw">struct</span> file *);</a>
<a class="sourceLine" id="cb13-34" title="34"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb13-35" title="35">        <span class="dt">ssize_t</span> (*copy_file_range)(<span class="kw">struct</span> file *, loff_t, <span class="kw">struct</span> file *,</a>
<a class="sourceLine" id="cb13-36" title="36">                        loff_t, <span class="dt">size_t</span>, <span class="dt">unsigned</span> <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb13-37" title="37">        loff_t (*remap_file_range)(<span class="kw">struct</span> file *file_in, loff_t pos_in,</a>
<a class="sourceLine" id="cb13-38" title="38">                                   <span class="kw">struct</span> file *file_out, loff_t pos_out,</a>
<a class="sourceLine" id="cb13-39" title="39">                                   loff_t len, <span class="dt">unsigned</span> <span class="dt">int</span> remap_flags);</a>
<a class="sourceLine" id="cb13-40" title="40">        <span class="dt">int</span> (*fadvise)(<span class="kw">struct</span> file *, loff_t, loff_t, <span class="dt">int</span>);</a>
<a class="sourceLine" id="cb13-41" title="41">        <span class="dt">int</span> (*uring_cmd)(<span class="kw">struct</span> io_uring_cmd *ioucmd, <span class="dt">unsigned</span> <span class="dt">int</span> issue_flags);</a>
<a class="sourceLine" id="cb13-42" title="42">        <span class="dt">int</span> (*uring_cmd_iopoll)(<span class="kw">struct</span> io_uring_cmd *, <span class="kw">struct</span> io_comp_batch *,</a>
<a class="sourceLine" id="cb13-43" title="43">                                <span class="dt">unsigned</span> <span class="dt">int</span> poll_flags);</a>
<a class="sourceLine" id="cb13-44" title="44">} __randomize_layout;</a></code></pre></div>
<h2 id="地址空间"><span class="header-section-number">2.9</span> 地址空间</h2>
<p>磁盘块可能不连续和动态变化的，文件访问需要将文件看作一个连续的字节流，这个矛盾的解决核心在于地址空间的引入。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// 可缓存、可映射对象的内容。</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="kw">struct</span> address_space {</a>
<a class="sourceLine" id="cb14-3" title="3">        <span class="kw">struct</span> inode            *host;            <span class="co">// 拥有者，可以是 inode 或 block_device。</span></a>
<a class="sourceLine" id="cb14-4" title="4">        <span class="kw">struct</span> xarray           i_pages;          <span class="co">// 缓存的页面。</span></a>
<a class="sourceLine" id="cb14-5" title="5">        <span class="kw">struct</span> rw_semaphore     invalidate_lock;  <span class="co">// 在无效操作期间，保护页缓存内容与文件偏移-&gt;磁盘块映射之间的一致性。它还用于阻止通过内存映射修改页缓存内容。</span></a>
<a class="sourceLine" id="cb14-6" title="6">        gfp_t                   gfp_mask;         <span class="co">// 用于分配页面的内存分配标志。</span></a>
<a class="sourceLine" id="cb14-7" title="7">        atomic_t                i_mmap_writable;  <span class="co">// VM_SHARED 映射的数量。</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="pp">#ifdef CONFIG_READ_ONLY_THP_FOR_FS</span></a>
<a class="sourceLine" id="cb14-9" title="9">        <span class="co">/* thp 的数量，仅用于非 shmem 文件 */</span></a>
<a class="sourceLine" id="cb14-10" title="10">        atomic_t                nr_thps;        <span class="co">// 页缓存中的 THP（非共享内存）数量。</span></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb14-12" title="12">        <span class="kw">struct</span> rb_root_cached   i_mmap;         <span class="co">// 私有和共享映射的树。</span></a>
<a class="sourceLine" id="cb14-13" title="13">        <span class="dt">unsigned</span> <span class="dt">long</span>           nrpages;        <span class="co">// 页条目的数量，由 i_pages 锁保护。</span></a>
<a class="sourceLine" id="cb14-14" title="14">        pgoff_t                 writeback_index;<span class="co">// 写回从这里开始。</span></a>
<a class="sourceLine" id="cb14-15" title="15">        <span class="dt">const</span> <span class="kw">struct</span> address_space_operations *a_ops; <span class="co">// 方法。</span></a>
<a class="sourceLine" id="cb14-16" title="16">        <span class="dt">unsigned</span> <span class="dt">long</span>           flags;          <span class="co">// 错误位和标志（AS_*）。</span></a>
<a class="sourceLine" id="cb14-17" title="17">        <span class="kw">struct</span> rw_semaphore     i_mmap_rwsem;   <span class="co">// 保护 @i_mmap 和 @i_mmap_writable</span></a>
<a class="sourceLine" id="cb14-18" title="18">        errseq_t                wb_err;         <span class="co">// 最近发生的错误。</span></a>
<a class="sourceLine" id="cb14-19" title="19">        spinlock_t              private_lock;   <span class="co">// 供 address_space 的拥有者使用。</span></a>
<a class="sourceLine" id="cb14-20" title="20">        <span class="kw">struct</span> list_head        private_list;   <span class="co">// 供 address_space 的拥有者使用。</span></a>
<a class="sourceLine" id="cb14-21" title="21">        <span class="dt">void</span>                    *private_data;  <span class="co">// 供 address_space 的拥有者使用。</span></a>
<a class="sourceLine" id="cb14-22" title="22">} __attribute__((aligned(<span class="kw">sizeof</span>(<span class="dt">long</span>)))) __randomize_layout;</a></code></pre></div>
<p>地址空间操作:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">struct</span> address_space_operations {</a>
<a class="sourceLine" id="cb15-2" title="2">        <span class="dt">int</span> (*writepage)(<span class="kw">struct</span> page *page, <span class="kw">struct</span> writeback_control *wbc); <span class="co">// 将文件在内存page中的更新到磁盘上</span></a>
<a class="sourceLine" id="cb15-3" title="3">        <span class="dt">int</span> (*read_folio)(<span class="kw">struct</span> file *, <span class="kw">struct</span> folio *); <span class="co">// 从磁盘上读取文件的数据到内存page中</span></a>
<a class="sourceLine" id="cb15-4" title="4"></a>
<a class="sourceLine" id="cb15-5" title="5">        <span class="co">/* 从此映射中回写一些脏页。 */</span></a>
<a class="sourceLine" id="cb15-6" title="6">        <span class="dt">int</span> (*writepages)(<span class="kw">struct</span> address_space *, <span class="kw">struct</span> writeback_control *); <span class="co">// 将多个page更新到磁盘上</span></a>
<a class="sourceLine" id="cb15-7" title="7"></a>
<a class="sourceLine" id="cb15-8" title="8">        <span class="co">/* 标记一个 folio 为脏页。如果此操作使其变脏，则返回 true */</span></a>
<a class="sourceLine" id="cb15-9" title="9">        <span class="dt">bool</span> (*dirty_folio)(<span class="kw">struct</span> address_space *, <span class="kw">struct</span> folio *);</a>
<a class="sourceLine" id="cb15-10" title="10"></a>
<a class="sourceLine" id="cb15-11" title="11">        <span class="dt">void</span> (*readahead)(<span class="kw">struct</span> readahead_control *);</a>
<a class="sourceLine" id="cb15-12" title="12"></a>
<a class="sourceLine" id="cb15-13" title="13">        <span class="dt">int</span> (*write_begin)(<span class="kw">struct</span> file *, <span class="kw">struct</span> address_space *mapping, <span class="co">// 要求具体文件系统准备将数据写到文件</span></a>
<a class="sourceLine" id="cb15-14" title="14">                                loff_t pos, <span class="dt">unsigned</span> len,</a>
<a class="sourceLine" id="cb15-15" title="15">                                <span class="kw">struct</span> page **pagep, <span class="dt">void</span> **fsdata);</a>
<a class="sourceLine" id="cb15-16" title="16">        <span class="dt">int</span> (*write_end)(<span class="kw">struct</span> file *, <span class="kw">struct</span> address_space *mapping,   <span class="co">// 完成数据复制之后调用，具体文件系统 unlock page，释放引用计数，更新 i_size</span></a>
<a class="sourceLine" id="cb15-17" title="17">                                loff_t pos, <span class="dt">unsigned</span> len, <span class="dt">unsigned</span> copied,</a>
<a class="sourceLine" id="cb15-18" title="18">                                <span class="kw">struct</span> page *page, <span class="dt">void</span> *fsdata);</a>
<a class="sourceLine" id="cb15-19" title="19"></a>
<a class="sourceLine" id="cb15-20" title="20">        <span class="co">/* 不幸的是，FIBMAP 需要这个权宜之计。不要使用它 */</span></a>
<a class="sourceLine" id="cb15-21" title="21">        sector_t (*bmap)(<span class="kw">struct</span> address_space *, sector_t); <span class="co">// 将文件中的逻辑块扇区编号映射为对应设备上的物理块扇区编号</span></a>
<a class="sourceLine" id="cb15-22" title="22">        <span class="dt">void</span> (*invalidate_folio) (<span class="kw">struct</span> folio *, <span class="dt">size_t</span> offset, <span class="dt">size_t</span> len); <span class="co">// 使某个page部分或全部失效</span></a>
<a class="sourceLine" id="cb15-23" title="23">        <span class="dt">bool</span> (*release_folio)(<span class="kw">struct</span> folio *, gfp_t); <span class="co">// 日志文件系统使用，释放page</span></a>
<a class="sourceLine" id="cb15-24" title="24">        <span class="dt">void</span> (*free_folio)(<span class="kw">struct</span> folio *folio);</a>
<a class="sourceLine" id="cb15-25" title="25">        <span class="dt">ssize_t</span> (*direct_IO)(<span class="kw">struct</span> kiocb *, <span class="kw">struct</span> iov_iter *iter); <span class="co">// 绕过page cache</span></a>
<a class="sourceLine" id="cb15-26" title="26">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb15-27" title="27"><span class="co">         * 将folio的内容移动到指定的目标，如果migrate_mode是MIGRATE_ASYNC，就不阻塞（异步）</span></a>
<a class="sourceLine" id="cb15-28" title="28"><span class="co">         */</span></a>
<a class="sourceLine" id="cb15-29" title="29">        <span class="dt">int</span> (*migrate_folio)(<span class="kw">struct</span> address_space *, <span class="kw">struct</span> folio *dst,</a>
<a class="sourceLine" id="cb15-30" title="30">                        <span class="kw">struct</span> folio *src, <span class="kw">enum</span> migrate_mode);</a>
<a class="sourceLine" id="cb15-31" title="31">        <span class="dt">int</span> (*launder_folio)(<span class="kw">struct</span> folio *); <span class="co">// 释放一个folio之前调用，回写dirty的folio</span></a>
<a class="sourceLine" id="cb15-32" title="32">        <span class="dt">bool</span> (*is_partially_uptodate) (<span class="kw">struct</span> folio *, <span class="dt">size_t</span> from, <span class="co">// 判断是否最新</span></a>
<a class="sourceLine" id="cb15-33" title="33">                        <span class="dt">size_t</span> count);</a>
<a class="sourceLine" id="cb15-34" title="34">        <span class="dt">void</span> (*is_dirty_writeback) (<span class="kw">struct</span> folio *, <span class="dt">bool</span> *dirty, <span class="dt">bool</span> *wb);</a>
<a class="sourceLine" id="cb15-35" title="35">        <span class="dt">int</span> (*error_remove_page)(<span class="kw">struct</span> address_space *, <span class="kw">struct</span> page *); <span class="co">// 被内存故障处理代码使用</span></a>
<a class="sourceLine" id="cb15-36" title="36"></a>
<a class="sourceLine" id="cb15-37" title="37">        <span class="co">/* swapfile support */</span></a>
<a class="sourceLine" id="cb15-38" title="38">        <span class="dt">int</span> (*swap_activate)(<span class="kw">struct</span> swap_info_struct *sis, <span class="kw">struct</span> file *file,</a>
<a class="sourceLine" id="cb15-39" title="39">                                sector_t *span);</a>
<a class="sourceLine" id="cb15-40" title="40">        <span class="dt">void</span> (*swap_deactivate)(<span class="kw">struct</span> file *file);</a>
<a class="sourceLine" id="cb15-41" title="41">        <span class="dt">int</span> (*swap_rw)(<span class="kw">struct</span> kiocb *iocb, <span class="kw">struct</span> iov_iter *iter);</a>
<a class="sourceLine" id="cb15-42" title="42">};</a></code></pre></div>
<h2 id="其他数据结构"><span class="header-section-number">2.10</span> 其他数据结构</h2>
<p><code>file_system_type</code>描述各种特定文件系统类型，每种文件系统只有一个<code>file_system_type</code>对象，具体文件系统如ext2模块加载时调用<code>init_ext2_fs() -&gt; register_filesystem()</code>注册。根文件系统类型<code>rootfs_fs_type</code>。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">struct</span> file_system_type {</a>
<a class="sourceLine" id="cb16-2" title="2">        <span class="dt">const</span> <span class="dt">char</span> *name; <span class="co">// 名字</span></a>
<a class="sourceLine" id="cb16-3" title="3">        <span class="dt">int</span> fs_flags; <span class="co">// 类型标志</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="pp">#define FS_REQUIRES_DEV         1 </span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="pp">#define FS_BINARY_MOUNTDATA     2</span></a>
<a class="sourceLine" id="cb16-6" title="6"><span class="pp">#define FS_HAS_SUBTYPE          4</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="pp">#define FS_USERNS_MOUNT         8       </span><span class="co">/* 可以由用户命名空间根目录挂载 */</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="pp">#define FS_DISALLOW_NOTIFY_PERM 16      </span><span class="co">/* 禁用 fanotify 权限事件 */</span></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="pp">#define FS_ALLOW_IDMAP         32       </span><span class="co">/* 文件系统已更新以处理 vfs id 映射。 */</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="pp">#define FS_RENAME_DOES_D_MOVE   32768   </span><span class="co">/* 文件系统将在内部处理 rename() 时的 d_move()。 */</span></a>
<a class="sourceLine" id="cb16-11" title="11">        <span class="dt">int</span> (*init_fs_context)(<span class="kw">struct</span> fs_context *);</a>
<a class="sourceLine" id="cb16-12" title="12">        <span class="dt">const</span> <span class="kw">struct</span> fs_parameter_spec *parameters;</a>
<a class="sourceLine" id="cb16-13" title="13">        <span class="kw">struct</span> dentry *(*mount) (<span class="kw">struct</span> file_system_type *, <span class="dt">int</span>, <span class="co">// 从磁盘中读取超级块</span></a>
<a class="sourceLine" id="cb16-14" title="14">                       <span class="dt">const</span> <span class="dt">char</span> *, <span class="dt">void</span> *);</a>
<a class="sourceLine" id="cb16-15" title="15">        <span class="dt">void</span> (*kill_sb) (<span class="kw">struct</span> super_block *);   <span class="co">// 终止访问超级块</span></a>
<a class="sourceLine" id="cb16-16" title="16">        <span class="kw">struct</span> module *owner; <span class="co">// 文件系统模块</span></a>
<a class="sourceLine" id="cb16-17" title="17">        <span class="kw">struct</span> file_system_type * next; <span class="co">// 链表中下一个文件系统类型</span></a>
<a class="sourceLine" id="cb16-18" title="18">        <span class="kw">struct</span> hlist_head fs_supers;    <span class="co">// 超级块对象链表</span></a>
<a class="sourceLine" id="cb16-19" title="19"></a>
<a class="sourceLine" id="cb16-20" title="20">        <span class="co">// 运行时使锁生效</span></a>
<a class="sourceLine" id="cb16-21" title="21">        <span class="kw">struct</span> lock_class_key s_lock_key;</a>
<a class="sourceLine" id="cb16-22" title="22">        <span class="kw">struct</span> lock_class_key s_umount_key;</a>
<a class="sourceLine" id="cb16-23" title="23">        <span class="kw">struct</span> lock_class_key s_vfs_rename_key;</a>
<a class="sourceLine" id="cb16-24" title="24">        <span class="kw">struct</span> lock_class_key s_writers_key[SB_FREEZE_LEVELS];</a>
<a class="sourceLine" id="cb16-25" title="25"></a>
<a class="sourceLine" id="cb16-26" title="26">        <span class="kw">struct</span> lock_class_key i_lock_key;</a>
<a class="sourceLine" id="cb16-27" title="27">        <span class="kw">struct</span> lock_class_key i_mutex_key;</a>
<a class="sourceLine" id="cb16-28" title="28">        <span class="kw">struct</span> lock_class_key invalidate_lock_key;</a>
<a class="sourceLine" id="cb16-29" title="29">        <span class="kw">struct</span> lock_class_key i_mutex_dir_key;</a>
<a class="sourceLine" id="cb16-30" title="30">};</a></code></pre></div>
<p>文件系统挂载时，有一个<code>mount</code>结构体在挂载点被创建，代表文件系统实例，也就是代表一个挂载点。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">struct</span> mount {</a>
<a class="sourceLine" id="cb17-2" title="2">        <span class="kw">struct</span> hlist_node mnt_hash;     <span class="co">// 散列表</span></a>
<a class="sourceLine" id="cb17-3" title="3">        <span class="kw">struct</span> mount *mnt_parent;       <span class="co">// 父文件系统</span></a>
<a class="sourceLine" id="cb17-4" title="4">        <span class="kw">struct</span> dentry *mnt_mountpoint;  <span class="co">// 挂载点的目录项</span></a>
<a class="sourceLine" id="cb17-5" title="5">        <span class="kw">struct</span> vfsmount mnt;</a>
<a class="sourceLine" id="cb17-6" title="6">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb17-7" title="7">                <span class="kw">struct</span> rcu_head mnt_rcu;</a>
<a class="sourceLine" id="cb17-8" title="8">                <span class="kw">struct</span> llist_node mnt_llist;</a>
<a class="sourceLine" id="cb17-9" title="9">        };</a>
<a class="sourceLine" id="cb17-10" title="10"><span class="pp">#ifdef CONFIG_SMP</span></a>
<a class="sourceLine" id="cb17-11" title="11">        <span class="kw">struct</span> mnt_pcp __percpu *mnt_pcp;</a>
<a class="sourceLine" id="cb17-12" title="12"><span class="pp">#else</span></a>
<a class="sourceLine" id="cb17-13" title="13">        <span class="dt">int</span> mnt_count;   <span class="co">// 引用计数</span></a>
<a class="sourceLine" id="cb17-14" title="14">        <span class="dt">int</span> mnt_writers; <span class="co">// 写者引用计数</span></a>
<a class="sourceLine" id="cb17-15" title="15"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb17-16" title="16">        <span class="kw">struct</span> list_head mnt_mounts;    <span class="co">/* 子文件系统链表, 固定在此 */</span></a>
<a class="sourceLine" id="cb17-17" title="17">        <span class="kw">struct</span> list_head mnt_child;     <span class="co">/* 子文件系统链表 */</span></a>
<a class="sourceLine" id="cb17-18" title="18">        <span class="kw">struct</span> list_head mnt_instance;  <span class="co">/* sb-&gt;s_mounts 上的挂载实例 */</span></a>
<a class="sourceLine" id="cb17-19" title="19">        <span class="dt">const</span> <span class="dt">char</span> *mnt_devname;        <span class="co">/* 设备名称，例如 /dev/dsk/hda1 */</span></a>
<a class="sourceLine" id="cb17-20" title="20">        <span class="kw">struct</span> list_head mnt_list;      <span class="co">// 描述符链表</span></a>
<a class="sourceLine" id="cb17-21" title="21">        <span class="kw">struct</span> list_head mnt_expire;    <span class="co">/* 在到期链表的位置 */</span></a>
<a class="sourceLine" id="cb17-22" title="22">        <span class="kw">struct</span> list_head mnt_share;     <span class="co">/* 在共享安装链表的位置 */</span></a>
<a class="sourceLine" id="cb17-23" title="23">        <span class="kw">struct</span> list_head mnt_slave_list;<span class="co">/* 从安装链表 */</span></a>
<a class="sourceLine" id="cb17-24" title="24">        <span class="kw">struct</span> list_head mnt_slave;     <span class="co">/* 在从安装链表的位置 */</span></a>
<a class="sourceLine" id="cb17-25" title="25">        <span class="kw">struct</span> mount *mnt_master;       <span class="co">/* 从安装链表的主人 */</span></a>
<a class="sourceLine" id="cb17-26" title="26">        <span class="kw">struct</span> mnt_namespace *mnt_ns;   <span class="co">/* 相关的命名空间 */</span></a>
<a class="sourceLine" id="cb17-27" title="27">        <span class="kw">struct</span> mountpoint *mnt_mp;      <span class="co">/* 挂载的位置 */</span></a>
<a class="sourceLine" id="cb17-28" title="28">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb17-29" title="29">                <span class="kw">struct</span> hlist_node mnt_mp_list;  <span class="co">/* 具有相同挂载点的挂载链表 */</span></a>
<a class="sourceLine" id="cb17-30" title="30">                <span class="kw">struct</span> hlist_node mnt_umount;</a>
<a class="sourceLine" id="cb17-31" title="31">        };</a>
<a class="sourceLine" id="cb17-32" title="32">        <span class="kw">struct</span> list_head mnt_umounting; <span class="co">/* 用于卸载传播的列表条目 */</span></a>
<a class="sourceLine" id="cb17-33" title="33"><span class="pp">#ifdef CONFIG_FSNOTIFY</span></a>
<a class="sourceLine" id="cb17-34" title="34">        <span class="kw">struct</span> fsnotify_mark_connector __rcu *mnt_fsnotify_marks;</a>
<a class="sourceLine" id="cb17-35" title="35">        __u32 mnt_fsnotify_mask;</a>
<a class="sourceLine" id="cb17-36" title="36"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb17-37" title="37">        <span class="dt">int</span> mnt_id;                     <span class="co">/* 安装标识符 */</span></a>
<a class="sourceLine" id="cb17-38" title="38">        <span class="dt">int</span> mnt_group_id;               <span class="co">/* 组标识符 */</span></a>
<a class="sourceLine" id="cb17-39" title="39">        <span class="dt">int</span> mnt_expiry_mark;            <span class="co">/* 到期时为1 */</span></a>
<a class="sourceLine" id="cb17-40" title="40">        <span class="kw">struct</span> hlist_head mnt_pins;</a>
<a class="sourceLine" id="cb17-41" title="41">        <span class="kw">struct</span> hlist_head mnt_stuck_children;</a>
<a class="sourceLine" id="cb17-42" title="42">} __randomize_layout;</a>
<a class="sourceLine" id="cb17-43" title="43"></a>
<a class="sourceLine" id="cb17-44" title="44"><span class="kw">struct</span> vfsmount {</a>
<a class="sourceLine" id="cb17-45" title="45">        <span class="kw">struct</span> dentry *mnt_root;        <span class="co">/* 该文件系统的根目录项 */</span></a>
<a class="sourceLine" id="cb17-46" title="46">        <span class="kw">struct</span> super_block *mnt_sb;     <span class="co">/* 超级块 */</span></a>
<a class="sourceLine" id="cb17-47" title="47">        <span class="dt">int</span> mnt_flags;                  <span class="co">// 挂载标志, MNT_NOSUID 等</span></a>
<a class="sourceLine" id="cb17-48" title="48">        <span class="kw">struct</span> mnt_idmap *mnt_idmap;</a>
<a class="sourceLine" id="cb17-49" title="49">} __randomize_layout;</a></code></pre></div>
<p><code>files_struct</code>描述单个进程相关的信息，<code>struct task_struct</code>中的<code>files</code>成员指向它。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="co"> * /* 打开的文件表结构 */</span></a>
<a class="sourceLine" id="cb18-3" title="3"> */</a>
<a class="sourceLine" id="cb18-4" title="4"><span class="kw">struct</span> files_struct {</a>
<a class="sourceLine" id="cb18-5" title="5">  <span class="co">/*</span></a>
<a class="sourceLine" id="cb18-6" title="6"><span class="co">   * 主要用于读取的部分</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="co">   */</span></a>
<a class="sourceLine" id="cb18-8" title="8">        atomic_t count;             <span class="co">// 引用计数</span></a>
<a class="sourceLine" id="cb18-9" title="9">        <span class="dt">bool</span> resize_in_progress;</a>
<a class="sourceLine" id="cb18-10" title="10">        wait_queue_head_t resize_wait;</a>
<a class="sourceLine" id="cb18-11" title="11"></a>
<a class="sourceLine" id="cb18-12" title="12">        <span class="kw">struct</span> fdtable __rcu *fdt;  <span class="co">// 如果打开的文件数大于NR_OPEN_DEFAULT，分配一个新数组</span></a>
<a class="sourceLine" id="cb18-13" title="13">        <span class="kw">struct</span> fdtable fdtab;       <span class="co">// 基fd表</span></a>
<a class="sourceLine" id="cb18-14" title="14">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb18-15" title="15"><span class="co">        * 在 SMP 中，写入部分位于单独的缓存行</span></a>
<a class="sourceLine" id="cb18-16" title="16"><span class="co">        */</span></a>
<a class="sourceLine" id="cb18-17" title="17">        spinlock_t file_lock ____cacheline_aligned_in_smp;  <span class="co">// 单个文件的锁</span></a>
<a class="sourceLine" id="cb18-18" title="18">        <span class="dt">unsigned</span> <span class="dt">int</span> next_fd;                               <span class="co">// 缓存下一个可用的fd</span></a>
<a class="sourceLine" id="cb18-19" title="19">        <span class="dt">unsigned</span> <span class="dt">long</span> close_on_exec_init[<span class="dv">1</span>];                <span class="co">// exec()时关闭的fd链表</span></a>
<a class="sourceLine" id="cb18-20" title="20">        <span class="dt">unsigned</span> <span class="dt">long</span> open_fds_init[<span class="dv">1</span>];                     <span class="co">// 打开的fd链表</span></a>
<a class="sourceLine" id="cb18-21" title="21">        <span class="dt">unsigned</span> <span class="dt">long</span> full_fds_bits_init[<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb18-22" title="22">        <span class="kw">struct</span> file __rcu * fd_array[NR_OPEN_DEFAULT];      <span class="co">// 默认的文件对象数组</span></a>
<a class="sourceLine" id="cb18-23" title="23">};</a></code></pre></div>
<p><code>fs_struct</code>表示文件系统进程相关的信息，<code>struct task_struct</code>中的<code>fs</code>成员指向它。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">struct</span> fs_struct {</a>
<a class="sourceLine" id="cb19-2" title="2">        <span class="dt">int</span> users;              <span class="co">// 用户数目</span></a>
<a class="sourceLine" id="cb19-3" title="3">        spinlock_t lock;        <span class="co">// 保护该结构体的锁</span></a>
<a class="sourceLine" id="cb19-4" title="4">        seqcount_spinlock_t seq;</a>
<a class="sourceLine" id="cb19-5" title="5">        <span class="dt">int</span> umask;              <span class="co">// 掩码</span></a>
<a class="sourceLine" id="cb19-6" title="6">        <span class="dt">int</span> in_exec;            <span class="co">// 当前正在执行的文件</span></a>
<a class="sourceLine" id="cb19-7" title="7">        <span class="kw">struct</span> path root;       <span class="co">// 根目录路径</span></a>
<a class="sourceLine" id="cb19-8" title="8">        <span class="kw">struct</span> path pwd;        <span class="co">// 当前工作目录的路径</span></a>
<a class="sourceLine" id="cb19-9" title="9">} __randomize_layout;</a></code></pre></div>
<p><code>mnt_namespace</code>表示单进程命名空间，<code>struct task_struct</code>中的<code>nsproxy-&gt;mnt_namespace</code>成员指向它。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">struct</span> mnt_namespace {</a>
<a class="sourceLine" id="cb20-2" title="2">        <span class="kw">struct</span> ns_common        ns;</a>
<a class="sourceLine" id="cb20-3" title="3">        <span class="kw">struct</span> mount *  root; <span class="co">// 根目录的挂载点</span></a>
<a class="sourceLine" id="cb20-4" title="4">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="co">         * 对 .list 的遍历和修改受以下任意一种方式保护:</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="co">         * - 获取 namespace_sem 的写锁，或</span></a>
<a class="sourceLine" id="cb20-7" title="7"><span class="co">         * - 获取 namespace_sem 的读锁并获取 .ns_lock</span></a>
<a class="sourceLine" id="cb20-8" title="8"><span class="co">         */</span></a>
<a class="sourceLine" id="cb20-9" title="9">        <span class="kw">struct</span> list_head        list; <span class="co">// 挂载点链表</span></a>
<a class="sourceLine" id="cb20-10" title="10">        spinlock_t              ns_lock;</a>
<a class="sourceLine" id="cb20-11" title="11">        <span class="kw">struct</span> user_namespace   *user_ns;</a>
<a class="sourceLine" id="cb20-12" title="12">        <span class="kw">struct</span> ucounts          *ucounts; <span class="co">// 用户计数</span></a>
<a class="sourceLine" id="cb20-13" title="13">        u64                     seq;    <span class="co">/* 防止循环的序列号 */</span></a>
<a class="sourceLine" id="cb20-14" title="14">        wait_queue_head_t poll; <span class="co">// 轮询的等待队列</span></a>
<a class="sourceLine" id="cb20-15" title="15">        u64 event; <span class="co">// 事件计数</span></a>
<a class="sourceLine" id="cb20-16" title="16">        <span class="dt">unsigned</span> <span class="dt">int</span>            mounts; <span class="co">/* 命名空间中的挂载数量 */</span></a>
<a class="sourceLine" id="cb20-17" title="17">        <span class="dt">unsigned</span> <span class="dt">int</span>            pending_mounts;</a>
<a class="sourceLine" id="cb20-18" title="18">} __randomize_layout;</a>
<a class="sourceLine" id="cb20-19" title="19"></a>
<a class="sourceLine" id="cb20-20" title="20"><span class="kw">struct</span> ucounts {</a>
<a class="sourceLine" id="cb20-21" title="21">        <span class="kw">struct</span> hlist_node node;</a>
<a class="sourceLine" id="cb20-22" title="22">        <span class="kw">struct</span> user_namespace *ns;</a>
<a class="sourceLine" id="cb20-23" title="23">        kuid_t uid;</a>
<a class="sourceLine" id="cb20-24" title="24">        atomic_t count; <span class="co">// 引用计数</span></a>
<a class="sourceLine" id="cb20-25" title="25">        atomic_long_t ucount[UCOUNT_COUNTS];</a>
<a class="sourceLine" id="cb20-26" title="26">        atomic_long_t rlimit[UCOUNT_RLIMIT_COUNTS];</a>
<a class="sourceLine" id="cb20-27" title="27">};</a></code></pre></div>
<p>还有文件锁的数据结构为<code>struct file_lock</code>。</p>
<h2 id="举几个例子"><span class="header-section-number">2.11</span> 举几个例子</h2>
<h3 id="inode的i_nlink"><span class="header-section-number">2.11.1</span> <code>inode</code>的<code>i_nlink</code></h3>
<p>调试补丁为 <a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/0001-debug-vfs.patch"><code>0001-debug-vfs.patch</code></a> ，看其中的<code>debug_inode_nlink()</code>函数。</p>
<p>在ext2文件系统下测试:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb21-1" title="1"><span class="ex">fallocate</span> -l 100M image</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="ex">mkfs.ext2</span> -F image</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="fu">mount</span> -t ext2 image /mnt</a>
<a class="sourceLine" id="cb21-4" title="4"><span class="bu">cd</span> /mnt</a>
<a class="sourceLine" id="cb21-5" title="5"><span class="bu">echo</span> <span class="st">&quot;i love os&quot;</span> <span class="op">&gt;</span> file</a>
<a class="sourceLine" id="cb21-6" title="6"><span class="fu">cat</span> file <span class="co"># 这时文件的i_nlink为1，只有一个dentry</span></a>
<a class="sourceLine" id="cb21-7" title="7"><span class="fu">ln</span> file link <span class="co"># 创建硬链接i_nlink加1</span></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="fu">cat</span> file <span class="co"># 这时文件的i_nlink为2，有两个dentry</span></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="fu">ln</span> -s file slink <span class="co"># 创建软链接i_nlink不变</span></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="fu">cat</span> file <span class="co"># 这时文件的i_nlink不变还是为2</span></a>
<a class="sourceLine" id="cb21-11" title="11"><span class="fu">ls</span> <span class="co"># 这时目录的i_nlink为3</span></a>
<a class="sourceLine" id="cb21-12" title="12"><span class="fu">mkdir</span> dir <span class="co"># 只有创建文件夹i_nlink才会增加，创建文件不会</span></a>
<a class="sourceLine" id="cb21-13" title="13"><span class="fu">ls</span> <span class="co"># 这时目录的i_nlink为4</span></a></code></pre></div>
<p>对文件创建硬链接时<code>ln file link</code>，增加<code>inode-&gt;i_nlink</code>的流程如下:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1">linkat <span class="co">// 系统调用</span></a>
<a class="sourceLine" id="cb22-2" title="2">  do_linkat</a>
<a class="sourceLine" id="cb22-3" title="3">    vfs_link</a>
<a class="sourceLine" id="cb22-4" title="4">      ext2_link <span class="co">// ext2_dir_inode_operations的.link方法</span></a>
<a class="sourceLine" id="cb22-5" title="5">        inode_inc_link_count</a>
<a class="sourceLine" id="cb22-6" title="6">          inc_nlink</a>
<a class="sourceLine" id="cb22-7" title="7">            inode-&gt;__i_nlink++</a></code></pre></div>
<p>不能对目录创建硬链接。在目录<code>dir1</code>下创建<code>dir2</code>文件夹，父目录<code>dir1</code>的<code>inode-&gt;i_nlink</code>增加的流程如下:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1">mkdir <span class="co">// 系统调用</span></a>
<a class="sourceLine" id="cb23-2" title="2">  do_mkdirat</a>
<a class="sourceLine" id="cb23-3" title="3">    vfs_mkdir</a>
<a class="sourceLine" id="cb23-4" title="4">      ext2_mkdir <span class="co">// ext2_dir_inode_operations 的.mkdir方法</span></a>
<a class="sourceLine" id="cb23-5" title="5">        inode_inc_link_count</a>
<a class="sourceLine" id="cb23-6" title="6">          inc_nlink</a>
<a class="sourceLine" id="cb23-7" title="7">            inode-&gt;__i_nlink++</a></code></pre></div>
<h3 id="super_block的s_mounts"><span class="header-section-number">2.11.2</span> <code>super_block</code>的<code>s_mounts</code></h3>
<p>调试补丁为 <a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/0001-debug-vfs.patch"><code>0001-debug-vfs.patch</code></a> ，看其中的<code>debug_sb_mounts()</code>函数。</p>
<p>每个挂载路径下有3个<code>struct mount</code>，分别是一次调用<code>vfs_create_mount()</code>和两次调用<code>clone_mnt()</code>创建的:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1">mount</a>
<a class="sourceLine" id="cb24-2" title="2">  do_mount</a>
<a class="sourceLine" id="cb24-3" title="3">    path_mount</a>
<a class="sourceLine" id="cb24-4" title="4">      do_new_mount</a>
<a class="sourceLine" id="cb24-5" title="5">        do_new_mount_fc</a>
<a class="sourceLine" id="cb24-6" title="6">          vfs_create_mount</a>
<a class="sourceLine" id="cb24-7" title="7">            list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;mnt-&gt;mnt.mnt_sb-&gt;s_mounts)</a>
<a class="sourceLine" id="cb24-8" title="8">          do_add_mount</a>
<a class="sourceLine" id="cb24-9" title="9">            graft_tree</a>
<a class="sourceLine" id="cb24-10" title="10">              attach_recursive_mnt</a>
<a class="sourceLine" id="cb24-11" title="11">                propagate_mnt</a>
<a class="sourceLine" id="cb24-12" title="12">                  propagate_one</a>
<a class="sourceLine" id="cb24-13" title="13">                    copy_tree</a>
<a class="sourceLine" id="cb24-14" title="14">                      clone_mnt <span class="co">// 调用了两次</span></a>
<a class="sourceLine" id="cb24-15" title="15">                        list_add_tail(&amp;mnt-&gt;mnt_instance, &amp;sb-&gt;s_mounts)</a></code></pre></div>
<h3 id="通过inode得到完整路径"><span class="header-section-number">2.11.3</span> 通过<code>inode</code>得到完整路径</h3>
<p>调试补丁为 <a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/0001-debug-vfs.patch"><code>0001-debug-vfs.patch</code></a> ，看其中的<code>debug_get_full_path()</code>函数。</p>
<h1 id="ext2文件系统"><span class="header-section-number">3</span> ext2文件系统</h1>
<p>英文全称Extended file system，翻译为扩展文件系统。Linux内核最开始用的是minix文件系统，直到1992年4月，Rémy Card开发了ext文件系统，采用Unix文件系统（UFS）的元数据结构，在linux内核0.96c版中引入。设计上参考了BSD的快速文件系统（Fast File System，简称FFS）。1993年1月0.99版本中ext2合入内核， 2001年11月2.4.15版本中ext3合入内核，2006年10月10日2.6.19版本中ext4合入内核。</p>
<p>相关文档网站:</p>
<ul>
<li><a href="https://www.kernel.org/doc/html/latest/filesystems/ext2.html">内核仓库ext2文档</a></li>
<li><a href="https://ext4.wiki.kernel.org/index.php/Main_Page">ext4 wiki</a></li>
</ul>
<h2 id="磁盘数据结构"><span class="header-section-number">3.1</span> 磁盘数据结构</h2>
<h3 id="块组"><span class="header-section-number">3.1.1</span> 块组</h3>
<p>块组（block group）的内容如下:</p>
<table>
<thead>
<tr class="header">
<th>超级块</th>
<th>组描<br>述符</th>
<th>数据块位图</th>
<th>inode<br>位图</th>
<th>inode表</th>
<th>数据块</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1个块</td>
<td>k个块</td>
<td>1个块</td>
<td>1个块</td>
<td>n个块</td>
<td>m个块</td>
</tr>
</tbody>
</table>
<p>启动扇区和块组:</p>
<table>
<thead>
<tr class="header">
<th>启动块</th>
<th>块组0</th>
<th>块组1</th>
<th>…</th>
<th>块组n</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>对于超级块的存储，ext2的采用了稀疏超级块（sparse superblock）技术，超级块只存储到块组0、块组1和其他ID可以表示为3、5、7的幂的块组中，也就是0、1、3、5、7、9、25、49…</p>
<p>块组中内容的解释:</p>
<ul>
<li>超级块: 存储文件系统自身元数据</li>
<li>组描述符: 包含所有块组的状态</li>
<li>数据块位图: 每个bit表示对应的数据块是否空闲，1表示占用，0表示空闲</li>
<li>inode位图: 每个bit表示对应的inode是否空闲</li>
<li>inode表: 块组中的inode</li>
<li>数据块: 文件的有用数据</li>
</ul>
<p>举个例子，<code>32GB</code>的磁盘整个盘格式化为ext2文件系统，块大小为<code>4KB</code>，1个块大小的数据块位图描述<code>8*4K=32K</code>个数据块，也就是<code>32K*4KB=128MB</code>，大约有<code>32*1024MB/128MB=256</code>个块组。总块数为<code>total</code>，块大小为<code>bsize</code>字节，块组的总数约为<code>total/(8*bsize)</code>，套到上面的例子，就是<code>total=32*1024MB/4KB=8192K</code>，块组的总数约为<code>8192K/(8*4K)=256</code>个。<code>bsize</code>越小，块组数越大。</p>
<h3 id="超级块"><span class="header-section-number">3.1.2</span> 超级块</h3>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">struct</span> ext2_super_block {</a>
<a class="sourceLine" id="cb25-2" title="2">        __le32  s_inodes_count;         <span class="co">/* 索引节点总数 */</span></a>
<a class="sourceLine" id="cb25-3" title="3">        __le32  s_blocks_count;         <span class="co">/* 块总数 */</span></a>
<a class="sourceLine" id="cb25-4" title="4">        __le32  s_r_blocks_count;       <span class="co">/* 保留的块数 */</span></a>
<a class="sourceLine" id="cb25-5" title="5">        __le32  s_free_blocks_count;    <span class="co">/* 空闲块计数器 */</span></a>
<a class="sourceLine" id="cb25-6" title="6">        __le32  s_free_inodes_count;    <span class="co">/* 空闲索引节点计数器 */</span></a>
<a class="sourceLine" id="cb25-7" title="7">        __le32  s_first_data_block;     <span class="co">/* 第一个数据块的块号，总是为1 */</span></a>
<a class="sourceLine" id="cb25-8" title="8">        <span class="co">// 最小 EXT2_MIN_BLOCK_SIZE，最大 EXT2_MAX_BLOCK_SIZE</span></a>
<a class="sourceLine" id="cb25-9" title="9">        __le32  s_log_block_size;       <span class="co">/* 块大小，对数表示，值为0时表示2^0*1024=1024，值为1时表示2^1*1024=2048,值为2时表示2^2*1024=4096 */</span></a>
<a class="sourceLine" id="cb25-10" title="10">        __le32  s_log_frag_size;        <span class="co">/* 片大小 */</span></a>
<a class="sourceLine" id="cb25-11" title="11">        __le32  s_blocks_per_group;     <span class="co">/* 每组中的块数 */</span></a>
<a class="sourceLine" id="cb25-12" title="12">        __le32  s_frags_per_group;      <span class="co">/* 每组中的片数 */</span></a>
<a class="sourceLine" id="cb25-13" title="13">        __le32  s_inodes_per_group;     <span class="co">/* 每组中的索引节点数 */</span></a>
<a class="sourceLine" id="cb25-14" title="14">        __le32  s_mtime;                <span class="co">/* 最后一次挂载时间 */</span></a>
<a class="sourceLine" id="cb25-15" title="15">        __le32  s_wtime;                <span class="co">/* 写时间 */</span></a>
<a class="sourceLine" id="cb25-16" title="16">        __le16  s_mnt_count;            <span class="co">/* 挂载次数 */</span></a>
<a class="sourceLine" id="cb25-17" title="17">        __le16  s_max_mnt_count;        <span class="co">/* 检查之前挂载操作的次数，挂载次数达到这个值后要进行检查 */</span></a>
<a class="sourceLine" id="cb25-18" title="18">        __le16  s_magic;                <span class="co">/* 幻数，EXT2_SUPER_MAGIC */</span></a>
<a class="sourceLine" id="cb25-19" title="19">        __le16  s_state;                <span class="co">/* 状态标志,挂载时为0，正常卸载为1(EXT2_VALID_FS)，错误为2(EXT2_ERROR_FS) */</span></a>
<a class="sourceLine" id="cb25-20" title="20">        __le16  s_errors;               <span class="co">/* 检测到错误的行为 */</span></a>
<a class="sourceLine" id="cb25-21" title="21">        __le16  s_minor_rev_level;      <span class="co">/* 次版本号 */</span></a>
<a class="sourceLine" id="cb25-22" title="22">        __le32  s_lastcheck;            <span class="co">/* 最后检查的时间 */</span></a>
<a class="sourceLine" id="cb25-23" title="23">        __le32  s_checkinterval;        <span class="co">/* 检查间隔 */</span></a>
<a class="sourceLine" id="cb25-24" title="24">        __le32  s_creator_os;           <span class="co">/* 在什么操作系统上格式化的 */</span></a>
<a class="sourceLine" id="cb25-25" title="25">        __le32  s_rev_level;            <span class="co">/* Revision level，主版本号 */</span></a>
<a class="sourceLine" id="cb25-26" title="26">        __le16  s_def_resuid;           <span class="co">/* 保留块的默认uid */</span></a>
<a class="sourceLine" id="cb25-27" title="27">        __le16  s_def_resgid;           <span class="co">/* 保留块默认gid */</span></a>
<a class="sourceLine" id="cb25-28" title="28">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb25-29" title="29"><span class="co">         * 这些字段仅适用于 EXT2_DYNAMIC_REV 超级块。</span></a>
<a class="sourceLine" id="cb25-30" title="30"><span class="co">         *</span></a>
<a class="sourceLine" id="cb25-31" title="31"><span class="co">         * 注意: 兼容功能集和不兼容功能集之间的区别在于，</span></a>
<a class="sourceLine" id="cb25-32" title="32"><span class="co">         * 如果内核不知道不兼容功能集中设置的位，</span></a>
<a class="sourceLine" id="cb25-33" title="33"><span class="co">         * 它应该拒绝挂载文件系统。</span></a>
<a class="sourceLine" id="cb25-34" title="34"><span class="co">         *</span></a>
<a class="sourceLine" id="cb25-35" title="35"><span class="co">         * e2fsck 的要求更加严格；如果它不知道</span></a>
<a class="sourceLine" id="cb25-36" title="36"><span class="co">         * 兼容或不兼容功能集中的某个功能，</span></a>
<a class="sourceLine" id="cb25-37" title="37"><span class="co">         * 它必须中止操作，而不是尝试处理</span></a>
<a class="sourceLine" id="cb25-38" title="38"><span class="co">         * 它不理解的东西...</span></a>
<a class="sourceLine" id="cb25-39" title="39"><span class="co">         */</span></a>
<a class="sourceLine" id="cb25-40" title="40">        __le32  s_first_ino;            <span class="co">/* 第一个非保留的索引节点号 */</span></a>
<a class="sourceLine" id="cb25-41" title="41">        __le16   s_inode_size;          <span class="co">/* 磁盘索引节点大小 */</span></a>
<a class="sourceLine" id="cb25-42" title="42">        __le16  s_block_group_nr;       <span class="co">/* 超级块块组号 */</span></a>
<a class="sourceLine" id="cb25-43" title="43">        __le32  s_feature_compat;       <span class="co">/* 兼容特性，查看 EXT2_FEATURE_COMPAT_DIR_PREALLOC 等宏定义 */</span></a>
<a class="sourceLine" id="cb25-44" title="44">        __le32  s_feature_incompat;     <span class="co">/* 非兼容特性 */</span></a>
<a class="sourceLine" id="cb25-45" title="45">        __le32  s_feature_ro_compat;    <span class="co">/* 只读兼容特性 */</span></a>
<a class="sourceLine" id="cb25-46" title="46">        __u8    s_uuid[<span class="dv">16</span>];             <span class="co">/* 卷的 128 位 uuid，文件系统标识符 */</span></a>
<a class="sourceLine" id="cb25-47" title="47">        <span class="dt">char</span>    s_volume_name[<span class="dv">16</span>];      <span class="co">/* 卷名 */</span></a>
<a class="sourceLine" id="cb25-48" title="48">        <span class="dt">char</span>    s_last_mounted[<span class="dv">64</span>];     <span class="co">/* 最后挂载点文件夹 */</span></a>
<a class="sourceLine" id="cb25-49" title="49">        __le32  s_algorithm_usage_bitmap; <span class="co">/* 压缩 */</span></a>
<a class="sourceLine" id="cb25-50" title="50">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb25-51" title="51"><span class="co">         * 性能提示。只有在 EXT2_COMPAT_PREALLOC 标志开启时，</span></a>
<a class="sourceLine" id="cb25-52" title="52"><span class="co">         * 才应进行目录预分配。</span></a>
<a class="sourceLine" id="cb25-53" title="53"><span class="co">         */</span></a>
<a class="sourceLine" id="cb25-54" title="54">        __u8    s_prealloc_blocks;      <span class="co">/* 预分配的块数 */</span></a>
<a class="sourceLine" id="cb25-55" title="55">        __u8    s_prealloc_dir_blocks;  <span class="co">/* 为目录预分配的块数 */</span></a>
<a class="sourceLine" id="cb25-56" title="56">        __u16   s_padding1; <span class="co">// 对齐用的</span></a>
<a class="sourceLine" id="cb25-57" title="57">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb25-58" title="58"><span class="co">         * 如果设置了 EXT3_FEATURE_COMPAT_HAS_JOURNAL，则启用日志支持。</span></a>
<a class="sourceLine" id="cb25-59" title="59"><span class="co">         */</span></a>
<a class="sourceLine" id="cb25-60" title="60">        __u8    s_journal_uuid[<span class="dv">16</span>];     <span class="co">/* 日志超级块的 uuid */</span></a>
<a class="sourceLine" id="cb25-61" title="61">        __u32   s_journal_inum;         <span class="co">/* 日志文件的 inode 编号 */</span></a>
<a class="sourceLine" id="cb25-62" title="62">        __u32   s_journal_dev;          <span class="co">/* 日志文件的设备编号 */</span></a>
<a class="sourceLine" id="cb25-63" title="63">        __u32   s_last_orphan;          <span class="co">/* 要删除的 inode 列表的起始位置 */</span></a>
<a class="sourceLine" id="cb25-64" title="64">        __u32   s_hash_seed[<span class="dv">4</span>];         <span class="co">/* HTREE 哈希种子 */</span></a>
<a class="sourceLine" id="cb25-65" title="65">        __u8    s_def_hash_version;     <span class="co">/* 使用的默认哈希版本 */</span></a>
<a class="sourceLine" id="cb25-66" title="66">        __u8    s_reserved_char_pad;</a>
<a class="sourceLine" id="cb25-67" title="67">        __u16   s_reserved_word_pad;</a>
<a class="sourceLine" id="cb25-68" title="68">        __le32  s_default_mount_opts;</a>
<a class="sourceLine" id="cb25-69" title="69">        __le32  s_first_meta_bg;        <span class="co">/* 第一个元块组 */</span></a>
<a class="sourceLine" id="cb25-70" title="70">        __u32   s_reserved[<span class="dv">190</span>];        <span class="co">/* 填充到块的末尾 */</span></a>
<a class="sourceLine" id="cb25-71" title="71">};</a></code></pre></div>
<h3 id="组描述符"><span class="header-section-number">3.1.3</span> 组描述符</h3>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">struct</span> ext<span class="dv">2</span><span class="er">_group_desc</span></a>
<a class="sourceLine" id="cb26-2" title="2">{</a>
<a class="sourceLine" id="cb26-3" title="3">        __le32  bg_block_bitmap;        <span class="co">/* 数据块位图所在的块号 */</span></a>
<a class="sourceLine" id="cb26-4" title="4">        __le32  bg_inode_bitmap;        <span class="co">/* inode位图所在的块号 */</span></a>
<a class="sourceLine" id="cb26-5" title="5">        __le32  bg_inode_table;         <span class="co">/* inode表所在的起始块号 */</span></a>
<a class="sourceLine" id="cb26-6" title="6">        __le16  bg_free_blocks_count;   <span class="co">/* 组中空闲块个数 */</span></a>
<a class="sourceLine" id="cb26-7" title="7">        __le16  bg_free_inodes_count;   <span class="co">/* 组中空闲索引节点数 */</span></a>
<a class="sourceLine" id="cb26-8" title="8">        __le16  bg_used_dirs_count;     <span class="co">/* 组中目录数 */</span></a>
<a class="sourceLine" id="cb26-9" title="9">        __le16  bg_pad;</a>
<a class="sourceLine" id="cb26-10" title="10">        __le32  bg_reserved[<span class="dv">3</span>];</a>
<a class="sourceLine" id="cb26-11" title="11">};</a></code></pre></div>
<h3 id="inode表"><span class="header-section-number">3.1.4</span> inode表</h3>
<p><code>struct ext2_group_desc</code>的<code>bg_inode_table</code>表示inode表所在的起始块号，磁盘索引节点固定128字节（可以在gdb中打印<code>p sizeof(struct ext2_inode)</code>），1024字节块大小包含8个inode，4096字节块大小包含32个inode。</p>
<p>注意没有索引节点号，因为可以通过计算出来，比如块大小为4096字节，块组中inode位图占用一个块，一个块组的inode个数为4096，索引节点12345在磁盘上的位置可以这样计算<code>12345/4096=3余57</code>，所以在第3个块组（从块组0开始算）中索引节点表中的第57个表项。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="co"> * 磁盘索引节点结构</span></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="kw">struct</span> ext2_inode {</a>
<a class="sourceLine" id="cb27-5" title="5">        __le16  i_mode;         <span class="co">/* 文件类型和访问权限，查看S_ISREG()等函数 */</span></a>
<a class="sourceLine" id="cb27-6" title="6">        __le16  i_uid;          <span class="co">/* 所有者 Uid 的低 16 位，拥有者id */</span></a>
<a class="sourceLine" id="cb27-7" title="7">        <span class="co">// 文件长度，最高位没使用，最大表示2GB文件，大于2GB文件再使用i_dir_acl字段</span></a>
<a class="sourceLine" id="cb27-8" title="8">        __le32  i_size;         <span class="co">/* 大小（字节） */</span></a>
<a class="sourceLine" id="cb27-9" title="9">        __le32  i_atime;        <span class="co">/* 访问时间 */</span></a>
<a class="sourceLine" id="cb27-10" title="10">        __le32  i_ctime;        <span class="co">/* 索引节点创建时间 */</span></a>
<a class="sourceLine" id="cb27-11" title="11">        __le32  i_mtime;        <span class="co">/* 文件数据最后改变时间 */</span></a>
<a class="sourceLine" id="cb27-12" title="12">        __le32  i_dtime;        <span class="co">/* 删除时间 */</span></a>
<a class="sourceLine" id="cb27-13" title="13">        __le16  i_gid;          <span class="co">/* 组 ID 的低 16 位，用户组id */</span></a>
<a class="sourceLine" id="cb27-14" title="14">        __le16  i_links_count;  <span class="co">/* 硬链接计数 */</span></a>
<a class="sourceLine" id="cb27-15" title="15">        __le32  i_blocks;       <span class="co">/* 数据块数，以512字节为单位 */</span></a>
<a class="sourceLine" id="cb27-16" title="16">        __le32  i_flags;        <span class="co">/* 文件标志 */</span></a>
<a class="sourceLine" id="cb27-17" title="17">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb27-18" title="18">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb27-19" title="19">                        __le32  l_i_reserved1;</a>
<a class="sourceLine" id="cb27-20" title="20">                } linux1;</a>
<a class="sourceLine" id="cb27-21" title="21">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb27-22" title="22">                        __le32  h_i_translator;</a>
<a class="sourceLine" id="cb27-23" title="23">                } hurd1;</a>
<a class="sourceLine" id="cb27-24" title="24">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb27-25" title="25">                        __le32  m_i_reserved1;</a>
<a class="sourceLine" id="cb27-26" title="26">                } masix1;</a>
<a class="sourceLine" id="cb27-27" title="27">        } osd1;                         <span class="co">/* OS dependent 1，特定操作系统信息 */</span></a>
<a class="sourceLine" id="cb27-28" title="28">        <span class="co">// i_block 数据块指针，指向15个块，前12个指向数据，第13个一次间接地址，第14个二次间接地址，第15个三次间接地址</span></a>
<a class="sourceLine" id="cb27-29" title="29">        __le32  i_block[EXT2_N_BLOCKS];<span class="co">/* 指向块的指针 */</span></a>
<a class="sourceLine" id="cb27-30" title="30">        __le32  i_generation;   <span class="co">/* 文件版本，给nfs用的 */</span></a>
<a class="sourceLine" id="cb27-31" title="31">        <span class="co">// i_file_acl 访问控制列表，指向一个存放增强属性的块，其他inode如果增强属性一样，可以共享同一个块</span></a>
<a class="sourceLine" id="cb27-32" title="32">        __le32  i_file_acl;     <span class="co">/* 文件访问控制列表（ACL） */</span></a>
<a class="sourceLine" id="cb27-33" title="33">        __le32  i_dir_acl;      <span class="co">/* 目录访问控制列表 */</span></a>
<a class="sourceLine" id="cb27-34" title="34">        __le32  i_faddr;        <span class="co">/* 片地址 */</span></a>
<a class="sourceLine" id="cb27-35" title="35">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb27-36" title="36">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb27-37" title="37">                        __u8    l_i_frag;       <span class="co">/* 片编号 */</span></a>
<a class="sourceLine" id="cb27-38" title="38">                        __u8    l_i_fsize;      <span class="co">/* 片大小 */</span></a>
<a class="sourceLine" id="cb27-39" title="39">                        __u16   i_pad1;</a>
<a class="sourceLine" id="cb27-40" title="40">                        __le16  l_i_uid_high;   <span class="co">/* 以前是reserved2[0]    */</span></a>
<a class="sourceLine" id="cb27-41" title="41">                        __le16  l_i_gid_high;   <span class="co">/* 以前是reserved2[0] */</span></a>
<a class="sourceLine" id="cb27-42" title="42">                        __u32   l_i_reserved2;</a>
<a class="sourceLine" id="cb27-43" title="43">                } linux2;</a>
<a class="sourceLine" id="cb27-44" title="44">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb27-45" title="45">                        __u8    h_i_frag;       <span class="co">/* 片编号 */</span></a>
<a class="sourceLine" id="cb27-46" title="46">                        __u8    h_i_fsize;      <span class="co">/* 片大小 */</span></a>
<a class="sourceLine" id="cb27-47" title="47">                        __le16  h_i_mode_high;</a>
<a class="sourceLine" id="cb27-48" title="48">                        __le16  h_i_uid_high;</a>
<a class="sourceLine" id="cb27-49" title="49">                        __le16  h_i_gid_high;</a>
<a class="sourceLine" id="cb27-50" title="50">                        __le32  h_i_author;</a>
<a class="sourceLine" id="cb27-51" title="51">                } hurd2;</a>
<a class="sourceLine" id="cb27-52" title="52">                <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb27-53" title="53">                        __u8    m_i_frag;       <span class="co">/* 片编号 */</span></a>
<a class="sourceLine" id="cb27-54" title="54">                        __u8    m_i_fsize;      <span class="co">/* 片大小 */</span></a>
<a class="sourceLine" id="cb27-55" title="55">                        __u16   m_pad1;</a>
<a class="sourceLine" id="cb27-56" title="56">                        __u32   m_i_reserved2[<span class="dv">2</span>];</a>
<a class="sourceLine" id="cb27-57" title="57">                } masix2;</a>
<a class="sourceLine" id="cb27-58" title="58">        } osd2;                         <span class="co">/* 特定文件系统信息 */</span></a>
<a class="sourceLine" id="cb27-59" title="59">};</a></code></pre></div>
<p><code>i_file_acl</code>指向一个存放增强属性的块，其他inode如果增强属性一样，可以共享同一个块，系统调用<code>setxattr()</code>、<code>lsetxattr()</code>、<code>fsetxattr()</code>设置文件增强属性，<code>getxattr()</code>、<code>lgetxattr()</code>、<code>fgetxattr()</code>返回文件增强属性，<code>listxattr()</code>、<code>llistxattr()</code>、<code>flistxattr()</code>列出文件所有增强属性。这些系统调用是通过 <code>chacl()</code>、<code>setfacl()</code>、<code>getfacl()</code>调用的。没有正式成为POSIX标准。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">struct</span> ext2_xattr_entry {</a>
<a class="sourceLine" id="cb28-2" title="2">        __u8    e_name_len;     <span class="co">/* 名称长度 */</span></a>
<a class="sourceLine" id="cb28-3" title="3">        __u8    e_name_index;   <span class="co">/* 属性名称索引 */</span></a>
<a class="sourceLine" id="cb28-4" title="4">        __le16  e_value_offs;   <span class="co">/* 值在磁盘块中的偏移量 */</span></a>
<a class="sourceLine" id="cb28-5" title="5">        __le32  e_value_block;  <span class="co">/* 属性存储的磁盘块 (n/i) */</span></a>
<a class="sourceLine" id="cb28-6" title="6">        __le32  e_value_size;   <span class="co">/* 属性值的大小 */</span></a>
<a class="sourceLine" id="cb28-7" title="7">        __le32  e_hash;         <span class="co">/* 名称和值的哈希值 */</span></a>
<a class="sourceLine" id="cb28-8" title="8">        <span class="dt">char</span>    e_name[];       <span class="co">/* 属性名称，可变数组/柔性数组/零长度数组 */</span></a>
<a class="sourceLine" id="cb28-9" title="9">};</a></code></pre></div>
<h3 id="各种文件类型的存储"><span class="header-section-number">3.1.5</span> 各种文件类型的存储</h3>
<p>文件类型如下:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="pp">#define FT_UNKNOWN      0 </span><span class="co">// 未知</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="pp">#define FT_REG_FILE     1 </span><span class="co">// 常规文件</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="pp">#define FT_DIR          2 </span><span class="co">// 目录</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="pp">#define FT_CHRDEV       3 </span><span class="co">// 字符设备</span></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="pp">#define FT_BLKDEV       4 </span><span class="co">// 块设备</span></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="pp">#define FT_FIFO         5 </span><span class="co">// 命名管道</span></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="pp">#define FT_SOCK         6 </span><span class="co">// 套接字</span></a>
<a class="sourceLine" id="cb29-8" title="8"><span class="pp">#define FT_SYMLINK      7 </span><span class="co">// 符号链接</span></a>
<a class="sourceLine" id="cb29-9" title="9">                         </a>
<a class="sourceLine" id="cb29-10" title="10"><span class="pp">#define FT_MAX          8 </span><span class="co">// 类型总数</span></a></code></pre></div>
<p>常规文件刚创建时是空的，不需要数据块，可以用<code>truncate()</code>或<code>open()</code>系统调用清空，如输入命令<code>&gt; filename</code>。</p>
<p>设备文件、管道、套接字所有信息都存放在inode中。</p>
<p>符号链接名小于60个字符就放到<code>struct ext2_inode</code>的<code>i_block</code>数组中（15个4字节），如果大于60个字符就存到单独数据块中。</p>
<p>最后重点讲一下目录的存储，数据块包含<code>ext2_dir_entry_2</code>结构:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb30-2" title="2"><span class="co"> * 目录项的新版本。由于EXT2结构以英特尔字节顺序存储，并且name_len字段永远不可能大于255个字符，因此可以安全地将额外的一个字节重新分配给file_type字段。</span></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="kw">struct</span> ext2_dir_entry_2 {</a>
<a class="sourceLine" id="cb30-5" title="5">        __le32  inode;                  <span class="co">/* 索引节点号 */</span></a>
<a class="sourceLine" id="cb30-6" title="6">        __le16  rec_len;                <span class="co">/* 目录项长度，总是4的倍数 */</span></a>
<a class="sourceLine" id="cb30-7" title="7">        __u8    name_len;               <span class="co">/* 文件名长度 */</span></a>
<a class="sourceLine" id="cb30-8" title="8">        __u8    file_type;              <span class="co">// 文件类型，struct ext2_dir_entry中没有</span></a>
<a class="sourceLine" id="cb30-9" title="9">        <span class="dt">char</span>    name[];                 <span class="co">/* 文件名，最大EXT2_NAME_LEN (255)字节 */</span></a>
<a class="sourceLine" id="cb30-10" title="10">};</a></code></pre></div>
<p>我们举个例子，刚格式化完ext2，然后创建目录<code>mkdir dir</code>，创建文件<code>touch file</code>、创建软链接<code>ln -s file link</code>。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb31-1" title="1">                      <span class="ex">file_type--+</span></a>
<a class="sourceLine" id="cb31-2" title="2">                                 <span class="kw">|</span></a>
<a class="sourceLine" id="cb31-3" title="3">                    <span class="ex">name_len--+</span>  <span class="kw">|</span></a>
<a class="sourceLine" id="cb31-4" title="4">                              <span class="kw">|</span>  <span class="kw">|</span></a>
<a class="sourceLine" id="cb31-5" title="5">  <span class="ex">address</span>     inode   rec_len <span class="kw">|</span>  <span class="kw">|</span>   <span class="ex">name</span></a>
<a class="sourceLine" id="cb31-6" title="6">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a>
<a class="sourceLine" id="cb31-7" title="7">        <span class="ex">0</span> <span class="kw">|</span>      <span class="ex">2</span>    <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">1</span><span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="bu">.</span> \<span class="ex">0</span> \0 \0<span class="kw">|</span></a>
<a class="sourceLine" id="cb31-8" title="8">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a>
<a class="sourceLine" id="cb31-9" title="9">       <span class="ex">12</span> <span class="kw">|</span>      <span class="ex">2</span>    <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="bu">.</span>  <span class="bu">.</span> \<span class="ex">0</span> \0<span class="kw">|</span></a>
<a class="sourceLine" id="cb31-10" title="10">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+--+--+--+--+--+--+--+--+</span></a>
<a class="sourceLine" id="cb31-11" title="11">       <span class="ex">24</span> <span class="kw">|</span>      <span class="ex">11</span>   <span class="kw">|</span>  <span class="ex">20</span> <span class="kw">|</span><span class="ex">10</span><span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="ex">l</span>  o  s  t  +  f  o  u  n  d \0 \0<span class="kw">|</span></a>
<a class="sourceLine" id="cb31-12" title="12">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+--+--+--+--+--+--+--+--+</span></a>
<a class="sourceLine" id="cb31-13" title="13">       <span class="ex">44</span> <span class="kw">|</span>    <span class="ex">15809</span>  <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">3</span><span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="ex">d</span>  i  r \0<span class="kw">|</span></a>
<a class="sourceLine" id="cb31-14" title="14">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a>
<a class="sourceLine" id="cb31-15" title="15">       <span class="ex">56</span> <span class="kw">|</span>      <span class="ex">12</span>   <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">4</span><span class="kw">|</span> <span class="ex">1</span><span class="kw">|</span> <span class="ex">f</span>  i  l  e<span class="kw">|</span></a>
<a class="sourceLine" id="cb31-16" title="16">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a>
<a class="sourceLine" id="cb31-17" title="17">       <span class="ex">68</span> <span class="kw">|</span>      <span class="ex">13</span>   <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">4</span><span class="kw">|</span> <span class="ex">7</span><span class="kw">|</span> <span class="ex">l</span>  i  n  k<span class="kw">|</span></a>
<a class="sourceLine" id="cb31-18" title="18">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a></code></pre></div>
<p>如果删除<code>dir</code>，就会变成以下样子，删除的目录<code>inode</code>改为<code>0</code>，然后前一项的<code>rec_len</code>加上<code>12</code>。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb32-1" title="1">                      <span class="ex">file_type--+</span></a>
<a class="sourceLine" id="cb32-2" title="2">                                 <span class="kw">|</span></a>
<a class="sourceLine" id="cb32-3" title="3">                    <span class="ex">name_len--+</span>  <span class="kw">|</span></a>
<a class="sourceLine" id="cb32-4" title="4">                              <span class="kw">|</span>  <span class="kw">|</span></a>
<a class="sourceLine" id="cb32-5" title="5">  <span class="ex">address</span>     inode   rec_len <span class="kw">|</span>  <span class="kw">|</span>   <span class="ex">name</span></a>
<a class="sourceLine" id="cb32-6" title="6">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a>
<a class="sourceLine" id="cb32-7" title="7">        <span class="ex">0</span> <span class="kw">|</span>      <span class="ex">2</span>    <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">1</span><span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="bu">.</span> \<span class="ex">0</span> \0 \0<span class="kw">|</span></a>
<a class="sourceLine" id="cb32-8" title="8">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a>
<a class="sourceLine" id="cb32-9" title="9">       <span class="ex">12</span> <span class="kw">|</span>      <span class="ex">2</span>    <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="bu">.</span>  <span class="bu">.</span> \<span class="ex">0</span> \0<span class="kw">|</span></a>
<a class="sourceLine" id="cb32-10" title="10">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+--+--+--+--+--+--+--+--+</span></a>
<a class="sourceLine" id="cb32-11" title="11">       <span class="ex">24</span> <span class="kw">|</span>      <span class="ex">11</span>   <span class="kw">|</span>  <span class="ex">32</span> <span class="kw">|</span><span class="ex">10</span><span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="ex">l</span>  o  s  t  +  f  o  u  n  d \0 \0<span class="kw">|</span></a>
<a class="sourceLine" id="cb32-12" title="12">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+--+--+--+--+--+--+--+--+</span></a>
<a class="sourceLine" id="cb32-13" title="13">       <span class="ex">44</span> <span class="kw">|</span>      <span class="ex">0</span>    <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">3</span><span class="kw">|</span> <span class="ex">2</span><span class="kw">|</span> <span class="ex">d</span>  i  r \0<span class="kw">|</span></a>
<a class="sourceLine" id="cb32-14" title="14">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a>
<a class="sourceLine" id="cb32-15" title="15">       <span class="ex">56</span> <span class="kw">|</span>      <span class="ex">12</span>   <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">4</span><span class="kw">|</span> <span class="ex">1</span><span class="kw">|</span> <span class="ex">f</span>  i  l  e<span class="kw">|</span></a>
<a class="sourceLine" id="cb32-16" title="16">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a>
<a class="sourceLine" id="cb32-17" title="17">       <span class="ex">68</span> <span class="kw">|</span>      <span class="ex">13</span>   <span class="kw">|</span>  <span class="ex">12</span> <span class="kw">|</span> <span class="ex">4</span><span class="kw">|</span> <span class="ex">7</span><span class="kw">|</span> <span class="ex">l</span>  i  n  k<span class="kw">|</span></a>
<a class="sourceLine" id="cb32-18" title="18">          <span class="ex">+--+--+--+--</span><span class="kw">|</span><span class="ex">--+--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--</span><span class="kw">|</span><span class="ex">--+--+--+--+</span></a></code></pre></div>
<h2 id="内存数据结构"><span class="header-section-number">3.2</span> 内存数据结构</h2>
<p>磁盘和内存数据结构的关系如下，动态缓存指文件关闭或数据块被删除后页框回收算法从高速缓存中删除数据:</p>
<ul>
<li>超级块: 磁盘<code>ext2_super_block</code>，内存<code>ext2_sb_info</code>，总是缓存</li>
<li>组描述符: 磁盘和内存都是<code>ext2_group_desc</code>，总是缓存</li>
<li>块位图和inode位图: 磁盘是块中的位数组，内存是缓冲区中的位数组，动态缓存</li>
<li>索引节点: 磁盘<code>ext2_inode</code>，内存<code>ext2_inode_info</code>，动态缓存，空闲索引节点从不缓存</li>
<li>数据块: 磁盘是字节数组，内存是VFS缓冲区，动态缓存，空闲块从不缓存</li>
</ul>
<h3 id="超级块-1"><span class="header-section-number">3.2.1</span> 超级块</h3>
<p>VFS的<code>struct super_block</code>中的<code>s_fs_info</code>指向<code>struct ext2_sb_info</code>类型的结构:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="co"> * 第二扩展文件系统的内存中超级块数据 */</span></a>
<a class="sourceLine" id="cb33-3" title="3"> */</a>
<a class="sourceLine" id="cb33-4" title="4"><span class="kw">struct</span> ext2_sb_info {</a>
<a class="sourceLine" id="cb33-5" title="5">        <span class="dt">unsigned</span> <span class="dt">long</span> s_inodes_per_block;<span class="co">/* 每个块的 inode 数量 */</span></a>
<a class="sourceLine" id="cb33-6" title="6">        <span class="dt">unsigned</span> <span class="dt">long</span> s_blocks_per_group;<span class="co">/* 每组中的块数 */</span></a>
<a class="sourceLine" id="cb33-7" title="7">        <span class="dt">unsigned</span> <span class="dt">long</span> s_inodes_per_group;<span class="co">/* 每组中的 inode 数量 */</span></a>
<a class="sourceLine" id="cb33-8" title="8">        <span class="dt">unsigned</span> <span class="dt">long</span> s_itb_per_group;  <span class="co">/* 每组的 inode 表块数 */</span></a>
<a class="sourceLine" id="cb33-9" title="9">        <span class="dt">unsigned</span> <span class="dt">long</span> s_gdb_count;      <span class="co">/* 组描述符块的数量 */</span></a>
<a class="sourceLine" id="cb33-10" title="10">        <span class="co">// 组描述符的个数，可以放在一个块中</span></a>
<a class="sourceLine" id="cb33-11" title="11">        <span class="dt">unsigned</span> <span class="dt">long</span> s_desc_per_block; <span class="co">/* 每个块的组描述符数量 */</span></a>
<a class="sourceLine" id="cb33-12" title="12">        <span class="dt">unsigned</span> <span class="dt">long</span> s_groups_count;   <span class="co">/* 文件系统中的组数 */</span></a>
<a class="sourceLine" id="cb33-13" title="13">        <span class="dt">unsigned</span> <span class="dt">long</span> s_overhead_last;  <span class="co">/* 最近一次计算的开销 */</span></a>
<a class="sourceLine" id="cb33-14" title="14">        <span class="dt">unsigned</span> <span class="dt">long</span> s_blocks_last;    <span class="co">/* 最近一次看到的块数 */</span></a>
<a class="sourceLine" id="cb33-15" title="15">        <span class="co">// 包含磁盘超级块的缓冲区的缓冲区头</span></a>
<a class="sourceLine" id="cb33-16" title="16">        <span class="kw">struct</span> buffer_head * s_sbh;     <span class="co">/* 包含超级块的缓冲区 */</span></a>
<a class="sourceLine" id="cb33-17" title="17">        <span class="co">// 指向磁盘超级块所在的缓冲区</span></a>
<a class="sourceLine" id="cb33-18" title="18">        <span class="kw">struct</span> ext2_super_block * s_es; <span class="co">/* 指向缓冲区中超级块的指针 */</span></a>
<a class="sourceLine" id="cb33-19" title="19">        <span class="co">// 指向一个缓冲区（包含组描述符的缓冲区）首部数组</span></a>
<a class="sourceLine" id="cb33-20" title="20">        <span class="kw">struct</span> buffer_head ** s_group_desc;</a>
<a class="sourceLine" id="cb33-21" title="21">        <span class="dt">unsigned</span> <span class="dt">long</span>  s_mount_opt;</a>
<a class="sourceLine" id="cb33-22" title="22">        <span class="dt">unsigned</span> <span class="dt">long</span> s_sb_block;</a>
<a class="sourceLine" id="cb33-23" title="23">        kuid_t s_resuid;</a>
<a class="sourceLine" id="cb33-24" title="24">        kgid_t s_resgid;</a>
<a class="sourceLine" id="cb33-25" title="25">        <span class="dt">unsigned</span> <span class="dt">short</span> s_mount_state;</a>
<a class="sourceLine" id="cb33-26" title="26">        <span class="dt">unsigned</span> <span class="dt">short</span> s_pad;</a>
<a class="sourceLine" id="cb33-27" title="27">        <span class="dt">int</span> s_addr_per_block_bits;</a>
<a class="sourceLine" id="cb33-28" title="28">        <span class="dt">int</span> s_desc_per_block_bits;</a>
<a class="sourceLine" id="cb33-29" title="29">        <span class="dt">int</span> s_inode_size;</a>
<a class="sourceLine" id="cb33-30" title="30">        <span class="dt">int</span> s_first_ino;</a>
<a class="sourceLine" id="cb33-31" title="31">        spinlock_t s_next_gen_lock;</a>
<a class="sourceLine" id="cb33-32" title="32">        u32 s_next_generation;</a>
<a class="sourceLine" id="cb33-33" title="33">        <span class="dt">unsigned</span> <span class="dt">long</span> s_dir_count;</a>
<a class="sourceLine" id="cb33-34" title="34">        u8 *s_debts;</a>
<a class="sourceLine" id="cb33-35" title="35">        <span class="kw">struct</span> percpu_counter s_freeblocks_counter;</a>
<a class="sourceLine" id="cb33-36" title="36">        <span class="kw">struct</span> percpu_counter s_freeinodes_counter;</a>
<a class="sourceLine" id="cb33-37" title="37">        <span class="kw">struct</span> percpu_counter s_dirs_counter;</a>
<a class="sourceLine" id="cb33-38" title="38">        <span class="kw">struct</span> blockgroup_lock *s_blockgroup_lock;</a>
<a class="sourceLine" id="cb33-39" title="39">        <span class="co">/* 每个文件系统预留窗口树的根 */</span></a>
<a class="sourceLine" id="cb33-40" title="40">        spinlock_t s_rsv_window_lock;</a>
<a class="sourceLine" id="cb33-41" title="41">        <span class="kw">struct</span> rb_root s_rsv_window_root; <span class="co">// ext2_reserve_window_node的所有实例</span></a>
<a class="sourceLine" id="cb33-42" title="42">        <span class="kw">struct</span> ext2_reserve_window_node s_rsv_window_head;</a>
<a class="sourceLine" id="cb33-43" title="43">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb33-44" title="44"><span class="co">         * s_lock 保护 s_mount_state、s_blocks_last、s_overhead_last 和由 sbi-&gt;s_es 指向的</span></a>
<a class="sourceLine" id="cb33-45" title="45"><span class="co">         * 超级块缓冲区内容的并发修改。</span></a>
<a class="sourceLine" id="cb33-46" title="46"><span class="co">         *</span></a>
<a class="sourceLine" id="cb33-47" title="47"><span class="co">         * 注意: 在 ext2_show_options() 中使用它来提供挂载选项的一致视图。</span></a>
<a class="sourceLine" id="cb33-48" title="48"><span class="co">         */</span></a>
<a class="sourceLine" id="cb33-49" title="49">        spinlock_t s_lock;</a>
<a class="sourceLine" id="cb33-50" title="50">        <span class="kw">struct</span> mb_cache *s_ea_block_cache;</a>
<a class="sourceLine" id="cb33-51" title="51">        <span class="kw">struct</span> dax_device *s_daxdev;</a>
<a class="sourceLine" id="cb33-52" title="52">        u64 s_dax_part_off;</a>
<a class="sourceLine" id="cb33-53" title="53">};</a></code></pre></div>
<p>各个数据结构之间的关系如下图:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb34-1" title="1">                                   <span class="ex">ext2</span> partition</a>
<a class="sourceLine" id="cb34-2" title="2">                                       <span class="ex">+-------+----------+----------+----------+</span></a>
<a class="sourceLine" id="cb34-3" title="3">                                       <span class="kw">|</span> <span class="ex">super</span> <span class="kw">|</span><span class="ex">group</span>     <span class="kw">|</span><span class="ex">group</span>     <span class="kw">|</span><span class="ex">group</span>     <span class="kw">|</span></a>
<a class="sourceLine" id="cb34-4" title="4">                                       <span class="kw">|</span> <span class="ex">block</span> <span class="kw">|</span><span class="ex">descriptor</span><span class="kw">|</span><span class="ex">descriptor</span><span class="kw">|</span><span class="ex">descriptor</span><span class="kw">|</span></a>
<a class="sourceLine" id="cb34-5" title="5">                                       <span class="ex">+-------+----------+----------+----------+</span></a>
<a class="sourceLine" id="cb34-6" title="6">                                           ^         ^          ^            ^</a>
<a class="sourceLine" id="cb34-7" title="7">                                           <span class="kw">|</span>         <span class="kw">|</span>          <span class="kw">|</span>            <span class="kw">|</span></a>
<a class="sourceLine" id="cb34-8" title="8">                                           <span class="kw">|</span>         <span class="ex">+------+</span>   +--------+   +----------+</a>
<a class="sourceLine" id="cb34-9" title="9">                                           <span class="kw">|</span>                <span class="kw">|</span>            <span class="kw">|</span>              <span class="kw">|</span></a>
<a class="sourceLine" id="cb34-10" title="10">                                     <span class="ex">+-----------+</span>     +-----------+ +-----------+ +-----------+</a>
<a class="sourceLine" id="cb34-11" title="11"> <span class="ex">+---------------------+</span>             <span class="kw">|</span>  <span class="ex">buffer</span>   <span class="kw">|</span>     <span class="kw">|</span>  <span class="ex">buffer</span>   <span class="kw">|</span> <span class="kw">|</span>  <span class="ex">buffer</span>   <span class="kw">|</span> <span class="kw">|</span>  <span class="ex">buffer</span>   <span class="kw">|</span></a>
<a class="sourceLine" id="cb34-12" title="12"> <span class="kw">|</span>   <span class="ex">super_block</span>       <span class="kw">|</span>        <span class="ex">+---</span><span class="op">&gt;</span>+-----------+     +-----------+ +-----------+ +-----------+</a>
<a class="sourceLine" id="cb34-13" title="13"> <span class="kw">|</span>                     <span class="kw">|</span>        <span class="kw">|</span>         ^                 ^             ^             ^</a>
<a class="sourceLine" id="cb34-14" title="14"> <span class="kw">|</span>   <span class="ex">.s_fs_info</span>        <span class="kw">|</span>        <span class="kw">|</span>         <span class="kw">|</span><span class="ex">b_data</span>           <span class="kw">|</span><span class="ex">b_data</span>       <span class="kw">|</span><span class="ex">b_data</span>       <span class="kw">|</span><span class="ex">b_data</span></a>
<a class="sourceLine" id="cb34-15" title="15"> <span class="kw">|</span> <span class="ex">+--------------+----</span><span class="kw">|</span><span class="ex">--s_es--+</span>         <span class="kw">|</span>                 <span class="kw">|</span>             <span class="kw">|</span>             <span class="kw">|</span>  </a>
<a class="sourceLine" id="cb34-16" title="16"> <span class="kw">|</span> <span class="kw">|</span> <span class="ex">ext2_sb_info</span> <span class="kw">|</span><span class="ex">----</span><span class="kw">|</span><span class="ex">----s_sbh---</span><span class="op">&gt;</span>+-----------+    +-----------------------------------------+</a>
<a class="sourceLine" id="cb34-17" title="17"> <span class="kw">|</span> <span class="ex">+--------------+</span>    <span class="kw">|</span>             <span class="kw">|</span><span class="ex">buffer_head</span><span class="kw">|</span>    <span class="kw">|</span><span class="ex">+-----------+</span> +-----------+ +-----------+<span class="kw">|</span></a>
<a class="sourceLine" id="cb34-18" title="18"> <span class="kw">|</span>           <span class="kw">|</span>         <span class="kw">|</span>             <span class="ex">+-----------+</span>    <span class="kw">||</span><span class="ex">buffer_head</span><span class="kw">|</span> <span class="kw">|</span><span class="ex">buffer_head</span><span class="kw">|</span> <span class="kw">|</span><span class="ex">buffer_head</span><span class="kw">||</span></a>
<a class="sourceLine" id="cb34-19" title="19"> <span class="ex">+---------------------+</span>                              <span class="kw">|</span><span class="ex">+-----------+</span> +-----------+ +-----------+<span class="kw">|</span></a>
<a class="sourceLine" id="cb34-20" title="20">             <span class="kw">|</span>                                        <span class="ex">+-----------------------------------------+</span></a>
<a class="sourceLine" id="cb34-21" title="21">          <span class="ex">s_group_desc</span>                                              ^</a>
<a class="sourceLine" id="cb34-22" title="22">             <span class="kw">|</span>                                                      <span class="kw">|</span></a>
<a class="sourceLine" id="cb34-23" title="23">             <span class="ex">+------------------------------------------------------+</span></a></code></pre></div>
<p>挂载时<code>struct file_system_type ext2_fs_type</code>的<code>ext2_mount()</code>方法再执行到<code>ext2_fill_super()</code>从磁盘读取超级块。</p>
<p>ext2超级块的操作实现是<code>struct super_operations ext2_sops</code>。</p>
<h3 id="索引节点"><span class="header-section-number">3.2.2</span> 索引节点</h3>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="co"> * 第二扩展文件系统在内存中的 inode 数据</span></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="kw">struct</span> ext2_inode_info {</a>
<a class="sourceLine" id="cb35-5" title="5">        __le32  i_data[<span class="dv">15</span>];</a>
<a class="sourceLine" id="cb35-6" title="6">        __u32   i_flags;</a>
<a class="sourceLine" id="cb35-7" title="7">        __u32   i_faddr;</a>
<a class="sourceLine" id="cb35-8" title="8">        __u8    i_frag_no;</a>
<a class="sourceLine" id="cb35-9" title="9">        __u8    i_frag_size;</a>
<a class="sourceLine" id="cb35-10" title="10">        __u16   i_state;</a>
<a class="sourceLine" id="cb35-11" title="11">        __u32   i_file_acl;</a>
<a class="sourceLine" id="cb35-12" title="12">        __u32   i_dir_acl;</a>
<a class="sourceLine" id="cb35-13" title="13">        __u32   i_dtime;</a>
<a class="sourceLine" id="cb35-14" title="14"></a>
<a class="sourceLine" id="cb35-15" title="15">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb35-16" title="16"><span class="co">         * i_block_group 是包含此文件 inode 的块组的编号。</span></a>
<a class="sourceLine" id="cb35-17" title="17"><span class="co">         * 在 inode 的整个生命周期中保持不变，它用于进行块分配决策 - </span></a>
<a class="sourceLine" id="cb35-18" title="18"><span class="co">         * 我们试图将文件的数据块放置在其 inode 块附近，并将新的 inode 放置在其父目录的 inode 附近。</span></a>
<a class="sourceLine" id="cb35-19" title="19"><span class="co">         */</span></a>
<a class="sourceLine" id="cb35-20" title="20">        __u32   i_block_group;</a>
<a class="sourceLine" id="cb35-21" title="21"></a>
<a class="sourceLine" id="cb35-22" title="22">        <span class="co">/* 块预读 */</span></a>
<a class="sourceLine" id="cb35-23" title="23">        <span class="kw">struct</span> ext2_block_alloc_info *i_block_alloc_info;</a>
<a class="sourceLine" id="cb35-24" title="24"></a>
<a class="sourceLine" id="cb35-25" title="25">        __u32   i_dir_start_lookup;</a>
<a class="sourceLine" id="cb35-26" title="26"><span class="pp">#ifdef CONFIG_EXT2_FS_XATTR</span></a>
<a class="sourceLine" id="cb35-27" title="27">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb35-28" title="28"><span class="co">         * 扩展属性可以独立于主文件数据进行读取。即使在读取时也获取 i_mutex 会导致扩展属性的读取者和常规文件数据的写入者之间产生竞争，</span></a>
<a class="sourceLine" id="cb35-29" title="29"><span class="co">         * 因此我们在读取或更改扩展属性时，会改为在 xattr_sem 上进行同步。</span></a>
<a class="sourceLine" id="cb35-30" title="30"><span class="co">         */</span></a>
<a class="sourceLine" id="cb35-31" title="31">        <span class="kw">struct</span> rw_semaphore xattr_sem;</a>
<a class="sourceLine" id="cb35-32" title="32"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb35-33" title="33">        rwlock_t i_meta_lock;</a>
<a class="sourceLine" id="cb35-34" title="34"></a>
<a class="sourceLine" id="cb35-35" title="35">        <span class="co">/*</span></a>
<a class="sourceLine" id="cb35-36" title="36"><span class="co">         * truncate_mutex 用于将 ext2_truncate() 与 ext2_getblock() 串行化。</span></a>
<a class="sourceLine" id="cb35-37" title="37"><span class="co">         * 它还保护 inode 的预留数据结构的内部: ext2_reserve_window 和</span></a>
<a class="sourceLine" id="cb35-38" title="38"><span class="co">         * ext2_reserve_window_node。</span></a>
<a class="sourceLine" id="cb35-39" title="39"><span class="co">         */</span></a>
<a class="sourceLine" id="cb35-40" title="40">        <span class="kw">struct</span> mutex truncate_mutex;</a>
<a class="sourceLine" id="cb35-41" title="41">        <span class="kw">struct</span> inode    vfs_inode;      <span class="co">// 虚拟文件系统的索引节点</span></a>
<a class="sourceLine" id="cb35-42" title="42">        <span class="kw">struct</span> list_head i_orphan;      <span class="co">/* 已解除链接但仍打开的 inodes */</span></a>
<a class="sourceLine" id="cb35-43" title="43"><span class="pp">#ifdef CONFIG_QUOTA</span></a>
<a class="sourceLine" id="cb35-44" title="44">        <span class="kw">struct</span> dquot *i_dquot[MAXQUOTAS];</a>
<a class="sourceLine" id="cb35-45" title="45"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb35-46" title="46">};</a>
<a class="sourceLine" id="cb35-47" title="47"></a>
<a class="sourceLine" id="cb35-48" title="48"><span class="kw">struct</span> ext2_block_alloc_info {                                                   </a>
<a class="sourceLine" id="cb35-49" title="49">        <span class="co">/* 预留窗口信息 */</span>                               </a>
<a class="sourceLine" id="cb35-50" title="50">        <span class="kw">struct</span> ext2_reserve_window_node rsv_window_node;                         </a>
<a class="sourceLine" id="cb35-51" title="51">        <span class="co">/*                                                                       </span></a>
<a class="sourceLine" id="cb35-52" title="52"><span class="co">         * 是曾经 ext2_inode_info 结构中的 i_next_alloc_block </span></a>
<a class="sourceLine" id="cb35-53" title="53"><span class="co">         * 是文件中最近分配的块的逻辑（文件相对）编号。</span></a>
<a class="sourceLine" id="cb35-54" title="54"><span class="co">         * 我们用这个来检测线性递增的分配请求。</span></a>
<a class="sourceLine" id="cb35-55" title="55"><span class="co">         */</span>                                                                      </a>
<a class="sourceLine" id="cb35-56" title="56">        __u32                   last_alloc_logical_block;                        </a>
<a class="sourceLine" id="cb35-57" title="57">        <span class="co">/*                                                                       </span></a>
<a class="sourceLine" id="cb35-58" title="58"><span class="co">         * 曾是 ext2_inode_info 结构中的 i_next_alloc_goal                              </span></a>
<a class="sourceLine" id="cb35-59" title="59"><span class="co">         * 是 i_next_alloc_block 的物理对应项。它是最近分配给该文件的块的物理块编号。</span></a>
<a class="sourceLine" id="cb35-60" title="60"><span class="co">         * 当我们检测到线性递增的请求时，这为我们提供了下一次分配的目标。</span></a>
<a class="sourceLine" id="cb35-61" title="61"><span class="co">         */</span>                                                                      </a>
<a class="sourceLine" id="cb35-62" title="62">        ext2_fsblk_t            last_alloc_physical_block;                       </a>
<a class="sourceLine" id="cb35-63" title="63">};</a>
<a class="sourceLine" id="cb35-64" title="64"></a>
<a class="sourceLine" id="cb35-65" title="65"><span class="kw">struct</span> ext2_reserve_window_node {                       </a>
<a class="sourceLine" id="cb35-66" title="66">        <span class="kw">struct</span> rb_node          rsv_node;               </a>
<a class="sourceLine" id="cb35-67" title="67">        __u32                   rsv_goal_size;      <span class="co">// 预留窗口的预期长度, 最大为 EXT2_MAX_RESERVE_BLOCKS</span></a>
<a class="sourceLine" id="cb35-68" title="68">        __u32                   rsv_alloc_hit;      <span class="co">// 预分配的命中数</span></a>
<a class="sourceLine" id="cb35-69" title="69">        <span class="kw">struct</span> ext2_reserve_window      rsv_window; <span class="co">// 预留窗口</span></a>
<a class="sourceLine" id="cb35-70" title="70">};                                                      </a></code></pre></div>
<p>由<code>struct super_operations ext2_sops</code>的<code>ext2_alloc_inode()</code>分配索引节点对象。</p>
<p>ext2索引节点操作实现:</p>
<ul>
<li>常规文件: <code>struct inode_operations ext2_file_inode_operations</code></li>
<li>目录: <code>struct inode_operations ext2_dir_inode_operations</code></li>
<li>快速符号链接（路径名小于60字节）: <code>struct inode_operations ext2_fast_symlink_inode_operations</code></li>
<li>普通符号链接（路径名大于60字节）: <code>struct inode_operations ext2_symlink_inode_operations</code></li>
</ul>
<p><code>ext2_inode_info-&gt;vfs_inode-&gt;i_mapping-&gt;a_ops</code>的实现是<code>ext2_aops</code>和<code>ext2_dax_aops</code>（DAX，Direct Access，允许文件系统直接访问持久性内存（如非易失性内存，NVDIMM）上的数据，而无需经过缓存。这可以显著提高I/O性能，特别是在读取和写入小文件时）。</p>
<h2 id="管理磁盘空间"><span class="header-section-number">3.3</span> 管理磁盘空间</h2>
<p>创建索引节点 <code>ext2_new_inode()</code>，删除索引节点 <code>ext2_free_inode()</code>。</p>
<p>当块大小为<code>1024</code>字节时，命令<code>echo -n something | dd of=file bs=1 seek=4098</code>创建一个有“洞”的文件，索引节点的<code>i_size</code>值为<code>4099</code>，但<code>i_blocks</code>的值为2，因为只占用1个块，1个块<code>1024</code>字节，以<code>512</code>为单位的<code>i_blocks</code>的值为2。<code>i_block[]</code>数组前4个元素值为0，第五个元素存放块号。</p>
<p>分配数据块调用<code>ext2_get_block() -&gt; ext2_alloc_blocks() -&gt; ext2_new_blocks()</code>，释放数据块调用<code>ext2_free_blocks()</code>。</p>
<p>再讲一下数据块寻址，<code>inode</code>的<code>i_block[]</code>数组默认有15个元素，每个元素4字节，前12个直接指向存放数据的逻辑块（对应的文件块号是<code>0~11</code>）。第13个元素指向的是间接块，这个间接块上存了一个<code>bsize/4</code>个元素的数组（其中<code>bsize</code>表示块大小），对应的文件块号为<code>12~(11+bsize/4)</code>。第14个元素指向二级间接块，第15个元素指向三级间接块。</p>
<p>ext2不经过页缓存直接写调用<code>ext2_file_write_iter() -&gt; ext2_dio_write_iter()</code>, 经过缓存写调用<code>ext2_file_write_iter() -&gt; generic_file_write_iter()</code>。</p>
<h2 id="调试ext2磁盘布局"><span class="header-section-number">3.4</span> 调试ext2磁盘布局</h2>
<p><code>mkfs.ext2 /dev/sda</code>相当于<code>mke2fs -t 2 -b 1024 -m 5</code>，块大小默认<code>1024</code>字节，保留块百分比默认<code>5%</code>，每<code>8192</code>字节设置一个索引节点，<code>lost+found</code>目录放丢失和找到的缺陷块。</p>
<p>我们举个例子，一个比较小的磁盘（也可以打开内核配置<code>CONFIG_BLK_DEV_LOOP</code>然后对文件执行同样的操作），执行完以下命令:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb36-1" title="1"><span class="ex">mkfs.ext2</span> -F /dev/sda <span class="co"># 8412KB大小</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="fu">dd</span> if=/dev/sda of=image bs=1K count=8412</a>
<a class="sourceLine" id="cb36-3" title="3"><span class="ex">vim</span> image <span class="co"># 然后输入 :%!xxd，当然也可以使用其他编辑器打开查看二进制数据</span></a></code></pre></div>
<p>其中执行<code>mkfs.ext2</code>输出以下日志:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb37-1" title="1"><span class="ex">mke2fs</span> 1.46.2 (28-Feb-2021)</a>
<a class="sourceLine" id="cb37-2" title="2"><span class="ex">Discarding</span> device blocks: done                            </a>
<a class="sourceLine" id="cb37-3" title="3"><span class="ex">Creating</span> filesystem with 8412 1k blocks and 2112 inodes</a>
<a class="sourceLine" id="cb37-4" title="4"><span class="ex">Filesystem</span> UUID: 13b5577a-898c-40e5-a9e6-c0a0dd2b8ab6</a>
<a class="sourceLine" id="cb37-5" title="5"><span class="ex">Superblock</span> backups stored on blocks: </a>
<a class="sourceLine" id="cb37-6" title="6">        <span class="ex">8193</span></a>
<a class="sourceLine" id="cb37-7" title="7"></a>
<a class="sourceLine" id="cb37-8" title="8"><span class="ex">Allocating</span> group tables: done                            </a>
<a class="sourceLine" id="cb37-9" title="9"><span class="ex">Writing</span> inode tables: done                            </a>
<a class="sourceLine" id="cb37-10" title="10"><span class="ex">Writing</span> superblocks and filesystem accounting information: done</a></code></pre></div>
<p>通过<code>debugfs image</code>，然后输入<code>stats</code>查看到有2个块组（如果磁盘大小减小成<code>8411KB</code>，则只用1个块组）:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb38-1" title="1"><span class="ex">Filesystem</span> volume name:   <span class="op">&lt;</span>none<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="ex">Last</span> mounted on:          <span class="op">&lt;</span>not available<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="ex">Filesystem</span> UUID:          13b5577a-898c-40e5-a9e6-c0a0dd2b8ab6</a>
<a class="sourceLine" id="cb38-4" title="4"><span class="ex">Filesystem</span> magic number:  0xEF53</a>
<a class="sourceLine" id="cb38-5" title="5"><span class="ex">Filesystem</span> revision <span class="co">#:    1 (dynamic)</span></a>
<a class="sourceLine" id="cb38-6" title="6"><span class="ex">Filesystem</span> features:      ext_attr resize_inode dir_index filetype sparse_super large_file</a>
<a class="sourceLine" id="cb38-7" title="7"><span class="ex">Filesystem</span> flags:         signed_directory_hash </a>
<a class="sourceLine" id="cb38-8" title="8"><span class="ex">Default</span> mount options:    user_xattr acl</a>
<a class="sourceLine" id="cb38-9" title="9"><span class="ex">Filesystem</span> state:         clean</a>
<a class="sourceLine" id="cb38-10" title="10"><span class="ex">Errors</span> behavior:          Continue</a>
<a class="sourceLine" id="cb38-11" title="11"><span class="ex">Filesystem</span> OS type:       Linux</a>
<a class="sourceLine" id="cb38-12" title="12"><span class="ex">Inode</span> count:              2112</a>
<a class="sourceLine" id="cb38-13" title="13"><span class="ex">Block</span> count:              8412</a>
<a class="sourceLine" id="cb38-14" title="14"><span class="ex">Reserved</span> block count:     420</a>
<a class="sourceLine" id="cb38-15" title="15"><span class="ex">Overhead</span> clusters:        337</a>
<a class="sourceLine" id="cb38-16" title="16"><span class="ex">Free</span> blocks:              8061</a>
<a class="sourceLine" id="cb38-17" title="17"><span class="ex">Free</span> inodes:              2101</a>
<a class="sourceLine" id="cb38-18" title="18"><span class="ex">First</span> block:              1</a>
<a class="sourceLine" id="cb38-19" title="19"><span class="ex">Block</span> size:               1024</a>
<a class="sourceLine" id="cb38-20" title="20"><span class="ex">Fragment</span> size:            1024</a>
<a class="sourceLine" id="cb38-21" title="21"><span class="ex">Reserved</span> GDT blocks:      32</a>
<a class="sourceLine" id="cb38-22" title="22"><span class="ex">Blocks</span> per group:         8192</a>
<a class="sourceLine" id="cb38-23" title="23"><span class="ex">Fragments</span> per group:      8192</a>
<a class="sourceLine" id="cb38-24" title="24"><span class="ex">Inodes</span> per group:         1056</a>
<a class="sourceLine" id="cb38-25" title="25"><span class="ex">Inode</span> blocks per group:   132</a>
<a class="sourceLine" id="cb38-26" title="26"><span class="ex">Filesystem</span> created:       Thu May 23 12:50:34 2024</a>
<a class="sourceLine" id="cb38-27" title="27"><span class="ex">Last</span> mount time:          n/a</a>
<a class="sourceLine" id="cb38-28" title="28"><span class="ex">Last</span> write time:          Thu May 23 12:50:34 2024</a>
<a class="sourceLine" id="cb38-29" title="29"><span class="ex">Mount</span> count:              0</a>
<a class="sourceLine" id="cb38-30" title="30"><span class="ex">Maximum</span> mount count:      -1</a>
<a class="sourceLine" id="cb38-31" title="31"><span class="ex">Last</span> checked:             Thu May 23 12:50:34 2024</a>
<a class="sourceLine" id="cb38-32" title="32"><span class="ex">Check</span> interval:           0 (<span class="op">&lt;</span>none<span class="op">&gt;</span>)</a>
<a class="sourceLine" id="cb38-33" title="33"><span class="ex">Reserved</span> blocks uid:      0 (user root)</a>
<a class="sourceLine" id="cb38-34" title="34"><span class="ex">Reserved</span> blocks gid:      0 (group root)</a>
<a class="sourceLine" id="cb38-35" title="35"><span class="ex">First</span> inode:              11</a>
<a class="sourceLine" id="cb38-36" title="36"><span class="ex">Inode</span> size:               128</a>
<a class="sourceLine" id="cb38-37" title="37"><span class="ex">Default</span> directory hash:   half_md4</a>
<a class="sourceLine" id="cb38-38" title="38"><span class="ex">Directory</span> Hash Seed:      2ac788a5-17e7-49f1-9b94-4ca6c9397d55</a>
<a class="sourceLine" id="cb38-39" title="39"><span class="ex">Directories</span>:              2</a>
<a class="sourceLine" id="cb38-40" title="40"> <span class="ex">Group</span>  0: block bitmap at 35, inode bitmap at 36, inode table at 37</a>
<a class="sourceLine" id="cb38-41" title="41">           <span class="ex">8010</span> free blocks, 1045 free inodes, 2 used directories</a>
<a class="sourceLine" id="cb38-42" title="42"> <span class="ex">Group</span>  1: block bitmap at 8227, inode bitmap at 8228, inode table at 8229</a>
<a class="sourceLine" id="cb38-43" title="43">           <span class="ex">51</span> free blocks, 1056 free inodes, 0 used directories</a></code></pre></div>
<p>默认1个块大小<code>1024(0x400)</code>字节，每个块的内容如下:</p>
<ul>
<li>第0个块: <code>0~0x400</code>为引导块（启动块）</li>
<li>第1个块: <code>0x400~0x800</code>为超级块（<code>gdb</code>打印<code>p sizeof(struct ext2_super_block)</code>的值为<code>1024</code>），超级块固定1个块
<ul>
<li><code>0x400</code>地址为<code>s_inodes_count</code>成员，值为<code>0x840(2112)</code>，注意是小端模式存储的</li>
<li><code>0x438</code>地址的值为<code>EXT2_SUPER_MAGIC</code>，是<code>s_magic</code>成员的值，偏移量可以用<code>gdb</code>命令<code>p &amp;((struct ext2_super_block *)0)-&gt;s_magic</code>查看</li>
<li>其他字段的值请自行实践查看</li>
</ul></li>
<li>第2个块: <code>0x800~0xc00</code>，两个块组描述符，一个块组描述符<code>32</code>字节，每个块组中含有全部块组的块组描述符，如果超过<code>32</code>个块组（<code>32*32=1024</code>），组描述符就不只一个块。和超级块一样，块组描述符也是只存储到块组0、1、3、5、7、9、25、49…
<ul>
<li>第一个<code>ext2_group_desc</code>，<code>bg_block_bitmap</code>的值为<code>35(0x23)</code></li>
</ul></li>
<li>第35个块: <code>0x8c00~0x9000</code>为数据块位图</li>
<li>第36个块: <code>0x9000~0x9400</code>为索引节点位图</li>
<li>第37~164个块: <code>0x9400~0x29400</code>为inode表，inode表占<code>128</code>个块（<code>1024</code>个<code>inode</code>）
<ul>
<li><code>0x9900</code>为<code>lost+found</code>文件的<code>ext2_inode</code>，<code>0x9928</code>为<code>i_block[]</code>（值为<code>0xaa</code>），数据块的地址为<code>0xaa*1024=0x2a800</code>，也就是<code>.</code>和<code>..</code>两个隐藏的文件夹</li>
</ul></li>
</ul>
<h2 id="工具软件"><span class="header-section-number">3.5</span> 工具软件</h2>
<p>最后再介绍几个ext文件系统相关的用户态工具:</p>
<ul>
<li><code>mke2fs</code>: 用于建立ext2文件系统，ext2文件系统直接使用<code>mkfs.ext2</code>（相当于<code>mke2fs -t 2</code>），ext4直接使用<code>mkfs.ext4</code>。具体用法查看<code>man 8 mke2fs</code>。</li>
<li><code>e2fsck</code>: 用于检查使用 ext2 文件系统的 partition 是否正常工作，对于ext2文件系统可以直接使用<code>fsck.ext2</code>命令，ext4直接使用<code>fsck.ext4</code>。具体用法查看<code>man 8 e2fsck</code>。</li>
<li><code>debugfs</code>: ext2/ext3/ext4文件系统调试器，具体用法查看<code>man 8 debugfs</code>。</li>
<li><code>dumpe2fs</code>: 显示ext2、ext3、ext4文件系统的超级快和块组信息，具体用法查看<code>man 8 dumpe2fs</code>。</li>
<li><code>tune2fs</code>: 用于管理文件系统参数，具体用法查看<code>man 8 tune2fs</code>。</li>
<li><code>e2image</code>: 将关键的 ext2/ext3/ext4 文件系统元数据保存到文件中，具体用法查看<code>man 8 e2image</code>。
<ul>
<li><code>e2image device image-file</code>: 保存元数据，查看超级快和块组信息使用<code>debugfs -i image-file</code>和<code>dumpe2fs -i image-file</code>。</li>
<li><code>e2image -I device image-file</code>: 恢复。</li>
</ul></li>
<li><code>dump</code>: 备份ext2/3/4文件系统，安装<code>apt install dump -y</code>。</li>
</ul>
<h2 id="开发一个新文件系统的步骤"><span class="header-section-number">3.6</span> 开发一个新文件系统的步骤</h2>
<p>以ext2为例，说明开发一个新文件系统所需的步骤，也可以作为学习一个文件系统的方法步骤。</p>
<ol type="1">
<li>定义超级块结构。</li>
</ol>
<ul>
<li>磁盘超级块结构<code>struct ext2_super_block</code>，在<code>struct file_system_type ext2_fs_type</code>的<code>.mount</code>实现<code>ext2_mount()</code>里调用到的<code>ext2_fill_super()</code>中找。</li>
<li>内存超级块结构<code>struct ext2_sb_info</code>，赋值给<code>struct super_block</code>的<code>s_fs_info</code>成员。</li>
</ul>
<ol start="2" type="1">
<li>实现超级块操作方法<code>ext2_sops</code>。</li>
<li>定义索引节点结构。</li>
</ol>
<ul>
<li>磁盘索引节点结构<code>struct ext2_inode</code>，在超级块操作方法<code>ext2_sops</code>的<code>.write_inode</code>实现函数中找。</li>
<li>内存索引节点结构<code>struct ext2_inode_info</code>，内嵌<code>struct inode</code>，在超级块操作方法<code>ext2_sops</code>的很多函数都可以找到。</li>
</ul>
<ol start="4" type="1">
<li>实现各种类型文件的索引节点操作方法:</li>
</ol>
<ul>
<li>常规文件<code>ext2_file_inode_operations</code>。</li>
<li>目录<code>ext2_dir_inode_operations</code>。</li>
<li>快速符号链接（路径名小于60字节）<code>ext2_fast_symlink_inode_operations</code>。</li>
<li>普通符号链接（路径名大于60字节）<code>ext2_symlink_inode_operations</code>。</li>
<li>其他<code>ext2_special_inode_operations</code>。</li>
</ul>
<ol start="5" type="1">
<li>实现<code>dentry</code>操作方法，ext和xfs等文件系统都没定义，nfs为<code>nfs_dentry_operations</code>和<code>nfs4_dentry_operations</code>，smb client为<code>cifs_dentry_ops</code>和<code>cifs_ci_dentry_ops</code>。</li>
<li>实现各种类型文件的<code>file</code>操作方法:</li>
</ol>
<ul>
<li>常规文件<code>ext2_file_operations</code>。</li>
<li>目录<code>ext2_dir_operations</code>。</li>
<li>其他类型查看<code>init_special_inode()</code>函数。</li>
</ul>
<ol start="7" type="1">
<li>实现各种类型文件的<code>address_space</code>操作方法:</li>
</ol>
<ul>
<li>常规文件<code>ext2_aops</code>和<code>ext2_dax_aops</code>。</li>
<li>目录，ext2没定义目录相关的操作，nfs为<code>nfs_dir_aops</code>。</li>
<li>其他类型，如块设备<code>def_blk_aops</code>。</li>
</ul>
<ol start="8" type="1">
<li>定义文件系统类型<code>ext2_fs_type</code>。</li>
<li>模块加载卸载方法，<code>init_ext2_fs</code>和<code>exit_ext2_fs</code>。</li>
</ol>
<h1 id="minix文件系统"><span class="header-section-number">4</span> minix文件系统</h1>
<h2 id="使用"><span class="header-section-number">4.1</span> 使用</h2>
<p>虚拟机启动时，不能使用4k盘，qemu启动命令<code>logical_block_size</code>和<code>physical_block_size</code>参数要使用512:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb39-1" title="1"><span class="ex">-drive</span> file=1,if=none,format=raw,cache=writeback,file.locking=off,id=dd_1 \</a>
<a class="sourceLine" id="cb39-2" title="2">-device scsi-hd,drive=dd_1,id=disk_1,logical_block_size=512,physical_block_size=512 \</a></code></pre></div>
<p>格式化磁盘，具体的选项使用<code>man mkfs.minix</code>查看:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb40-1" title="1"><span class="ex">mkfs.minix</span> image <span class="co"># 默认版本1</span></a>
<a class="sourceLine" id="cb40-2" title="2"><span class="ex">mkfs.minix</span> -3 /dev/sda <span class="co"># 指定版本3</span></a></code></pre></div>
<p><code>mkfs.minix image</code>的输出如下:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb41-1" title="1"><span class="ex">21856</span> inodes</a>
<a class="sourceLine" id="cb41-2" title="2"><span class="ex">65535</span> blocks</a>
<a class="sourceLine" id="cb41-3" title="3"><span class="va">Firstdatazone=</span>696 <span class="kw">(</span><span class="ex">696</span><span class="kw">)</span></a>
<a class="sourceLine" id="cb41-4" title="4"><span class="va">Zonesize=</span>1024 <span class="co"># v1的zone大小</span></a>
<a class="sourceLine" id="cb41-5" title="5"><span class="va">Maxsize=</span>268966912</a></code></pre></div>
<p>挂载文件系统:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb42-1" title="1"><span class="fu">mount</span> -t minix /dev/sda /mnt</a></code></pre></div>
<p>或者格式化文件，通过loop设备挂载，注意这时需要打开<code>CONFIG_BLK_DEV_LOOP</code>配置。</p>
<h2 id="独立模块编译"><span class="header-section-number">4.2</span> 独立模块编译</h2>
<p>如果我们要在minix文件系统的基础上再开发，为了方便开发测试，可以<code>fs/minix</code>复制出来，<a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/0001-myminix.patch">然后打上补丁<code>0001-myminix.patch</code></a>，这里我把文件系统类型名改为了<code>myminix</code>，挂载时要指定挂载选项，如通过loop设备挂载:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb43-1" title="1"><span class="fu">mount</span> -t myminix -o loop image /mnt</a></code></pre></div>
<h2 id="util-linux"><span class="header-section-number">4.3</span> <code>util-linux</code></h2>
<p>用户态工具源码包含在<a href="https://git.kernel.org/pub/scm/utils/util-linux/util-linux.git/tree/disk-utils"><code>util-linux</code></a>中，<a href="https://github.com/util-linux/util-linux">github仓库</a>。</p>
<p>编译参考<a href="https://github.com/util-linux/util-linux/blob/master/Documentation/howto-compilation.txt"><code>Documentation/howto-compilation.txt</code></a>。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb44-1" title="1"><span class="ex">apt</span> install -y autopoint gettext flex bison sqlite3 libsqlite3-dev</a>
<a class="sourceLine" id="cb44-2" title="2"><span class="ex">./autogen.sh</span> <span class="kw">&amp;&amp;</span> <span class="ex">./configure</span> <span class="kw">&amp;&amp;</span> <span class="fu">make</span> -j<span class="kw">`</span><span class="ex">nproc</span><span class="kw">`</span></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="co"># make install # 默认安装到/usr/sbin/mkfs.minix</span></a></code></pre></div>
<h2 id="数据结构"><span class="header-section-number">4.4</span> 数据结构</h2>
<ol type="1">
<li>超级块结构。</li>
</ol>
<ul>
<li>磁盘超级块结构<code>struct minix_super_block</code>和<code>struct minix3_super_block</code></li>
<li>内存超级块结构<code>struct minix_sb_info</code>，赋值给<code>struct super_block</code>的<code>s_fs_info</code>成员</li>
</ul>
<ol start="2" type="1">
<li>超级块操作方法<code>minix_sops</code>。</li>
<li>索引节点结构。</li>
</ol>
<ul>
<li>磁盘索引节点结构<code>struct minix_inode</code>和<code>struct minix2_inode</code></li>
<li>内存索引节点结构<code>struct minix_inode_info</code></li>
</ul>
<ol start="4" type="1">
<li>各种类型文件的索引节点操作方法:</li>
</ol>
<ul>
<li>常规文件<code>minix_file_inode_operations</code>。</li>
<li>目录<code>minix_dir_inode_operations</code>。</li>
<li>符号链接（路径名小于60字节）<code>minix_symlink_inode_operations</code>。</li>
</ul>
<ol start="5" type="1">
<li><code>dentry</code>操作方法，minix没有定义</li>
<li>各种类型文件的<code>file</code>操作方法:</li>
</ol>
<ul>
<li>常规文件<code>minix_file_operations</code>。</li>
<li>目录<code>minix_dir_operations</code>。</li>
<li>其他类型查看<code>init_special_inode()</code>函数。</li>
</ul>
<ol start="7" type="1">
<li>各种类型文件的<code>address_space</code>操作方法，常规文件、目录、符号链接都是<code>minix_aops</code></li>
<li>文件系统类型<code>minix_fs_type</code>。</li>
<li>模块加载卸载方法，<code>init_minix_fs</code>和<code>exit_minix_fs</code>。</li>
</ol>
<p>其他重要的数据结构:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb45-1" title="1"><span class="kw">typedef</span> <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb45-2" title="2">        block_t *p; <span class="co">// key在内存中的地址</span></a>
<a class="sourceLine" id="cb45-3" title="3">        block_t key; <span class="co">// 块号</span></a>
<a class="sourceLine" id="cb45-4" title="4">        <span class="kw">struct</span> buffer_head *bh; <span class="co">// 缓冲头，内存中保存块的数据</span></a>
<a class="sourceLine" id="cb45-5" title="5">} Indirect;</a></code></pre></div>
<h2 id="函数流程"><span class="header-section-number">4.5</span> 函数流程</h2>
<p>写文件流程:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb46-1" title="1">write</a>
<a class="sourceLine" id="cb46-2" title="2">  ksys_write</a>
<a class="sourceLine" id="cb46-3" title="3">    vfs_write</a>
<a class="sourceLine" id="cb46-4" title="4">      new_sync_write</a>
<a class="sourceLine" id="cb46-5" title="5">        generic_file_write_iter</a>
<a class="sourceLine" id="cb46-6" title="6">          __generic_file_write_iter</a>
<a class="sourceLine" id="cb46-7" title="7">            generic_perform_write</a>
<a class="sourceLine" id="cb46-8" title="8">              minix_write_begin</a>
<a class="sourceLine" id="cb46-9" title="9">                block_write_begin</a>
<a class="sourceLine" id="cb46-10" title="10">                  __block_write_begin_int</a>
<a class="sourceLine" id="cb46-11" title="11">                    minix_get_block</a>
<a class="sourceLine" id="cb46-12" title="12">                      V<span class="dv">1</span><span class="er">_minix_get_block</span></a>
<a class="sourceLine" id="cb46-13" title="13">                        get_block <span class="co">// 这里的bh已经分配内存了</span></a>
<a class="sourceLine" id="cb46-14" title="14">                          block_to_path</a>
<a class="sourceLine" id="cb46-15" title="15">                            offsets[n++] = block <span class="co">// if (block &lt; 7) 直接块</span></a>
<a class="sourceLine" id="cb46-16" title="16">                          <span class="co">// depth=1时直接指向数据，depth=2时一次间接地址</span></a>
<a class="sourceLine" id="cb46-17" title="17">                          <span class="co">// Zonesize=1024，v1版本DIRECT = 7，所以当写的文件大小超过7168字节时，depth=2</span></a>
<a class="sourceLine" id="cb46-18" title="18">                          get_branch</a>
<a class="sourceLine" id="cb46-19" title="19">                            i_data(inode)</a>
<a class="sourceLine" id="cb46-20" title="20">                              <span class="cf">return</span> u.i<span class="dv">1</span><span class="er">_data</span></a>
<a class="sourceLine" id="cb46-21" title="21">                            add_chain(i1_data + *offsets)</a>
<a class="sourceLine" id="cb46-22" title="22">                              Indirect-&gt;p = block_t *</a>
<a class="sourceLine" id="cb46-23" title="23">                              Indirect-&gt;key = block_t</a>
<a class="sourceLine" id="cb46-24" title="24">                              Indirect-&gt;bh = buffer_head *</a>
<a class="sourceLine" id="cb46-25" title="25">                            sb_bread <span class="co">// 根据块号和块大小获取数据，返回buffer_head</span></a>
<a class="sourceLine" id="cb46-26" title="26">                          alloc_branch <span class="co">// 如果块没找到</span></a>
<a class="sourceLine" id="cb46-27" title="27">                            parent = minix_new_block <span class="co">// 获得新块，只是设置bitmap</span></a>
<a class="sourceLine" id="cb46-28" title="28">                            <span class="co">// 间接块才往下走</span></a>
<a class="sourceLine" id="cb46-29" title="29">                            nr = minix_new_block(inode)</a>
<a class="sourceLine" id="cb46-30" title="30">                            bh = sb_getblk <span class="co">// 获取间接块对应的buffer_head</span></a>
<a class="sourceLine" id="cb46-31" title="31">                          map_bh <span class="co">// 将buffer_head映射到块</span></a></code></pre></div>
<h2 id="支持长文件名"><span class="header-section-number">4.6</span> 支持长文件名</h2>
<p>我们来看一个有趣的问题: 让minix文件系统（v3）支持最大长度4095字节的文件名。</p>
<p>当我们使用<code>touch</code>命令创建一个4095字节长度的文件时，会执行到<code>minix_lookup</code>函数。而当创建一个4096字节长度的文件时，不会执行到<code>minix_lookup</code>函数，说明在<code>vfs</code>已经拦截了。</p>
<p>相关代码流程如下:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb47-1" title="1">openat</a>
<a class="sourceLine" id="cb47-2" title="2">  do_sys_open</a>
<a class="sourceLine" id="cb47-3" title="3">    do_sys_openat<span class="dv">2</span></a>
<a class="sourceLine" id="cb47-4" title="4">      getname</a>
<a class="sourceLine" id="cb47-5" title="5">        getname_flags</a>
<a class="sourceLine" id="cb47-6" title="6">          len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX) = <span class="dv">4064</span> <span class="co">// EMBEDDED_NAME_MAX 为 4096-32</span></a>
<a class="sourceLine" id="cb47-7" title="7">          <span class="co">// touch &lt;4095字节文件名&gt; 时 len = 4095, 会调用到 minix_lookup</span></a>
<a class="sourceLine" id="cb47-8" title="8">          <span class="co">// touch &lt;4096字节文件名&gt; 时 len = 4096, 不会调用到 minix_lookup</span></a>
<a class="sourceLine" id="cb47-9" title="9">          len = strncpy_from_user(kname, filename, PATH_MAX)</a>
<a class="sourceLine" id="cb47-10" title="10">          <span class="cf">if</span> (unlikely(len == PATH_MAX))</a>
<a class="sourceLine" id="cb47-11" title="11">          <span class="cf">return</span> ERR_PTR(-ENAMETOOLONG) <span class="co">// touch &lt;4096字节文件名&gt; 时</span></a>
<a class="sourceLine" id="cb47-12" title="12">      do_filp_open</a>
<a class="sourceLine" id="cb47-13" title="13">        path_openat</a>
<a class="sourceLine" id="cb47-14" title="14">          open_last_lookups</a>
<a class="sourceLine" id="cb47-15" title="15">            lookup_open</a>
<a class="sourceLine" id="cb47-16" title="16">              minix_lookup</a>
<a class="sourceLine" id="cb47-17" title="17">                <span class="co">// s_namelen 的值在 minix_fill_super 中设置，minix v3 为 60字节</span></a>
<a class="sourceLine" id="cb47-18" title="18">                <span class="cf">return</span> ERR_PTR(-ENAMETOOLONG) <span class="co">// touch &lt;4095字节文件名&gt; 时</span></a></code></pre></div>
<p>如果当路径中前面有其他路径时（如<code>/mnt/&lt;4095字节文件名&gt;</code>就有4100个字节），会被vfs拦截，所以当要支持4095字节长度时，要在<code>vfs</code>做修改。而大部分文件系统支持的最大文件名长度为255字节，所以我们可以这样设计: 当文件名（普通文件和文件夹）大于255字节时，在<code>vfs</code>对文件名做hash映射，当文件名（普通文件和文件夹）大于minix v3文件系统最大支持的60字节时，在minix文件系统对文件名做hash映射。</p>
<p>暂时只对最后一个路径名作hash映射，后续再补充支持对中间路径名进行hash映射，补丁为<a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/0001-minix-support-long-file-name.patch"><code>0001-minix-support-long-file-name.patch</code></a>。</p>
<h1 id="lazy-umount"><span class="header-section-number">5</span> 文件系统延迟卸载</h1>
<h2 id="描述"><span class="header-section-number">5.1</span> 描述</h2>
<p>执行以下命令:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb48-1" title="1"><span class="ex">mkfs.ext2</span> -F /dev/sda</a>
<a class="sourceLine" id="cb48-2" title="2"><span class="fu">mount</span> -t ext2 /dev/sda /mnt</a>
<a class="sourceLine" id="cb48-3" title="3"><span class="bu">cd</span> /mnt <span class="kw">&amp;&amp;</span> <span class="ex">vim</span> file</a>
<a class="sourceLine" id="cb48-4" title="4"><span class="fu">umount</span> --lazy /mnt</a>
<a class="sourceLine" id="cb48-5" title="5"><span class="co"># 这时无法执行mkfs</span></a>
<a class="sourceLine" id="cb48-6" title="6"><span class="ex">mkfs.ext2</span> -F /dev/sda <span class="co"># /dev/sda is apparently in use by the system; will not make a filesystem here!</span></a></code></pre></div>
<p>这时，通用的一些命令如<code>df</code>、<code>mount</code>等看不到挂载实例，也无法看到哪些进程正在使用挂载点。</p>
<h2 id="调试"><span class="header-section-number">5.2</span> 调试</h2>
<p>通过命令<code>strace -o strace.txt -f -v -s 4096 df</code>和<code>strace -o strace.txt -f -v -s 4096 mount</code>可以知道，<code>df</code>、<code>mount</code>命令都是读取<code>/proc/self/mountinfo</code>文件。</p>
<p>以下命令查询进程:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb49-1" title="1"><span class="co"># +D：递归地列出指定目录下所有打开的文件</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="ex">lsof</span> +D /mnt <span class="co"># List Open Files</span></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="co"># -m：表示查询挂载点（而不仅仅是某个文件）</span></a>
<a class="sourceLine" id="cb49-4" title="4"><span class="fu">fuser</span> -mv /mnt <span class="co"># file user, 显示哪些进程正在访问特定文件、目录或文件系统</span></a></code></pre></div>
<p>正常<code>umount</code>的系统调用:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb50-1" title="1"><span class="ex">umount2</span>(<span class="st">&quot;/mnt&quot;</span>, 0)       = <span class="ex">0</span></a></code></pre></div>
<p><code>umount --lazy</code>的系统调用:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb51-1" title="1"><span class="ex">umount2</span>(<span class="st">&quot;/mnt&quot;</span>, MNT_DETACH)       = <span class="ex">0</span></a></code></pre></div>
<h3 id="未执行umount---lazy"><span class="header-section-number">5.2.1</span> 未执行<code>umount --lazy</code></h3>
<p><code>lsof +D /mnt</code>输出如下:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb52-1" title="1"><span class="ex">COMMAND</span>  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</a>
<a class="sourceLine" id="cb52-2" title="2"><span class="fu">bash</span>    2924 root  cwd    DIR    7,0     1024    2 /mnt</a>
<a class="sourceLine" id="cb52-3" title="3"><span class="ex">vim</span>     3038 root  cwd    DIR    7,0     1024    2 /mnt</a>
<a class="sourceLine" id="cb52-4" title="4"><span class="ex">vim</span>     3038 root    3u   REG    7,0    12288   15 /mnt/.file.swm</a></code></pre></div>
<p>通过<code>strace</code>命令可知，这些输出是通过以下方式获取:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb53-1" title="1"><span class="fu">ls</span> /proc/2924/cwd -lh <span class="co"># /proc/2924/cwd -&gt; /mnt</span></a>
<a class="sourceLine" id="cb53-2" title="2"><span class="fu">ls</span> /proc/3038/cwd -lh <span class="co"># /proc/3038/cwd -&gt; /mnt</span></a>
<a class="sourceLine" id="cb53-3" title="3"><span class="fu">ls</span> /proc/3038/fd/3 -lh <span class="co"># 3 -&gt; /mnt/.file.swm</span></a></code></pre></div>
<p><code>fuser -mv /mnt</code>输出如下:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb54-1" title="1">                     <span class="ex">USER</span>        PID ACCESS COMMAND</a>
<a class="sourceLine" id="cb54-2" title="2">/mnt:                <span class="ex">root</span>     kernel mount /mnt</a>
<a class="sourceLine" id="cb54-3" title="3">                     <span class="ex">root</span>       2924 ..c.. bash</a>
<a class="sourceLine" id="cb54-4" title="4">                     <span class="ex">root</span>       3038 F.c.. vim</a></code></pre></div>
<p>通过<code>strace</code>命令可知，这些输出是通过以下方式获取:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb55-1" title="1"><span class="fu">cat</span> /proc/mounts</a>
<a class="sourceLine" id="cb55-2" title="2"><span class="ex">statx</span>(0, <span class="st">&quot;/mnt&quot;</span>, ..., stx_mnt_id=0x46}) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb55-3" title="3"><span class="ex">statx</span>(0, <span class="st">&quot;/proc/2924/cwd&quot;</span>, ..., stx_mnt_id=0x46}) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb55-4" title="4"><span class="ex">statx</span>(0, <span class="st">&quot;/proc/3038/cwd&quot;</span>, ..., stx_mnt_id=0x46}) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb55-5" title="5"><span class="ex">statx</span>(0, <span class="st">&quot;/proc/3038/fd/3&quot;</span>, ..., stx_mnt_id=0x46}) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb55-6" title="6"></a>
<a class="sourceLine" id="cb55-7" title="7"><span class="fu">ls</span> /proc/3038/fd/3 -lh <span class="co"># 3 -&gt; /mnt/.file.swm</span></a></code></pre></div>
<h3 id="执行umount---lazy后"><span class="header-section-number">5.2.2</span> 执行<code>umount --lazy</code>后</h3>
<div class="sourceCode" id="cb56"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb56-1" title="1"><span class="fu">ls</span> /proc/2924/cwd -lh <span class="co"># /proc/2924/cwd -&gt; /</span></a>
<a class="sourceLine" id="cb56-2" title="2"><span class="fu">ls</span> /proc/3038/cwd -lh <span class="co"># /proc/3038/cwd -&gt; / , 如果是在/mnt/dir/下打开文件file，则指向/dir</span></a>
<a class="sourceLine" id="cb56-3" title="3"><span class="fu">ls</span> /proc/3038/fd/3 -lh <span class="co"># /proc/3038/fd/3 -&gt; /.file.swm</span></a></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb57-1" title="1"><span class="fu">cat</span> /proc/mounts</a>
<a class="sourceLine" id="cb57-2" title="2"><span class="ex">statx</span>(0, <span class="st">&quot;/&quot;</span>, ..., stx_mnt_id=0x16}) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb57-3" title="3"><span class="ex">statx</span>(0, <span class="st">&quot;/mnt&quot;</span>, ..., stx_mnt_id=0x16}) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb57-4" title="4"><span class="ex">statx</span>(0, <span class="st">&quot;/proc/2924/cwd&quot;</span>, ..., stx_mnt_id=0x46}) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb57-5" title="5"><span class="ex">statx</span>(0, <span class="st">&quot;/proc/3038/cwd&quot;</span>, ..., stx_mnt_id=0x46}) = <span class="ex">0</span></a>
<a class="sourceLine" id="cb57-6" title="6"><span class="ex">statx</span>(0, <span class="st">&quot;/proc/3038/fd/3&quot;</span>, ..., stx_mnt_id=0x46}) = <span class="ex">0</span></a></code></pre></div>
<h2 id="代码分析"><span class="header-section-number">5.3</span> 代码分析</h2>
<p>打开<code>/proc/self/mountinfo</code>和<code>/proc/mounts</code>涉及的函数:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb58-1" title="1">mountinfo_open</a>
<a class="sourceLine" id="cb58-2" title="2">  mounts_open_common</a>
<a class="sourceLine" id="cb58-3" title="3">    p-&gt;show = show_mountinfo</a>
<a class="sourceLine" id="cb58-4" title="4">      seq_printf(m, <span class="st">&quot;%i %i %u:%u &quot;</span>, r-&gt;mnt_id, ...</a>
<a class="sourceLine" id="cb58-5" title="5"></a>
<a class="sourceLine" id="cb58-6" title="6">mounts_open</a>
<a class="sourceLine" id="cb58-7" title="7">  mounts_open_common</a>
<a class="sourceLine" id="cb58-8" title="8">    p-&gt;show = show_vfsmnt</a></code></pre></div>
<p>读取内容时都涉及到<code>struct seq_operations mounts_op</code>。</p>
<p><code>ls /proc/5718/cwd -lh</code>的流程:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb59-1" title="1">do_readlinkat</a>
<a class="sourceLine" id="cb59-2" title="2">  vfs_readlink</a>
<a class="sourceLine" id="cb59-3" title="3">    proc_pid_readlink</a>
<a class="sourceLine" id="cb59-4" title="4">      proc_cwd_link</a></code></pre></div>
<p>正常<code>umount</code>流程:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb60-1" title="1">ksys_umount</a>
<a class="sourceLine" id="cb60-2" title="2">  path_umount</a>
<a class="sourceLine" id="cb60-3" title="3">    do_umount</a>
<a class="sourceLine" id="cb60-4" title="4">      <span class="cf">if</span> (flags &amp; MNT_DETACH) <span class="co">// 条件不满足</span></a>
<a class="sourceLine" id="cb60-5" title="5">      propagate_mount_busy <span class="co">// 如果挂载点正在被使用，在这里拦截，umount_tree()不执行</span></a>
<a class="sourceLine" id="cb60-6" title="6">      umount_tree(mnt, UMOUNT_PROPAGATE|UMOUNT_SYNC)</a></code></pre></div>
<p><code>umount --lazy</code>流程:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb61-1" title="1">ksys_umount</a>
<a class="sourceLine" id="cb61-2" title="2">  path_umount</a>
<a class="sourceLine" id="cb61-3" title="3">    do_umount</a>
<a class="sourceLine" id="cb61-4" title="4">      <span class="cf">if</span> (flags &amp; MNT_DETACH) <span class="co">// 条件满足</span></a>
<a class="sourceLine" id="cb61-5" title="5">      umount_tree(mnt, UMOUNT_PROPAGATE)</a>
<a class="sourceLine" id="cb61-6" title="6">        <span class="co">// move_from_ns()使用gdb调试时，要去掉inline，否则无法进断点</span></a>
<a class="sourceLine" id="cb61-7" title="7">        move_from_ns <span class="co">// 从红黑树中删除</span></a></code></pre></div>
<p>真正卸载流程:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb62-1" title="1">__cleanup_mnt</a>
<a class="sourceLine" id="cb62-2" title="2">  cleanup_mnt</a>
<a class="sourceLine" id="cb62-3" title="3">    deactivate_super</a>
<a class="sourceLine" id="cb62-4" title="4">      deactivate_locked_super</a>
<a class="sourceLine" id="cb62-5" title="5">        ext4_kill_sb <span class="co">// 具体文件系统</span></a>
<a class="sourceLine" id="cb62-6" title="6">    mnt_free_id <span class="co">// 释放mnt_id</span></a></code></pre></div>
<p>挂载加到红黑树的流程:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb63-1" title="1">fsmount</a>
<a class="sourceLine" id="cb63-2" title="2">  vfs_create_mount</a>
<a class="sourceLine" id="cb63-3" title="3">    alloc_vfsmnt</a>
<a class="sourceLine" id="cb63-4" title="4">      mnt_alloc_id <span class="co">// 分配mnt_id</span></a>
<a class="sourceLine" id="cb63-5" title="5">  mnt_add_to_ns</a>
<a class="sourceLine" id="cb63-6" title="6"></a>
<a class="sourceLine" id="cb63-7" title="7">move_mount</a>
<a class="sourceLine" id="cb63-8" title="8">  do_move_mount</a>
<a class="sourceLine" id="cb63-9" title="9">    attach_recursive_mnt</a>
<a class="sourceLine" id="cb63-10" title="10">      commit_tree</a>
<a class="sourceLine" id="cb63-11" title="11">        mnt_add_to_ns <span class="co">// 加到红黑树中</span></a></code></pre></div>
<h2 id="openeuler-overlayfs"><span class="header-section-number">5.4</span> openeuler overlayfs</h2>
<ul>
<li>TODO: 挂载第二次时，<code>ovl_free_fs() -&gt; wait_for_completion()</code>发生空指针解引用</li>
<li><a href="https://summer-ospp.ac.cn/2022/#/org/prodetail/22b970207">overlayfs 添加sysfs文件显示载挂载信息</a></li>
<li><a href="https://gitee.com/openeuler/kernel/issues/I5WIS5">issue</a></li>
<li><a href="https://gitee.com/openeuler/kernel/pulls/149/commits"><code>a5c8655cfb97 overlayfs: add sysfs file for OverlayFS</code></a></li>
</ul>
<p><code>openEuler-22.09</code>分支要回退<code>c1ad2f078e89 sign-file: Support SM signature</code>，还需要关闭配置<code>CONFIG_DEBUG_INFO_BTF</code>。</p>
<h3 id="使用-1"><span class="header-section-number">5.4.1</span> 使用</h3>
<p>overlayfs我以前没用过，先看看怎么使用:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb64-1" title="1"><span class="fu">mkdir</span> /mnt/lower <span class="co"># 存放只读数据</span></a>
<a class="sourceLine" id="cb64-2" title="2"><span class="fu">mkdir</span> /mnt/upper <span class="co"># 存放可写数据。</span></a>
<a class="sourceLine" id="cb64-3" title="3"><span class="fu">mkdir</span> /mnt/work  <span class="co"># 用于存储合并过程中的元数据</span></a>
<a class="sourceLine" id="cb64-4" title="4"><span class="fu">mkdir</span> /mnt/merged <span class="co"># 合并后的结果挂载点</span></a>
<a class="sourceLine" id="cb64-5" title="5"><span class="fu">mount</span> -t overlay ovl-name -o lowerdir=/mnt/lower,upperdir=/mnt/upper,workdir=/mnt/work /mnt/merged</a>
<a class="sourceLine" id="cb64-6" title="6"><span class="bu">echo</span> <span class="st">&quot;This is a file in lower&quot;</span> <span class="op">&gt;</span> /mnt/lower/lower_file.txt</a>
<a class="sourceLine" id="cb64-7" title="7"><span class="bu">echo</span> <span class="st">&quot;This is a file in upper&quot;</span> <span class="op">&gt;</span> /mnt/upper/upper_file.txt</a>
<a class="sourceLine" id="cb64-8" title="8"><span class="fu">ls</span> /mnt/merged</a>
<a class="sourceLine" id="cb64-9" title="9"><span class="bu">echo</span> <span class="st">&quot;Lower file is changed in merged&quot;</span> <span class="op">&gt;</span> /mnt/merged/lower_file.txt</a>
<a class="sourceLine" id="cb64-10" title="10"><span class="fu">cat</span> /mnt/lower/lower_file.txt <span class="co"># 没变</span></a>
<a class="sourceLine" id="cb64-11" title="11"><span class="fu">cat</span> /mnt/merged/lower_file.txt <span class="co"># 变了</span></a></code></pre></div>
<p>再来看<a href="https://gitee.com/openeuler/kernel/issues/I5WIS5">overlayfs 添加sysfs文件显示载挂载信息</a>的测试:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb65-1" title="1"><span class="ex">tree</span> /sys/fs/overlayfs/</a>
<a class="sourceLine" id="cb65-2" title="2"><span class="co"># /sys/fs/overlayfs/</span></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="co"># └── merge_0_36</span></a>
<a class="sourceLine" id="cb65-4" title="4"><span class="co">#     ├── lower</span></a>
<a class="sourceLine" id="cb65-5" title="5"><span class="co">#     ├── merge</span></a>
<a class="sourceLine" id="cb65-6" title="6"><span class="co">#     ├── upper</span></a>
<a class="sourceLine" id="cb65-7" title="7"><span class="co">#     └── work</span></a>
<a class="sourceLine" id="cb65-8" title="8"><span class="fu">cat</span> /sys/fs/overlayfs/merge_0_36/lower <span class="co"># /mnt/lower</span></a>
<a class="sourceLine" id="cb65-9" title="9"><span class="fu">cat</span> /sys/fs/overlayfs/merge_0_36/upper <span class="co"># /mnt/upper</span></a>
<a class="sourceLine" id="cb65-10" title="10"><span class="fu">cat</span> /sys/fs/overlayfs/merge_0_36/work <span class="co"># /mnt/work</span></a>
<a class="sourceLine" id="cb65-11" title="11"><span class="fu">cat</span> /sys/fs/overlayfs/merge_0_36/merge <span class="co"># /mnt/merged</span></a>
<a class="sourceLine" id="cb65-12" title="12"><span class="bu">cd</span> /mnt/merged</a>
<a class="sourceLine" id="cb65-13" title="13"><span class="fu">umount</span> --lazy /mnt/merged</a>
<a class="sourceLine" id="cb65-14" title="14"><span class="ex">tree</span> /sys/fs/overlayfs/ <span class="co"># 还能看到和原来一样的输出</span></a>
<a class="sourceLine" id="cb65-15" title="15"><span class="bu">cd</span></a>
<a class="sourceLine" id="cb65-16" title="16"><span class="ex">tree</span> /sys/fs/overlayfs/ <span class="co"># 已经看不到输出</span></a></code></pre></div>
<h3 id="代码分析-1"><span class="header-section-number">5.4.2</span> 代码分析</h3>
<div class="sourceCode" id="cb66"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb66-1" title="1">mount</a>
<a class="sourceLine" id="cb66-2" title="2">  do_mount</a>
<a class="sourceLine" id="cb66-3" title="3">    path_mount</a>
<a class="sourceLine" id="cb66-4" title="4">      do_new_mount</a>
<a class="sourceLine" id="cb66-5" title="5">        ovl_mount_end</a>
<a class="sourceLine" id="cb66-6" title="6">          ovl_register_sysfs</a>
<a class="sourceLine" id="cb66-7" title="7">          ovl_mergedir_backup</a>
<a class="sourceLine" id="cb66-8" title="8"></a>
<a class="sourceLine" id="cb66-9" title="9">__cleanup_mnt</a>
<a class="sourceLine" id="cb66-10" title="10">  cleanup_mnt</a>
<a class="sourceLine" id="cb66-11" title="11">    deactivate_super</a>
<a class="sourceLine" id="cb66-12" title="12">      deactivate_locked_super</a>
<a class="sourceLine" id="cb66-13" title="13">        kill_anon_super</a>
<a class="sourceLine" id="cb66-14" title="14">          generic_shutdown_super</a>
<a class="sourceLine" id="cb66-15" title="15">            ovl_put_super</a>
<a class="sourceLine" id="cb66-16" title="16">              ovl_free_fs</a>
<a class="sourceLine" id="cb66-17" title="17">                kobject_put</a>
<a class="sourceLine" id="cb66-18" title="18">                  kref_put</a>
<a class="sourceLine" id="cb66-19" title="19">                    kobject_release</a>
<a class="sourceLine" id="cb66-20" title="20">                      kobject_cleanup</a>
<a class="sourceLine" id="cb66-21" title="21">                        ovl_kobj_release</a>
<a class="sourceLine" id="cb66-22" title="22">                          complete(&amp;ofs-&gt;kobj_unregister)</a></code></pre></div>
</body>
</html>
