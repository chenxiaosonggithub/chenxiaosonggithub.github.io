<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>中断</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://chenxiaosong.com/stylesheet.css" />
</head>
<body>
<header id="title-block-header">
<!-- sign begin -->
<ul>
<li>作者: 陈孝松</li>
<li><a href="https://chenxiaosong.com/">中文主页: chenxiaosong.com</a></li>
<li><a href="https://chenxiaosong.com/en">英文主页: chenxiaosong.com/en</a></li>
<li><a href="https://chenxiaosong.com/video.html">哔哩哔哩教学视频: 陈孝松</a></li>
<li><a href="https://chenxiaosong.com/course.html">课程: chenxiaosong.com/course</a></li>
<li><a href="https://chenxiaosong.com/blog.html">博客: chenxiaosong.com/blog</a></li>
<li><a href="https://chenxiaosong.com/contribution.html">贡献: chenxiaosong.com/contribution</a></li>
<li>邮箱: <a href="mailto:chenxiaosong@chenxiaosong.com" class="email">chenxiaosong@chenxiaosong.com</a></li>
<li><a href="https://chenxiaosong.com/q.html">QQ交流群: 544216206, 点击查看群介绍</a></li>
</ul>
<!-- sign end -->
<h1 class="title">中断</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#几个概念"><span class="toc-section-number">1</span> 几个概念</a></li>
<li><a href="#中断简介"><span class="toc-section-number">2</span> 中断简介</a></li>
<li><a href="#中断处理程序"><span class="toc-section-number">3</span> 中断处理程序</a><ul>
<li><a href="#注册中断处理程序"><span class="toc-section-number">3.1</span> 注册中断处理程序</a></li>
<li><a href="#释放中断处理程序"><span class="toc-section-number">3.2</span> 释放中断处理程序</a></li>
<li><a href="#编写中断处理程序"><span class="toc-section-number">3.3</span> 编写中断处理程序</a></li>
<li><a href="#中断处理程序的实现"><span class="toc-section-number">3.4</span> 中断处理程序的实现</a></li>
</ul></li>
<li><a href="#procinterrupts"><span class="toc-section-number">4</span> <code>/proc/interrupts</code></a></li>
<li><a href="#中断控制"><span class="toc-section-number">5</span> 中断控制</a></li>
<li><a href="#下半部"><span class="toc-section-number">6</span> 下半部</a><ul>
<li><a href="#软中断"><span class="toc-section-number">6.1</span> 软中断</a></li>
<li><a href="#tasklet"><span class="toc-section-number">6.2</span> tasklet</a></li>
<li><a href="#工作队列"><span class="toc-section-number">6.3</span> 工作队列</a></li>
<li><a href="#threaded_irq"><span class="toc-section-number">6.4</span> <code>threaded_irq</code></a></li>
</ul></li>
</ul>
</nav>
<p><a href="https://chenxiaosong.com/course/kernel/kernel.html">点击跳转到内核课程所有目录</a>。</p>
<p><a href="https://chenxiaosong.com/course/kernel/video.html">点击这里查看配套的教学视频</a>。</p>
<h1 id="几个概念"><span class="header-section-number">1</span> 几个概念</h1>
<ul>
<li>中断（interrupt）: 定义为一个事件，该事件改变cpu执行的指令顺序，分为同步中断和异步中断。同步（synchronous）中断: 只有在一条指令终止执行后cpu才会发出中断，同步中断称为异常。异步（asynchronous）中断: 由其他硬件设备随机产生的，如间隔定时器或I/O设备。一般我们所说的中断特指异步中断，也叫硬中断(hardirq)。
<ul>
<li>可屏蔽中断（maskable interrupt）: I/O设备发出的所有中断请求都产生可屏蔽中断，控制单元忽略处理屏蔽状态（masked）的中断。</li>
<li>不可屏蔽中断（nonmaskable interrupt）: 只有几个危急事件（如硬件故障）才引起不可屏蔽中断。</li>
</ul></li>
<li>异常（exception）: 由程序的错误（处理器本身）产生，或由内核必须处理的异常（如缺页）条件产生的。
<ul>
<li>处理器探测异常（processor-detected exception）: cpu执行指令时探测到的反常条件所产生的异常。根据cpu产生异常时保存在x86的<code>eip</code>寄存器或arm64的<code>pc</code>寄存器中的值，可以分为3组:
<ul>
<li>故障（fault）: 保存在x86的<code>eip</code>寄存器或arm64的<code>pc</code>寄存器中的值是引起故障的指令地址，异常处理程序执行完后，那条指令重新执行，如缺页异常，纠正引起缺页异常的反常条件后重新执行同一指令。</li>
<li>陷阱（trap）: 保存在x86的<code>eip</code>寄存器或arm64的<code>pc</code>寄存器中的值是随后要执行的指令地址，只有当没有必要重新执行已终止的指令时，才触发陷阱，陷阱的主要用途是为了调试程序。</li>
<li>异常中止（abort）: x86的<code>eip</code>寄存器或arm64的<code>pc</code>寄存器中不能保存引起异常的指令所在的确切位置，用于报告严重的错误，如硬件故障或系统表中无效的值或不一致的值。异常终止处理程序只能终止进程，别无选择。</li>
</ul></li>
<li>编程异常（programmed exception）: 编程者发出请求时发生。以下几种情况会发生编程异常: x86下<code>int</code>（用于触发中断）和<code>int3</code>（触发特定的中断3，用于断点），arm64的<code>SVC</code>（对应x86的<code>int</code>）和<code>BRK</code>（对应x86的<code>int3</code>），以及x86下的<code>into</code>（检查溢出）和<code>bound</code>（检查地址出界）指令检查的条件不为真时。控制单元把编程异常作为陷阱来处理，也叫软件中断（software interrupt），注意软件中断和中断下半部的软中断（softirq）不是一个概念，编程异常有两种用途: 执行系统调用和给调试程序通报一个特定的事件。</li>
</ul></li>
</ul>
<h1 id="中断简介"><span class="header-section-number">2</span> 中断简介</h1>
<p>连接到计算机的硬件有很多，如硬盘、鼠标、键盘等，cpu的速度比这些外围硬件设备高出几个数量级，轮询（polling）会让内核做很多无用功，所以需要中断这种机制让硬件在需要时通知内核。中断本质上是一种电信号，硬件设备在生成中断时不考虑与cpu的时钟同步，也就是中断随时可以产生，内核随时可能会被新来的中断打断。硬件设备产生的电信号直接送入中断控制器（interrupt controller unit，简单的电子芯片）的输入引脚。不同设备对应的中断不同，每个中断对应一个中断号，又叫中断请求（Interrupt ReQuest，IRQ）线，但有些中断号是动态分配的，如连接在PCI（Peripheral Component Interconnect）总线上的设备。</p>
<p>进程上下文（process context）是一种内核所处的操作模式，此时内核代表进程执行，如执行系统调用或运行内核线程，可以通过<code>current</code>宏关联当前进程，进程上下文中可以睡眠，也可以调用调度器。</p>
<p>响应中断时，内核会执行一个函数，这个函数叫中断处理程序（interrupt handler）或中断服务例程（interrupt service routine，ISR），中断处理程序处理要非常快。执行中断处理程序时，内核处于中断上下文（interrupt context），又叫原子上下文中，不可阻塞，<code>current</code>宏指向被中断的进程，中断上下文中不可睡眠，中断栈的大小定义在<code>IRQ_STACK_SIZE</code>。</p>
<p>中断处理程序中要处理得快，完成的工作量就受限，所以把中断处理分为上半部（top half）和下半部（bottom half）。上半部做有严格时限的工作，如对中断应答或复位硬件，这时所有中断都被禁止。能稍后完成的工作推迟到下半部。</p>
<p>另外，曾经有次面试被问到“Linux内核是否支持中断嵌套“，正确答案是”不支持“，我当时回答错了呢。中断嵌套是指高优先级中断可以抢占正在执行的低优先级中断。</p>
<h1 id="中断处理程序"><span class="header-section-number">3</span> 中断处理程序</h1>
<h2 id="注册中断处理程序"><span class="header-section-number">3.1</span> 注册中断处理程序</h2>
<p>通过<code>request_irq()</code>注册一个中断处理程序，注意<code>request_irq()</code>函数会睡眠:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"> * request_irq - 为中断线添加处理程序</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"> * </span><span class="an">@irq:</span><span class="co">        要分配的中断线（中断号）</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="co"> * </span><span class="an">@handler:</span><span class="co">    当IRQ发生时调用的函数。</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co"> *              线程中断的主要处理程序</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co"> *              如果为NULL，将安装默认的主要处理程序</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co"> * </span><span class="an">@flags:</span><span class="co">      处理标志</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="co"> * </span><span class="an">@name</span><span class="do">:</span><span class="co">       </span><span class="do">产生此中断的设备名称，会被/proc/irq/和/proc/interrupts使用</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co"> * </span><span class="an">@dev:</span><span class="co">        传递给处理函数的cookie，用于共享中断线，一般会传递驱动程序的设备结构</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co"> *</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co"> * 此调用分配一个中断并建立一个处理程序；有关详细信息，请参见</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co"> * request_threaded_irq()的文档。</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co"> * Return: 成功时返回0，常见错误为-EBUSY，表示给定中断线已经在使用，或没有指定IRQF_SHARED</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co"> */</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span> __must_check</a>
<a class="sourceLine" id="cb1-16" title="16">request_irq(<span class="dt">unsigned</span> <span class="dt">int</span> irq, irq_handler_t handler, <span class="dt">unsigned</span> <span class="dt">long</span> flags,</a>
<a class="sourceLine" id="cb1-17" title="17">            <span class="dt">const</span> <span class="dt">char</span> *name, <span class="dt">void</span> *dev)</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">// devm: managed device</span></a>
<a class="sourceLine" id="cb1-20" title="20"><span class="co">// 类似垃圾回收机制，不需要调用free_irq()</span></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="co">// 请参考补丁[at86rf230: use devm_request_irq](https://lore.kernel.org/all/1398359358-11085-5-git-send-email-alex.aring@gmail.com/)</span></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="dt">static</span> <span class="kw">inline</span> <span class="dt">int</span> __must_check</a>
<a class="sourceLine" id="cb1-23" title="23">devm_request_irq(<span class="kw">struct</span> device *dev, <span class="dt">unsigned</span> <span class="dt">int</span> irq, irq_handler_t handler,</a>
<a class="sourceLine" id="cb1-24" title="24">                 <span class="dt">unsigned</span> <span class="dt">long</span> irqflags, <span class="dt">const</span> <span class="dt">char</span> *devname, <span class="dt">void</span> *dev_id)</a></code></pre></div>
<p><code>irq_handler_t handler</code>参数的的定义如下:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// include/linux/interrupt.h</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">typedef</span> irqreturn_t (*irq_handler_t)(<span class="dt">int</span>, <span class="dt">void</span> *);</a></code></pre></div>
<p><code>flags</code>参数可以为<code>0</code>，也可能是以下值:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co"> * 这些对应于 linux/ioport.h 中的 IORESOURCE_IRQ_*(IORESOURCE_IRQ_HIGHEDGE等) 定义，</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co"> * 用于选择中断线行为。当请求一个中断而未指定 IRQF_TRIGGER 时，</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="co"> * 应假定设置为“已配置”，这可能是根据机器或固件初始化。</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="co"> */</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="pp">#define IRQF_TRIGGER_NONE       0x00000000</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="pp">#define IRQF_TRIGGER_RISING     0x00000001</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="pp">#define IRQF_TRIGGER_FALLING    0x00000002</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="pp">#define IRQF_TRIGGER_HIGH       0x00000004</span></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="pp">#define IRQF_TRIGGER_LOW        0x00000008</span></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="pp">#define IRQF_TRIGGER_MASK       (IRQF_TRIGGER_HIGH | IRQF_TRIGGER_LOW | \</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="pp">                                 IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)</span></a>
<a class="sourceLine" id="cb3-13" title="13"><span class="pp">#define IRQF_TRIGGER_PROBE      0x00000010</span></a>
<a class="sourceLine" id="cb3-14" title="14"></a>
<a class="sourceLine" id="cb3-15" title="15"><span class="co">/*</span></a>
<a class="sourceLine" id="cb3-16" title="16"><span class="co"> * 这些标志仅由内核作为中断处理例程的一部分使用。</span></a>
<a class="sourceLine" id="cb3-17" title="17"><span class="co"> *</span></a>
<a class="sourceLine" id="cb3-18" title="18"><span class="co"> * IRQF_SHARED - 允许多个设备共享中断</span></a>
<a class="sourceLine" id="cb3-19" title="19"><span class="co"> * IRQF_PROBE_SHARED - 当调用者预计会发生共享不匹配时设置</span></a>
<a class="sourceLine" id="cb3-20" title="20"><span class="co"> * IRQF_TIMER - 标记此中断为定时器中断的标志</span></a>
<a class="sourceLine" id="cb3-21" title="21"><span class="co"> * IRQF_PERCPU - 中断是每个 CPU 的</span></a>
<a class="sourceLine" id="cb3-22" title="22"><span class="co"> * IRQF_NOBALANCING - 排除此中断进行中断平衡的标志</span></a>
<a class="sourceLine" id="cb3-23" title="23"><span class="co"> * IRQF_IRQPOLL - 中断用于轮询（在共享中断中，仅第一个注册的中断</span></a>
<a class="sourceLine" id="cb3-24" title="24"><span class="co"> *                出于性能原因被考虑）</span></a>
<a class="sourceLine" id="cb3-25" title="25"><span class="co"> * IRQF_ONESHOT - 硬中断处理程序完成后不会重新使能中断。</span></a>
<a class="sourceLine" id="cb3-26" title="26"><span class="co"> *                用于需要保持中断线禁用的线程中断，直到</span></a>
<a class="sourceLine" id="cb3-27" title="27"><span class="co"> *                线程处理程序运行。</span></a>
<a class="sourceLine" id="cb3-28" title="28"><span class="co"> * IRQF_NO_SUSPEND - 在挂起期间不禁用此中断。并不保证</span></a>
<a class="sourceLine" id="cb3-29" title="29"><span class="co"> *                   此中断会唤醒系统从挂起状态。见 Documentation/power/suspend-and-interrupts.rst</span></a>
<a class="sourceLine" id="cb3-30" title="30"><span class="co"> * IRQF_FORCE_RESUME - 在恢复时强制启用，即使设置了 IRQF_NO_SUSPEND</span></a>
<a class="sourceLine" id="cb3-31" title="31"><span class="co"> * IRQF_NO_THREAD - 中断不能被线程化</span></a>
<a class="sourceLine" id="cb3-32" title="32"><span class="co"> * IRQF_EARLY_RESUME - 在 syscore 期间尽早恢复 IRQ，而不是在设备</span></a>
<a class="sourceLine" id="cb3-33" title="33"><span class="co"> *                恢复时。</span></a>
<a class="sourceLine" id="cb3-34" title="34"><span class="co"> * IRQF_COND_SUSPEND - 如果 IRQ 与 NO_SUSPEND 用户共享，在挂起中断后执行此</span></a>
<a class="sourceLine" id="cb3-35" title="35"><span class="co"> *                中断处理程序。对于系统唤醒设备，用户需要在</span></a>
<a class="sourceLine" id="cb3-36" title="36"><span class="co"> *                他们的中断处理程序中实现唤醒检测。</span></a>
<a class="sourceLine" id="cb3-37" title="37"><span class="co"> * IRQF_NO_AUTOEN - 用户请求时不要自动启用 IRQ 或 NMI。</span></a>
<a class="sourceLine" id="cb3-38" title="38"><span class="co"> *                用户稍后将通过 enable_irq() 或 enable_nmi()</span></a>
<a class="sourceLine" id="cb3-39" title="39"><span class="co"> *                显式启用它。</span></a>
<a class="sourceLine" id="cb3-40" title="40"><span class="co"> * IRQF_NO_DEBUG - 在逃逸检测中排除 IPI 和类似处理程序，</span></a>
<a class="sourceLine" id="cb3-41" title="41"><span class="co"> *                 取决于 IRQF_PERCPU。</span></a>
<a class="sourceLine" id="cb3-42" title="42"><span class="co"> */</span></a>
<a class="sourceLine" id="cb3-43" title="43"><span class="pp">#define IRQF_SHARED             0x00000080</span></a>
<a class="sourceLine" id="cb3-44" title="44"><span class="pp">#define IRQF_PROBE_SHARED       0x00000100</span></a>
<a class="sourceLine" id="cb3-45" title="45"><span class="pp">#define __IRQF_TIMER            0x00000200</span></a>
<a class="sourceLine" id="cb3-46" title="46"><span class="pp">#define IRQF_PERCPU             0x00000400</span></a>
<a class="sourceLine" id="cb3-47" title="47"><span class="pp">#define IRQF_NOBALANCING        0x00000800</span></a>
<a class="sourceLine" id="cb3-48" title="48"><span class="pp">#define IRQF_IRQPOLL            0x00001000</span></a>
<a class="sourceLine" id="cb3-49" title="49"><span class="pp">#define IRQF_ONESHOT            0x00002000</span></a>
<a class="sourceLine" id="cb3-50" title="50"><span class="pp">#define IRQF_NO_SUSPEND         0x00004000</span></a>
<a class="sourceLine" id="cb3-51" title="51"><span class="pp">#define IRQF_FORCE_RESUME       0x00008000</span></a>
<a class="sourceLine" id="cb3-52" title="52"><span class="pp">#define IRQF_NO_THREAD          0x00010000</span></a>
<a class="sourceLine" id="cb3-53" title="53"><span class="pp">#define IRQF_EARLY_RESUME       0x00020000</span></a>
<a class="sourceLine" id="cb3-54" title="54"><span class="pp">#define IRQF_COND_SUSPEND       0x00040000</span></a>
<a class="sourceLine" id="cb3-55" title="55"><span class="pp">#define IRQF_NO_AUTOEN          0x00080000</span></a>
<a class="sourceLine" id="cb3-56" title="56"><span class="pp">#define IRQF_NO_DEBUG           0x00100000</span></a>
<a class="sourceLine" id="cb3-57" title="57"></a>
<a class="sourceLine" id="cb3-58" title="58"><span class="pp">#define IRQF_TIMER              (__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)</span></a></code></pre></div>
<h2 id="释放中断处理程序"><span class="header-section-number">3.2</span> 释放中断处理程序</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co"> *      free_irq - 释放通过 request_irq 分配的中断</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co"> *      </span><span class="an">@irq:</span><span class="co"> 要释放的中断线</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"> *      </span><span class="an">@dev_id:</span><span class="co"> 设备标识以释放</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co"> *</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co"> *      移除中断处理程序。如果中断线不再被任何驱动程序使用，</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co"> *      则将其禁用。在共享 IRQ 的情况下，调用者必须确保在调用</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co"> *      此函数之前，在其驱动的卡上禁用中断。该函数在此 IRQ</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="co"> *      的任何正在执行的中断完成之前不会返回。</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="co"> *</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="co"> *      此函数不得在中断上下文中调用。必须从进程上下文中调用。</span></a>
<a class="sourceLine" id="cb4-12" title="12"><span class="co"> *</span></a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co"> *      返回传递给 request_irq 的 devname 参数。</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co"> */</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="dt">const</span> <span class="dt">void</span> *free_irq(<span class="dt">unsigned</span> <span class="dt">int</span> irq, <span class="dt">void</span> *dev_id)</a></code></pre></div>
<h2 id="编写中断处理程序"><span class="header-section-number">3.3</span> 编写中断处理程序</h2>
<p>举个例子:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">static</span> irqreturn_t tg3_test_isr(<span class="dt">int</span> irq, <span class="dt">void</span> *dev_id)</a></code></pre></div>
<p>返回值定义如下:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="co"> * enum irqreturn - irqreturn 类型值，可以使用IRQ_RETVAL(x)将其他值转换为枚举值</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="co"> * </span><span class="an">@IRQ_NONE:</span><span class="co">           中断不是来自此设备或未被处理</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="co"> * </span><span class="an">@IRQ_HANDLED:</span><span class="co">        中断已被此设备处理</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co"> * </span><span class="an">@IRQ_WAKE_THREAD:</span><span class="co">    处理程序请求唤醒处理程序线程</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="co"> */</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">enum</span> irqreturn {</a>
<a class="sourceLine" id="cb6-8" title="8">        IRQ_NONE                = (<span class="dv">0</span> &lt;&lt; <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb6-9" title="9">        IRQ_HANDLED             = (<span class="dv">1</span> &lt;&lt; <span class="dv">0</span>),</a>
<a class="sourceLine" id="cb6-10" title="10">        IRQ_WAKE_THREAD         = (<span class="dv">1</span> &lt;&lt; <span class="dv">1</span>),</a>
<a class="sourceLine" id="cb6-11" title="11">};</a></code></pre></div>
<p>中断处理程序在执行时，相应的中断线在所有cpu上都会被屏幕，但其他中断都是打开的。</p>
<p>共享的中断处理程序如下:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1"><span class="co">// 共享的中断处理程序的dev参数不能传NULL，一般传设备结构的指针</span></a>
<a class="sourceLine" id="cb7-2" title="2">err = request_irq(tnapi-&gt;irq_vec, tg3_test_isr,  </a>
<a class="sourceLine" id="cb7-3" title="3">                  IRQF_SHARED, dev-&gt;name, tnapi);</a></code></pre></div>
<p>非共享的中断处理程序如下:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb8-1" title="1">retval = request_irq(rtc_irq, efw,</a>
<a class="sourceLine" id="cb8-2" title="2">                <span class="dv">0</span>, dev_name(&amp;cmos_rtc.rtc-&gt;dev),</a>
<a class="sourceLine" id="cb8-3" title="3">                cmos_rtc.rtc);</a></code></pre></div>
<h2 id="中断处理程序的实现"><span class="header-section-number">3.4</span> 中断处理程序的实现</h2>
<p>中断处理系统的实现依赖于cpu、中断控制器的类型、体系结构的设计、机器本身。</p>
<p>中断从硬件到内核的路径:</p>
<ul>
<li>硬件产生一个中断，通过总线把电信号发给中断控制器（interrupt controller unit）。</li>
<li>中断控制器把中断发给cpu。</li>
<li>cpu中断内核。</li>
</ul>
<p>x86系统结构下函数流程如下:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1">common_interrupt</a>
<a class="sourceLine" id="cb9-2" title="2">  __common_interrupt</a>
<a class="sourceLine" id="cb9-3" title="3">    handle_irq</a>
<a class="sourceLine" id="cb9-4" title="4">      generic_handle_irq_desc</a>
<a class="sourceLine" id="cb9-5" title="5">        handle_edge_irq</a>
<a class="sourceLine" id="cb9-6" title="6">          handle_irq_event</a>
<a class="sourceLine" id="cb9-7" title="7">            handle_irq_event_percpu</a>
<a class="sourceLine" id="cb9-8" title="8">              __handle_irq_event_percpu</a>
<a class="sourceLine" id="cb9-9" title="9">              add_interrupt_randomness</a></code></pre></div>
<h1 id="procinterrupts"><span class="header-section-number">4</span> <code>/proc/interrupts</code></h1>
<p>为了便于观察，我们以单核cpu为例:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1">           <span class="ex">CPU0</span>       </a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="ex">0</span>:         56   IO-APIC   2-edge      timer</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="ex">1</span>:          9   IO-APIC   1-edge      i8042</a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="ex">4</span>:        546   IO-APIC   4-edge      ttyS0</a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="ex">8</span>:          1   IO-APIC   8-edge      rtc0</a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="ex">9</span>:          0   IO-APIC   9-fasteoi   acpi</a>
<a class="sourceLine" id="cb10-7" title="7"> <span class="ex">12</span>:         15   IO-APIC  12-edge      i8042</a>
<a class="sourceLine" id="cb10-8" title="8"> <span class="ex">24</span>:          0  PCI-MSIX-0000:00:05.0   0-edge      virtio3-config</a>
<a class="sourceLine" id="cb10-9" title="9"> <span class="ex">25</span>:       1710  PCI-MSIX-0000:00:05.0   1-edge      virtio3-req.0</a>
<a class="sourceLine" id="cb10-10" title="10"> <span class="ex">26</span>:          0  PCI-MSIX-0000:00:04.0   0-edge      virtio2-config</a>
<a class="sourceLine" id="cb10-11" title="11"> <span class="ex">27</span>:          0  PCI-MSIX-0000:00:04.0   1-edge      virtio2-control</a>
<a class="sourceLine" id="cb10-12" title="12"> <span class="ex">28</span>:          0  PCI-MSIX-0000:00:04.0   2-edge      virtio2-event</a>
<a class="sourceLine" id="cb10-13" title="13"> <span class="ex">29</span>:        322  PCI-MSIX-0000:00:04.0   3-edge      virtio2-request</a>
<a class="sourceLine" id="cb10-14" title="14"> <span class="ex">30</span>:          0  PCI-MSIX-0000:00:02.0   0-edge      virtio0-config</a>
<a class="sourceLine" id="cb10-15" title="15"> <span class="ex">31</span>:         54  PCI-MSIX-0000:00:02.0   1-edge      virtio0-input.0</a>
<a class="sourceLine" id="cb10-16" title="16"> <span class="ex">32</span>:         81  PCI-MSIX-0000:00:02.0   2-edge      virtio0-output.0</a>
<a class="sourceLine" id="cb10-17" title="17"> <span class="ex">33</span>:          0  PCI-MSIX-0000:00:03.0   0-edge      virtio1-config</a>
<a class="sourceLine" id="cb10-18" title="18"> <span class="ex">34</span>:          0  PCI-MSIX-0000:00:03.0   1-edge      virtio1-requests</a>
<a class="sourceLine" id="cb10-19" title="19"><span class="ex">NMI</span>:          0   Non-maskable interrupts</a>
<a class="sourceLine" id="cb10-20" title="20"><span class="ex">LOC</span>:       2937   Local timer interrupts</a>
<a class="sourceLine" id="cb10-21" title="21"><span class="ex">SPU</span>:          0   Spurious interrupts</a>
<a class="sourceLine" id="cb10-22" title="22"><span class="ex">PMI</span>:          0   Performance monitoring interrupts</a>
<a class="sourceLine" id="cb10-23" title="23"><span class="ex">IWI</span>:          0   IRQ work interrupts</a>
<a class="sourceLine" id="cb10-24" title="24"><span class="ex">RTR</span>:          0   APIC ICR read retries</a>
<a class="sourceLine" id="cb10-25" title="25"><span class="ex">RES</span>:          0   Rescheduling interrupts</a>
<a class="sourceLine" id="cb10-26" title="26"><span class="ex">CAL</span>:          0   Function call interrupts</a>
<a class="sourceLine" id="cb10-27" title="27"><span class="ex">TLB</span>:          0   TLB shootdowns</a>
<a class="sourceLine" id="cb10-28" title="28"><span class="ex">TRM</span>:          0   Thermal event interrupts</a>
<a class="sourceLine" id="cb10-29" title="29"><span class="ex">THR</span>:          0   Threshold APIC interrupts</a>
<a class="sourceLine" id="cb10-30" title="30"><span class="ex">DFR</span>:          0   Deferred Error APIC interrupts</a>
<a class="sourceLine" id="cb10-31" title="31"><span class="ex">MCE</span>:          0   Machine check exceptions</a>
<a class="sourceLine" id="cb10-32" title="32"><span class="ex">MCP</span>:          1   Machine check polls</a>
<a class="sourceLine" id="cb10-33" title="33"><span class="ex">HYP</span>:          1   Hypervisor callback interrupts</a>
<a class="sourceLine" id="cb10-34" title="34"><span class="ex">ERR</span>:          0</a>
<a class="sourceLine" id="cb10-35" title="35"><span class="ex">MIS</span>:          0</a>
<a class="sourceLine" id="cb10-36" title="36"><span class="ex">PIN</span>:          0   Posted-interrupt notification event</a>
<a class="sourceLine" id="cb10-37" title="37"><span class="ex">NPI</span>:          0   Nested posted-interrupt event</a>
<a class="sourceLine" id="cb10-38" title="38"><span class="ex">PIW</span>:          0   Posted-interrupt wakeup event</a></code></pre></div>
<ul>
<li>第一列: 中断线。</li>
<li>第二列: 接收中断数目的计数器。</li>
<li>第三列: 中断控制器。</li>
<li>第四列: 设备名称，也就是<code>request_irq()</code>的<code>name</code>参数。如果中断是共享的，则所有设备名都会列出来，以逗号分隔。</li>
</ul>
<p>相关函数流程:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1">call_read_iter</a>
<a class="sourceLine" id="cb11-2" title="2">  proc_reg_read_iter</a>
<a class="sourceLine" id="cb11-3" title="3">    seq_read_iter</a>
<a class="sourceLine" id="cb11-4" title="4">      show_interrupts</a></code></pre></div>
<h1 id="中断控制"><span class="header-section-number">5</span> 中断控制</h1>
<p>控制中断系统是为了提供同步，通过禁止中断，可以确保某个中断处理程序不会抢占当前代码，还可以禁止内核抢占，但不能防止其他cpu的并发访问，禁止中断只能防止其他中断处理程序的并发访问。</p>
<p>禁止和激活当前处理器的本地中断，可以在中断上下文和进程上下文中使用:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1">local_irq_disable(); <span class="co">// 禁止当前cpu本地中断</span></a>
<a class="sourceLine" id="cb12-2" title="2">local_irq_enable(); <span class="co">// 激活当前cpu本地中断</span></a></code></pre></div>
<p>激活时恢复到原来的状态，可以在中断上下文和进程上下文中使用:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="dt">unsigned</span> <span class="dt">long</span> flags;</a>
<a class="sourceLine" id="cb13-2" title="2">local_irq_save(flags); <span class="co">// 禁止中断</span></a>
<a class="sourceLine" id="cb13-3" title="3">local_irq_restore(flags); <span class="co">// 中断恢复到原来的状态</span></a></code></pre></div>
<p>禁止（屏蔽掉，masking out）指定中断线，可以在中断上下文和进程上下文中使用，多个中断处理程序共享的中断线，不能用这些接口禁止中断。:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="co">// 禁止所有处理器指定的中断线，等待当前中断处理程序执行完</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="dt">void</span> disable_irq(<span class="dt">unsigned</span> <span class="dt">int</span> irq)</a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co">// 禁止所有处理器指定的中断线，不会等待当前中断处理程序执行完</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="dt">void</span> disable_irq_nosync(<span class="dt">unsigned</span> <span class="dt">int</span> irq)</a>
<a class="sourceLine" id="cb14-5" title="5"><span class="co">// 激活所有处理器指定的中断线，嵌套时最后一次调用enable_irq时才真正激活中断线</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="dt">void</span> enable_irq(<span class="dt">unsigned</span> <span class="dt">int</span> irq)</a>
<a class="sourceLine" id="cb14-7" title="7"><span class="co">// 等待特定的中断处理程序的退出</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="dt">void</span> synchronize_irq(<span class="dt">unsigned</span> <span class="dt">int</span> irq)</a></code></pre></div>
<p>查询中断系统的状态:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb15-1" title="1"><span class="co">// 本地cpu上的中断系统被禁止返回非0，否则返回0</span></a>
<a class="sourceLine" id="cb15-2" title="2">irqs_disabled()</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="co">/*</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="co"> * 宏用于检索当前执行上下文：</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="co"> *</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="co"> * in_nmi()             - 我们处于 NMI 上下文，Non-Maskable Interrupt 非屏蔽中断，一种高优先级中断，通常用于处理紧急事件，如硬件故障或性能监控</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="co"> * in_hardirq()         - 我们处于硬 IRQ 上下文</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="co"> * in_serving_softirq() - 我们处于 softirq 上下文</span></a>
<a class="sourceLine" id="cb15-9" title="9"><span class="co"> * in_task()            - 我们处于任务上下文</span></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="co"> */</span></a>
<a class="sourceLine" id="cb15-11" title="11"><span class="pp">#define in_nmi()                (nmi_count())</span></a>
<a class="sourceLine" id="cb15-12" title="12"><span class="pp">#define in_hardirq()            (hardirq_count())</span></a>
<a class="sourceLine" id="cb15-13" title="13"><span class="pp">#define in_serving_softirq()    (softirq_count() &amp; SOFTIRQ_OFFSET)</span></a>
<a class="sourceLine" id="cb15-14" title="14"><span class="pp">#define in_task()               (!(in_nmi() | in_hardirq() | in_serving_softirq()))</span></a></code></pre></div>
<h1 id="下半部"><span class="header-section-number">6</span> 下半部</h1>
<p>中断处理程序（又叫上半部，top half）执行时，最好的情况下，与该中断同级的中断（当然包括当前的中断线）会被屏蔽，中断处理程序要执行得越快越好，中断处理程序所做的事情越少越好，但至少要操作硬件对中断进行确认、有时要从硬件copy数据等，中断处理程序只能作为整个硬件处理流程的一部分，下半部（bottom half）执行与中断处理密切相关但中断处理程序本身不处理的工作。上半部和下半部的工作划分:</p>
<ul>
<li>如果任务对时间敏感，放在上半部。</li>
<li>如果任务与硬件相关，放在上半部。</li>
<li>如果任务不能被其他中断打断（尤其是相同的中断），放在上半部。</li>
<li>其他所有任务，放到下半部。</li>
</ul>
<p>一般下半部在中断处理程序一返回就会马上执行，下半部执行的时候，允许响应所有中断。有以下几种下半部机制:</p>
<ul>
<li>已经废弃的BH: 接口简单，提供一个静态创建的链表，每个BH在全局范围内同步，永远不允许两个BH同时执行，有性能瓶颈。在v2.5放弃。</li>
<li>已经废弃的任务队列（task queues）: 当时是用来取代BH的，定义一组队列，每个队列包含一个由等待调用的函数组成的链表，对性能要求较高的子系统（如网络）不能胜任。在v2.5放弃。</li>
<li>软中断（softirq）: 静态定义的下半部接口，可以在所有cpu上同时执行，即使类型相同也可以。对性能要求较高的场景（如网络）使用软中断。</li>
<li>tasklet: 基于软中断实现的灵活性强、动态创建的下半部实现机制，不同类型的tasklet可以在不同cpu上同时执行。</li>
<li>工作队列（work queues）: 取代任务队列，在进程上下文中执行。</li>
<li><code>threaded_irq</code>: 除了中断处理函数执行完，还会执行一个进程上下文的函数。</li>
<li>内核定时器: 也是软中断的一种（<code>TIMER_SOFTIRQ</code>），如果需要在确定的时间点运行某个操作，可以尝试使用定时器。</li>
</ul>
<p>软中断和tasklet处于中断上下文中（所以不能休眠），工作队列和<code>threaded_irq</code>处于进程上下文中。</p>
<h2 id="软中断"><span class="header-section-number">6.1</span> 软中断</h2>
<p>软中断（softirq）使用得比较少，网络和scsi子系统直接使用了软中断，内核定时器和tasklet都是基于软中断的。一个软中断不会抢占另一个软中断，软中断只能被中断处理程序抢占，软中断处理程序执行时当前cpu上的软中断被禁止，但其他软中断可以（相同类型的软中断也可以）在其他cpu上同时执行，所以要有严格的锁保护。</p>
<p>用以下结构表示:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="co">/* softirq 掩码和活动字段已移动到 irq_cpustat_t 中</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="co"> * asm/hardirq.h 以获得更好的缓存使用。  KAO</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="kw">struct</span> softirq_action</a>
<a class="sourceLine" id="cb16-5" title="5">{</a>
<a class="sourceLine" id="cb16-6" title="6">        <span class="dt">void</span>    (*action)(<span class="kw">struct</span> softirq_action *);</a>
<a class="sourceLine" id="cb16-7" title="7">};</a></code></pre></div>
<p>定义含有<code>NR_SOFTIRQS</code>个软中断的数组，目前<code>HI_SOFTIRQ</code>优先级最高，<code>RCU_SOFTIRQ</code>优先级最低:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1"><span class="dt">static</span> <span class="kw">struct</span> softirq_action softirq_vec[NR_SOFTIRQS]</a></code></pre></div>
<p>待处理的软中断在以下地方被检查和执行:</p>
<ul>
<li>硬件中断代码处返回时。</li>
<li><code>ksoftirqd</code>内核线程中。</li>
<li>显式检查和执行待处理软中断的代码中，如网络子系统。</li>
</ul>
<p>软中断处理程序的一个例子是:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1"><span class="dt">void</span> net_tx_action(<span class="kw">struct</span> softirq_action *h)</a></code></pre></div>
<p>注册软中断处理程序:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1">open_softirq(NET_TX_SOFTIRQ, net_tx_action);</a></code></pre></div>
<p>在<code>__do_softirq()</code>中调用软中断处理程序:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1">__u32 pending = local_softirq_pending(); <span class="co">// 读取待处理的位图</span></a>
<a class="sourceLine" id="cb20-2" title="2">set_softirq_pending(<span class="dv">0</span>); <span class="co">// 将位图清0</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="cf">while</span> ((softirq_bit = ffs(pending))) {</a>
<a class="sourceLine" id="cb20-4" title="4">        h = softirq_vec;</a>
<a class="sourceLine" id="cb20-5" title="5">        h-&gt;action(h);</a>
<a class="sourceLine" id="cb20-6" title="6">        h++;</a>
<a class="sourceLine" id="cb20-7" title="7">        pending &gt;&gt;= softirq_bit; <span class="co">// 找到下一个待处理的位</span></a>
<a class="sourceLine" id="cb20-8" title="8">}</a></code></pre></div>
<p>触发软中断:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="co">// 会禁止中断，然后恢复原来的状态</span></a>
<a class="sourceLine" id="cb21-2" title="2">raise_softirq(TIMER_SOFTIRQ);</a>
<a class="sourceLine" id="cb21-3" title="3"><span class="co">// 如果中断已经被禁止，用这个函数会优化性能</span></a>
<a class="sourceLine" id="cb21-4" title="4">raise_softirq_irqoff(NET_TX_SOFTIRQ);</a></code></pre></div>
<p>内核中不会立刻处理重新触发的软中断，大量软中断出现时，内核会唤醒每个处理器上的<code>ksoftirqd/n</code>（<code>n</code>是处理器编号）来处理，这些线程优先级最低（<code>nice</code>值是<code>19</code>），具体请查看<code>struct smp_hotplug_thread softirq_threads</code>。</p>
<p>禁止和激活本地处理器的软中断和tasklet（tasklet基于软中断）用以下函数，可以嵌套使用:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="dt">void</span> local_bh_disable(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="co">// 嵌套使用时最后一个local_bh_enable激活下半部</span></a>
<a class="sourceLine" id="cb22-3" title="3"><span class="dt">void</span> local_bh_enable(<span class="dt">void</span>)</a></code></pre></div>
<h2 id="tasklet"><span class="header-section-number">6.2</span> tasklet</h2>
<p>tasklet是用软中断实现的下半部机制（<code>HI_SOFTIRQ</code>和<code>TASKLET_SOFTIRQ</code>），注意名字中虽然有task，但和进程（任务）没有任何关系。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1"><span class="co">/* Tasklets --- BH的多线程类比。</span></a>
<a class="sourceLine" id="cb23-2" title="2"></a>
<a class="sourceLine" id="cb23-3" title="3"><span class="co">   此API已弃用。请考虑使用线程IRQ：</span></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="co">   https://lore.kernel.org/lkml/20200716081538.2sivhkj4hcyrusem@linutronix.de</span></a>
<a class="sourceLine" id="cb23-5" title="5"></a>
<a class="sourceLine" id="cb23-6" title="6"><span class="co">   与通用softirqs的主要区别：tasklet   同时只在一个CPU上运行。</span></a>
<a class="sourceLine" id="cb23-7" title="7"></a>
<a class="sourceLine" id="cb23-8" title="8"><span class="co">   与BH的主要区别：不同的tasklet</span></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="co">   可以在不同的CPU上同时运行。</span></a>
<a class="sourceLine" id="cb23-10" title="10"></a>
<a class="sourceLine" id="cb23-11" title="11"><span class="co">   属性：</span></a>
<a class="sourceLine" id="cb23-12" title="12"><span class="co">   * 如果调用tasklet_schedule()，则保证该tasklet将在此后至少在某个CPU上执行一次。</span></a>
<a class="sourceLine" id="cb23-13" title="13"><span class="co">   * 如果tasklet已经被调度，但其执行尚未开始，它将仅执行一次。</span></a>
<a class="sourceLine" id="cb23-14" title="14"><span class="co">   * 如果该tasklet已在另一个CPU上运行（或从tasklet本身调用调度），它将被重新调度以便稍后执行。</span></a>
<a class="sourceLine" id="cb23-15" title="15"><span class="co">   * tasklet在自身方面是严格序列化的，但不与其他tasklet序列化。如果客户端需要某种任务间同步，则需使用自旋锁。</span></a>
<a class="sourceLine" id="cb23-16" title="16"><span class="co"> */</span></a>
<a class="sourceLine" id="cb23-17" title="17"><span class="kw">struct</span> tasklet_struct</a>
<a class="sourceLine" id="cb23-18" title="18">{</a>
<a class="sourceLine" id="cb23-19" title="19">        <span class="kw">struct</span> tasklet_struct *next;</a>
<a class="sourceLine" id="cb23-20" title="20">        <span class="dt">unsigned</span> <span class="dt">long</span> state; <span class="co">// TASKLET_STATE_SCHED或TASKLET_STATE_RUN</span></a>
<a class="sourceLine" id="cb23-21" title="21">        atomic_t count; <span class="co">// 引用计数</span></a>
<a class="sourceLine" id="cb23-22" title="22">        <span class="dt">bool</span> use_callback;</a>
<a class="sourceLine" id="cb23-23" title="23">        <span class="kw">union</span> {</a>
<a class="sourceLine" id="cb23-24" title="24">                <span class="dt">void</span> (*func)(<span class="dt">unsigned</span> <span class="dt">long</span> data); <span class="co">// 处理函数</span></a>
<a class="sourceLine" id="cb23-25" title="25">                <span class="dt">void</span> (*callback)(<span class="kw">struct</span> tasklet_struct *t);</a>
<a class="sourceLine" id="cb23-26" title="26">        };</a>
<a class="sourceLine" id="cb23-27" title="27">        <span class="dt">unsigned</span> <span class="dt">long</span> data; <span class="co">// 处理函数的参数</span></a>
<a class="sourceLine" id="cb23-28" title="28">};</a></code></pre></div>
<p>已调度的tasklet存放在下面两个链表:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1"><span class="dt">static</span> DEFINE_PER_CPU(<span class="kw">struct</span> tasklet_head, tasklet_vec);</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="dt">static</span> DEFINE_PER_CPU(<span class="kw">struct</span> tasklet_head, tasklet_hi_vec);</a></code></pre></div>
<p>由<code>tasklet_schedule()</code>（对应<code>TASKLET_SOFTIRQ</code>）和<code>tasklet_hi_schedule()</code>（对应<code>HI_SOFTIRQ</code>）调度，处理程序是<code>tasklet_action()</code>和<code>tasklet_hi_action()</code>。</p>
<p>静态创建tasklet:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1"><span class="co">// .count初始化为0，激活状态</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="dt">static</span> DECLARE_TASKLET(fst_tx_task, fst_process_tx_work_q);</a>
<a class="sourceLine" id="cb25-3" title="3"><span class="co">// .count初始化为1，禁止状态</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="dt">static</span> DECLARE_TASKLET_DISABLED(keyboard_tasklet, kbd_bh);</a></code></pre></div>
<p>动态创建tasklet:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1">tasklet_init(&amp;ic-&gt;i_send_tasklet, rds_ib_tasklet_fn_send,</a>
<a class="sourceLine" id="cb26-2" title="2">             (<span class="dt">unsigned</span> <span class="dt">long</span>)ic);</a></code></pre></div>
<p>tasklet处理函数的一个例子:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1"><span class="dt">static</span> <span class="dt">void</span> rds_ib_tasklet_fn_send(<span class="dt">unsigned</span> <span class="dt">long</span> data)</a></code></pre></div>
<p>禁止或激活tasklet:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="dt">void</span> tasklet_disable(<span class="kw">struct</span> tasklet_struct *t)</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="co">// tasklet_disable_nosync不太安全，一般不用</span></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="dt">void</span> tasklet_disable_nosync(<span class="kw">struct</span> tasklet_struct *t)</a>
<a class="sourceLine" id="cb28-4" title="4"><span class="co">// DECLARE_TASKLET_DISABLED创建的，也得用tasklet_enable激活</span></a>
<a class="sourceLine" id="cb28-5" title="5"><span class="dt">void</span> tasklet_enable(<span class="kw">struct</span> tasklet_struct *t)</a>
<a class="sourceLine" id="cb28-6" title="6"><span class="co">// 从挂起的队列中移去已调度的tasklet，先等待tasklet执行完成再移去，只能在进程上下文中使用（会休眠）</span></a>
<a class="sourceLine" id="cb28-7" title="7"><span class="dt">void</span> tasklet_kill(<span class="kw">struct</span> tasklet_struct *t)</a></code></pre></div>
<h2 id="工作队列"><span class="header-section-number">6.3</span> 工作队列</h2>
<p>工作队列（work queue）把工作交给内核线程执行，在进程上下文中，允许重新调度和休眠。</p>
<p>工作队列子系统提供了默认的工作者线程（worker thread），在<code>workqueue_init_early()</code>中创建了<code>system_wq</code>等工作队列，如果需要任务也可以创建自己的工作者列队，用以下结构表示:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb29-2" title="2"><span class="co"> * 外部可见的工作队列。它将发出的工作项通过其 pool_workqueues 转发到适当的 worker_pool。</span></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="kw">struct</span> workqueue_struct</a></code></pre></div>
<p>所有的工作者线程都要执行<code>worker_thread()</code>，初始化后死循环并开始休眠，当有操作插入到队列中，线程唤醒执行。表示工作的数据结构如下:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">struct</span> work_struct {</a>
<a class="sourceLine" id="cb30-2" title="2">        atomic_long_t data;</a>
<a class="sourceLine" id="cb30-3" title="3">        <span class="kw">struct</span> list_head entry;</a>
<a class="sourceLine" id="cb30-4" title="4">        work_func_t func;</a>
<a class="sourceLine" id="cb30-5" title="5"><span class="pp">#ifdef CONFIG_LOCKDEP</span></a>
<a class="sourceLine" id="cb30-6" title="6">        <span class="kw">struct</span> lockdep_map lockdep_map;</a>
<a class="sourceLine" id="cb30-7" title="7"><span class="pp">#endif</span></a>
<a class="sourceLine" id="cb30-8" title="8">};</a></code></pre></div>
<p>还有以下几个相关的结构体:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb31-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="co"> * 做实际繁重工作的可怜家伙。所有在职工人要么担任经理角色，要么在空闲列表中，或在忙碌哈希中。</span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="co"> * 有关锁注释（L、I、X...）的详细信息，请参阅 workqueue.c。</span></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="co"> *</span></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="co"> * 仅在工作队列和异步中使用。</span></a>
<a class="sourceLine" id="cb31-6" title="6"><span class="co"> */</span></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="kw">struct</span> worker</a>
<a class="sourceLine" id="cb31-8" title="8"></a>
<a class="sourceLine" id="cb31-9" title="9"><span class="kw">struct</span> worker_pool</a></code></pre></div>
<p><code>struct work_struct</code>对象在<code>worker_thread()</code>中用<code>worker_pool *pool</code>的<code>worklist</code>链表连接。</p>
<p>创建推后的工作:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb32-1" title="1"><span class="co">// 编译时静态创建</span></a>
<a class="sourceLine" id="cb32-2" title="2">DECLARE_WORK(p9_poll_work, p9_poll_workfn);</a>
<a class="sourceLine" id="cb32-3" title="3">DECLARE_DELAYED_WORK(name, func)</a>
<a class="sourceLine" id="cb32-4" title="4"><span class="co">// 运行时动态创建</span></a>
<a class="sourceLine" id="cb32-5" title="5">INIT_WORK(&amp;priv-&gt;tx_onestep_tstamp, enetc_tx_onestep_tstamp);</a>
<a class="sourceLine" id="cb32-6" title="6">INIT_DELAYED_WORK(_work, _func)</a></code></pre></div>
<p>工作队列处理函数的一个例子是:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb33-1" title="1"><span class="dt">void</span> p9_poll_workfn(<span class="kw">struct</span> work_struct *work)</a></code></pre></div>
<p>工作队列处理函数由工作者线程执行，运行在进程上下文中，但不能访问用户空间，因为内核线程在用户空间没有相关的内存映射（系统调用时内核代表用户空间进程运行，会映射用户空间内存）。</p>
<p>使用默认的工作队列进行调度:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb34-1" title="1"><span class="dt">bool</span> schedule_work(<span class="kw">struct</span> work_struct *work)</a>
<a class="sourceLine" id="cb34-2" title="2"><span class="co">// 经过一段时间再执行</span></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="dt">bool</span> schedule_delayed_work(<span class="kw">struct</span> delayed_work *dwork, <span class="dt">unsigned</span> <span class="dt">long</span> delay)</a></code></pre></div>
<p>刷新工作队列和取消延迟执行的工作:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb35-1" title="1"><span class="co">// 直到队列中所有对象执行完成，注意不会取消延迟执行的工作</span></a>
<a class="sourceLine" id="cb35-2" title="2">flush_scheduled_work()</a>
<a class="sourceLine" id="cb35-3" title="3"><span class="co">// 取消延迟执行的工作</span></a>
<a class="sourceLine" id="cb35-4" title="4"><span class="dt">bool</span> cancel_delayed_work(<span class="kw">struct</span> delayed_work *dwork)</a></code></pre></div>
<p>创建新的工作队列:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb36-1" title="1">create_workqueue(name)</a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">// 调度执行工作, include/linux/workqueue.h</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="dt">bool</span> queue_work(<span class="kw">struct</span> workqueue_struct *wq, <span class="kw">struct</span> work_struct *work)</a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">// 经过一段时间再执行</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="dt">bool</span> queue_delayed_work(<span class="kw">struct</span> workqueue_struct *wq, <span class="kw">struct</span> delayed_work *dwork, <span class="dt">unsigned</span> <span class="dt">long</span> delay)</a>
<a class="sourceLine" id="cb36-6" title="6"><span class="co">// 刷新指定的工作队列</span></a>
<a class="sourceLine" id="cb36-7" title="7">flush_workqueue(wq)</a></code></pre></div>
<h2 id="threaded_irq"><span class="header-section-number">6.4</span> <code>threaded_irq</code></h2>
<p>以下两个函数中，<code>handler</code>函数执行于中断上下文，<code>thread_fn</code>函数执行于内核线程（进程上下文），如果<code>handler</code>函数返回<code>IRQ_WAKE_THREAD</code>，<code>thread_fn</code>函数会被执行。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb37-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="co"> *      request_threaded_irq - 分配一个中断线</span></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="co"> *      </span><span class="an">@irq:</span><span class="co"> 要分配的中断线</span></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="co"> *      </span><span class="an">@handler:</span><span class="co"> 当 IRQ 发生时调用的函数。</span></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="co"> *                线程中断的主要处理程序。</span></a>
<a class="sourceLine" id="cb37-6" title="6"><span class="co"> *                如果 handler 为 NULL 且 thread_fn != NULL，</span></a>
<a class="sourceLine" id="cb37-7" title="7"><span class="co"> *                则安装默认的主要处理程序 irq_default_primary_handler。</span></a>
<a class="sourceLine" id="cb37-8" title="8"><span class="co"> *      </span><span class="an">@thread_fn:</span><span class="co"> 从 irq 处理程序线程中调用的函数</span></a>
<a class="sourceLine" id="cb37-9" title="9"><span class="co"> *                  如果为 NULL，则不创建 irq 线程</span></a>
<a class="sourceLine" id="cb37-10" title="10"><span class="co"> *      </span><span class="an">@irqflags:</span><span class="co"> 中断类型标志</span></a>
<a class="sourceLine" id="cb37-11" title="11"><span class="co"> *      </span><span class="an">@devname:</span><span class="co"> 设备的 ASCII 名称</span></a>
<a class="sourceLine" id="cb37-12" title="12"><span class="co"> *      </span><span class="an">@dev_id:</span><span class="co"> 传递回处理程序函数的 cookie</span></a>
<a class="sourceLine" id="cb37-13" title="13"><span class="co"> *</span></a>
<a class="sourceLine" id="cb37-14" title="14"><span class="co"> *      此调用分配中断资源并启用中断线和 IRQ 处理。从此调用开始，</span></a>
<a class="sourceLine" id="cb37-15" title="15"><span class="co"> *      您的处理程序函数可能会被调用。由于您的处理程序函数必须清除</span></a>
<a class="sourceLine" id="cb37-16" title="16"><span class="co"> *      电路板引发的任何中断，因此您必须注意初始化硬件并按照正确的</span></a>
<a class="sourceLine" id="cb37-17" title="17"><span class="co"> *      顺序设置中断处理程序。</span></a>
<a class="sourceLine" id="cb37-18" title="18"><span class="co"> *</span></a>
<a class="sourceLine" id="cb37-19" title="19"><span class="co"> *      如果您想为设备设置线程化 irq 处理程序，则需要提供 </span><span class="an">@handler</span><span class="co"> 和 </span></a>
<a class="sourceLine" id="cb37-20" title="20"><span class="co"> *      </span><span class="an">@thread_fn。@handler</span><span class="co"> 仍在硬中断上下文中调用，并且必须检查中断</span></a>
<a class="sourceLine" id="cb37-21" title="21"><span class="co"> *      是否来自该设备。如果是，它需要禁用设备上的中断并返回 </span></a>
<a class="sourceLine" id="cb37-22" title="22"><span class="co"> *      IRQ_WAKE_THREAD，这将唤醒处理程序线程并运行 </span><span class="an">@thread_fn。</span></a>
<a class="sourceLine" id="cb37-23" title="23"><span class="co"> *      这种分离的处理程序设计是支持共享中断所必需的。</span></a>
<a class="sourceLine" id="cb37-24" title="24"><span class="co"> *</span></a>
<a class="sourceLine" id="cb37-25" title="25"><span class="co"> *      dev_id 必须是全局唯一的。通常使用设备数据结构的地址作为 cookie。</span></a>
<a class="sourceLine" id="cb37-26" title="26"><span class="co"> *      由于处理程序接收此值，因此使用它是有意义的。</span></a>
<a class="sourceLine" id="cb37-27" title="27"><span class="co"> *</span></a>
<a class="sourceLine" id="cb37-28" title="28"><span class="co"> *      如果您的中断是共享的，您必须传递非 NULL dev_id，因为这在释放</span></a>
<a class="sourceLine" id="cb37-29" title="29"><span class="co"> *      中断时是必需的。</span></a>
<a class="sourceLine" id="cb37-30" title="30"><span class="co"> *</span></a>
<a class="sourceLine" id="cb37-31" title="31"><span class="co"> *      标志：</span></a>
<a class="sourceLine" id="cb37-32" title="32"><span class="co"> *</span></a>
<a class="sourceLine" id="cb37-33" title="33"><span class="co"> *      IRQF_SHARED             中断是共享的</span></a>
<a class="sourceLine" id="cb37-34" title="34"><span class="co"> *      IRQF_TRIGGER_*          指定活动边缘或电平</span></a>
<a class="sourceLine" id="cb37-35" title="35"><span class="co"> *      IRQF_ONESHOT            运行 thread_fn 时屏蔽中断线，thread_fn执行后重新使能中断线</span></a>
<a class="sourceLine" id="cb37-36" title="36"><span class="co"> */</span></a>
<a class="sourceLine" id="cb37-37" title="37"><span class="dt">int</span> request_threaded_irq(<span class="dt">unsigned</span> <span class="dt">int</span> irq, irq_handler_t handler,</a>
<a class="sourceLine" id="cb37-38" title="38">                         irq_handler_t thread_fn, <span class="dt">unsigned</span> <span class="dt">long</span> irqflags,</a>
<a class="sourceLine" id="cb37-39" title="39">                         <span class="dt">const</span> <span class="dt">char</span> *devname, <span class="dt">void</span> *dev_id)</a>
<a class="sourceLine" id="cb37-40" title="40"></a>
<a class="sourceLine" id="cb37-41" title="41"><span class="co">/**</span></a>
<a class="sourceLine" id="cb37-42" title="42"><span class="co"> *      devm_request_threaded_irq - 为受管设备分配中断线</span></a>
<a class="sourceLine" id="cb37-43" title="43"><span class="co"> *      </span><span class="an">@dev:</span><span class="co"> 请求中断的设备</span></a>
<a class="sourceLine" id="cb37-44" title="44"><span class="co"> *      </span><span class="an">@irq:</span><span class="co"> 要分配的中断线</span></a>
<a class="sourceLine" id="cb37-45" title="45"><span class="co"> *      </span><span class="an">@handler:</span><span class="co"> 当 IRQ 发生时调用的函数，如果 handler 为 NULL 且 thread_fn != NULL，</span></a>
<a class="sourceLine" id="cb37-46" title="46"><span class="co"> *            则安装默认的主要处理程序 irq_default_primary_handler。</span></a>
<a class="sourceLine" id="cb37-47" title="47"><span class="co"> *      </span><span class="an">@thread_fn:</span><span class="co"> 在线程中断上下文中调用的函数。如果设备在 </span><span class="an">@handler</span><span class="co"> 中处理所有内容，则为 NULL</span></a>
<a class="sourceLine" id="cb37-48" title="48"><span class="co"> *      </span><span class="an">@irqflags:</span><span class="co"> 中断类型标志</span></a>
<a class="sourceLine" id="cb37-49" title="49"><span class="co"> *      </span><span class="an">@devname:</span><span class="co"> 设备的 ASCII 名称，如果为 NULL，则使用 dev_name(dev)</span></a>
<a class="sourceLine" id="cb37-50" title="50"><span class="co"> *      </span><span class="an">@dev_id:</span><span class="co"> 传递回处理程序函数的 cookie</span></a>
<a class="sourceLine" id="cb37-51" title="51"><span class="co"> *</span></a>
<a class="sourceLine" id="cb37-52" title="52"><span class="co"> *      除了额外的 </span><span class="an">@dev</span><span class="co"> 参数外，此函数接受相同的参数并执行与</span></a>
<a class="sourceLine" id="cb37-53" title="53"><span class="co"> *      request_threaded_irq() 相同的功能。使用此函数请求的 IRQ 将在</span></a>
<a class="sourceLine" id="cb37-54" title="54"><span class="co"> *      驱动程序卸载时自动释放。</span></a>
<a class="sourceLine" id="cb37-55" title="55"><span class="co"> *</span></a>
<a class="sourceLine" id="cb37-56" title="56"><span class="co"> *      如果使用此函数分配的 IRQ 需要单独释放，则必须使用 devm_free_irq()。</span></a>
<a class="sourceLine" id="cb37-57" title="57"><span class="co"> */</span></a>
<a class="sourceLine" id="cb37-58" title="58"><span class="co">// devm: managed device</span></a>
<a class="sourceLine" id="cb37-59" title="59"><span class="co">// 类似垃圾回收机制，不需要调用free_irq()</span></a>
<a class="sourceLine" id="cb37-60" title="60"><span class="co">// 请参考补丁[at86rf230: use devm_request_irq](https://lore.kernel.org/all/1398359358-11085-5-git-send-email-alex.aring@gmail.com/)</span></a>
<a class="sourceLine" id="cb37-61" title="61"><span class="dt">int</span> devm_request_threaded_irq(<span class="kw">struct</span> device *dev, <span class="dt">unsigned</span> <span class="dt">int</span> irq,</a>
<a class="sourceLine" id="cb37-62" title="62">                              irq_handler_t handler, irq_handler_t thread_fn,</a>
<a class="sourceLine" id="cb37-63" title="63">                              <span class="dt">unsigned</span> <span class="dt">long</span> irqflags, <span class="dt">const</span> <span class="dt">char</span> *devname,</a>
<a class="sourceLine" id="cb37-64" title="64">                              <span class="dt">void</span> *dev_id)</a></code></pre></div>
</body>
</html>
