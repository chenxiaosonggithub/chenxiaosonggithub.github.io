<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>进程管理和调度</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://chenxiaosong.com/stylesheet.css" />
</head>
<body>
<header id="title-block-header">
<!-- sign begin -->
<ul>
<li>作者: 陈孝松</li>
<li><a href="https://chenxiaosong.com/">中文主页: chenxiaosong.com</a></li>
<li><a href="https://chenxiaosong.com/en">英文主页: chenxiaosong.com/en</a></li>
<li><a href="https://chenxiaosong.com/video.html">哔哩哔哩教学视频: 陈孝松</a></li>
<li><a href="https://chenxiaosong.com/course.html">课程: chenxiaosong.com/course</a></li>
<li><a href="https://chenxiaosong.com/blog.html">博客: chenxiaosong.com/blog</a></li>
<li><a href="https://chenxiaosong.com/contribution.html">贡献: chenxiaosong.com/contribution</a></li>
<li>邮箱: <a href="mailto:chenxiaosong@chenxiaosong.com" class="email">chenxiaosong@chenxiaosong.com</a></li>
<li><a href="https://chenxiaosong.com/q.html">QQ交流群: 544216206, 点击查看群介绍</a></li>
</ul>
<!-- sign end -->
<h1 class="title">进程管理和调度</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#进程"><span class="toc-section-number">1</span> 进程</a><ul>
<li><a href="#简介"><span class="toc-section-number">1.1</span> 简介</a></li>
<li><a href="#进程描述符"><span class="toc-section-number">1.2</span> 进程描述符</a></li>
<li><a href="#进程创建和终结"><span class="toc-section-number">1.3</span> 进程创建和终结</a></li>
<li><a href="#调试"><span class="toc-section-number">1.4</span> 调试</a></li>
</ul></li>
<li><a href="#线程"><span class="toc-section-number">2</span> 线程</a><ul>
<li><a href="#创建线程"><span class="toc-section-number">2.1</span> 创建线程</a></li>
<li><a href="#内核线程"><span class="toc-section-number">2.2</span> 内核线程</a></li>
<li><a href="#调试-1"><span class="toc-section-number">2.3</span> 调试</a></li>
</ul></li>
<li><a href="#进程调度"><span class="toc-section-number">3</span> 进程调度</a><ul>
<li><a href="#简介-1"><span class="toc-section-number">3.1</span> 简介</a></li>
<li><a href="#用户空间接口"><span class="toc-section-number">3.2</span> 用户空间接口</a></li>
<li><a href="#调度策略"><span class="toc-section-number">3.3</span> 调度策略</a></li>
<li><a href="#on和o1调度器"><span class="toc-section-number">3.4</span> O(n)和O(1)调度器</a></li>
</ul></li>
<li><a href="#完全公平调度器"><span class="toc-section-number">4</span> 完全公平调度器</a><ul>
<li><a href="#时间记账"><span class="toc-section-number">4.1</span> 时间记账</a></li>
<li><a href="#进程选择"><span class="toc-section-number">4.2</span> 进程选择</a></li>
</ul></li>
<li><a href="#eevdf调度器"><span class="toc-section-number">5</span> EEVDF调度器</a></li>
<li><a href="#休眠和唤醒"><span class="toc-section-number">6</span> 休眠和唤醒</a></li>
<li><a href="#多处理器系统中的运行队列平衡"><span class="toc-section-number">7</span> 多处理器系统中的运行队列平衡</a></li>
<li><a href="#其他调度器"><span class="toc-section-number">8</span> 其他调度器</a><ul>
<li><a href="#bfs"><span class="toc-section-number">8.1</span> BFS</a></li>
<li><a href="#extensible-scheduler-class"><span class="toc-section-number">8.2</span> Extensible Scheduler Class</a></li>
</ul></li>
<li><a href="#硬实时"><span class="toc-section-number">9</span> 硬实时</a></li>
</ul>
</nav>
<p><a href="https://chenxiaosong.com/course/kernel/kernel.html">点击跳转到内核课程所有目录</a>。</p>
<p><a href="https://chenxiaosong.com/course/kernel/video.html">点击这里查看配套的教学视频</a>。</p>
<h1 id="进程"><span class="header-section-number">1</span> 进程</h1>
<h2 id="简介"><span class="header-section-number">1.1</span> 简介</h2>
<p>程序是存储在磁盘中，而进程是处于执行期的程序（当然还有其他相关资源），从内核视角看又叫任务（task）。执行线程，简称线程（thread），是在进程中活动的对象，内核调度的对象是线程，而不是进程。Linux内核不区分线程和进程，线程是特殊的进程。</p>
<p>进程提供两种虚拟机制: 虚拟处理器和虚拟内存。</p>
<p>在调试加打印时，我们经常会使用到<code>current-&gt;comm</code>和<code>current-&gt;pid</code>来获取进程名和进程id，如<code>if (!strcmp(current-&gt;comm, "cat")</code>，其中的<code>current</code>宏定义在x86架构的实现如下:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// arch/x86/include/asm/current.h</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#define current get_current()</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="dt">static</span> __always_inline <span class="kw">struct</span> task_struct *get_current(<span class="dt">void</span>)</a>
<a class="sourceLine" id="cb1-5" title="5">{                                                           </a>
<a class="sourceLine" id="cb1-6" title="6">        <span class="cf">return</span> this_cpu_read_stable(pcpu_hot.current_task); </a>
<a class="sourceLine" id="cb1-7" title="7">}                                                           </a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">struct</span> pcpu_hot {                                                   </a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="kw">union</span> {                                                     </a>
<a class="sourceLine" id="cb1-11" title="11">                <span class="kw">struct</span> {                                            </a>
<a class="sourceLine" id="cb1-12" title="12">                        <span class="kw">struct</span> task_struct      *current_task;</a>
<a class="sourceLine" id="cb1-13" title="13">                        ...</a>
<a class="sourceLine" id="cb1-14" title="14">                };</a>
<a class="sourceLine" id="cb1-15" title="15">                ...                          </a>
<a class="sourceLine" id="cb1-16" title="16">        };                                                          </a>
<a class="sourceLine" id="cb1-17" title="17">};                                                                  </a></code></pre></div>
<h2 id="进程描述符"><span class="header-section-number">1.2</span> 进程描述符</h2>
<p>用结构体<code>struct task_struct</code>来描述进程，这个结构体很大，请查看 <a href="https://gitee.com/chenxiaosonggitee/blog/tree/master/course/kernel/src/task_struct.c"><code>src/task_struct.c</code></a> 。</p>
<p>其中<code>__state</code>可以是以下值，通过<code>set_current_state(state_value)</code>来设置:</p>
<ul>
<li><code>TASK_RUNNING</code>: 进程可执行，要么正在执行，要么在等待队列中等待执行。</li>
<li><code>TASK_INTERRUPTIBLE</code>: 进程正在休眠，当某些条件满足时唤醒，接收到信号可被唤醒。</li>
<li><code>TASK_UNINTERRUPTIBLE</code>: 接收到信号不能唤醒，其他和<code>TASK_INTERRUPTIBLE</code>一样。</li>
<li><code>__TASK_STOPPED</code>: 进程停止执行，没有投入运行也不能投入运行，接收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>、<code>SIGTTOU</code>信号时进入这个状态，在调试期间接收到任何信号也进入这个状态。</li>
<li><code>__TASK_TRACED</code>: 被其他进程跟踪，如通过<code>ptrace</code>调试。</li>
</ul>
<p><code>exit_state</code>退出状态可以是以下值:</p>
<ul>
<li><code>EXIT_ZOMBIE</code>: 进程已经终止，但其状态尚未被父进程读取，进程描述符仍然存在。</li>
<li><code>EXIT_DEAD</code>: 进程状态已经被父进程读取，系统正在进行最终清理，进程描述符尚未完全释放。</li>
<li><code>EXIT_TRACE</code>: 进程正在被跟踪（traced）。这通常发生在调试会话中，进程在执行过程中被调试器（如gdb）所跟踪。</li>
</ul>
<p>用<code>set_current_state(state_value)</code>设置进程状态。</p>
<p>在系统启动的最后阶段启动pid这<code>1</code>的<code>init</code>进程，其他进程都是这个进程的后代，通过<code>current-&gt;parent</code>获得当前进程的父进程，当前进程的子进程用如下代码遍历:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" title="1"></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">struct</span> list_head *list;</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">struct</span> task_struct *child;</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5">list_for_each(list, &amp;current-&gt;children) {</a>
<a class="sourceLine" id="cb2-6" title="6">        child = list_entry(list, <span class="kw">struct</span> task_struct, sibling);</a>
<a class="sourceLine" id="cb2-7" title="7">        printk(KERN_INFO <span class="st">&quot;child pid: %d, comm: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, child-&gt;pid, child-&gt;comm);</a>
<a class="sourceLine" id="cb2-8" title="8">}</a></code></pre></div>
<p>遍历祖先，直到<code>init</code>进程:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">struct</span> task_struct *task;</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="cf">for</span> (task = current; task != &amp;init_task; task = task-&gt;parent) {</a>
<a class="sourceLine" id="cb3-3" title="3">        printk(KERN_INFO <span class="st">&quot;pid: %d, comm: %s</span><span class="sc">\n</span><span class="st">&quot;</span>, task-&gt;pid, task-&gt;comm);</a>
<a class="sourceLine" id="cb3-4" title="4">}</a></code></pre></div>
<p>从<code>tasks</code>成员获取前一个和后一个进程:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb4-1" title="1">list_entry(task-&gt;tasks.next, <span class="kw">struct</span> task_struct, tasks) <span class="co">// 后一个，next_task(p)宏定义</span></a>
<a class="sourceLine" id="cb4-2" title="2">list_entry(task-&gt;tasks.prev, <span class="kw">struct</span> task_struct, tasks) <span class="co">// 前一个</span></a></code></pre></div>
<p>遍历所有进程用<code>for_each_process(p)</code>宏定义，但除非必要，我们不建议这样全部遍历。</p>
<h2 id="进程创建和终结"><span class="header-section-number">1.3</span> 进程创建和终结</h2>
<p>进程的创建包含<code>fork()</code>（或<code>vfork</code>）和<code>exec</code>（<code>execve()</code>和<code>execveat()</code>）。</p>
<p>其中<code>fork</code>相关流程如下:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// fork()适合大多数创建子进程的场景，尤其是当子进程需要在执行exec()之前做更多操作时（如文件描述符重定向、环境变量设置等）</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">// 会为子进程分配一个新的地址空间，并将父进程的地址空间内容复制到子进程中</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="co">// 这个复制过程称为写时复制（Copy-On-Write, COW），即在父子进程之间共享相同的内存页，只有当父或子进程尝试修改某个页时，才会实际进行内存复制</span></a>
<a class="sourceLine" id="cb5-4" title="4">fork</a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co">// vfork() 不会为子进程复制父进程的地址空间</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co">// 效率高，适用于子进程立即调用exec()替换自身的场景（如执行一个新程序）</span></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="co">// 父进程会被挂起（即不能执行任何操作），直到调用 exec()，以防止父子进程之间发生竞争条件或冲突</span></a>
<a class="sourceLine" id="cb5-8" title="8">vfork</a>
<a class="sourceLine" id="cb5-9" title="9">clone<span class="dv">3</span></a>
<a class="sourceLine" id="cb5-10" title="10">clone</a>
<a class="sourceLine" id="cb5-11" title="11">  kernel_clone</a>
<a class="sourceLine" id="cb5-12" title="12">    copy_process</a>
<a class="sourceLine" id="cb5-13" title="13">      dup_task_struct</a></code></pre></div>
<p>进程终结时，调用<code>exit()</code>系统调用（在<code>kernel/exit.c</code>中）:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb6-1" title="1">exit</a>
<a class="sourceLine" id="cb6-2" title="2">  do_exit</a>
<a class="sourceLine" id="cb6-3" title="3">    exit_notify</a>
<a class="sourceLine" id="cb6-4" title="4">      forget_original_parent</a>
<a class="sourceLine" id="cb6-5" title="5">        exit_ptrace</a>
<a class="sourceLine" id="cb6-6" title="6">        find_new_reaper</a>
<a class="sourceLine" id="cb6-7" title="7">          <span class="cf">if</span> (reaper == &amp;init_task) <span class="co">// 进程所在的线程组内如果没有其他进程，则返回init进程</span></a></code></pre></div>
<p>进程退出执行后<code>__state</code>被设置为<code>EXIT_ZOMBIE</code>状态，直到父进程调用<code>wait4()</code>和<code>waitpid()</code>系统调用查询子进程是否终结（用户态程序调用<code>wait()</code>或<code>pthread_join()</code>），然后进程描述符被释放，<code>release_task()</code>被调用:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb7-1" title="1">wait<span class="dv">4</span></a>
<a class="sourceLine" id="cb7-2" title="2">waitpid</a>
<a class="sourceLine" id="cb7-3" title="3">  kernel_wait<span class="dv">4</span></a>
<a class="sourceLine" id="cb7-4" title="4">    do_wait</a>
<a class="sourceLine" id="cb7-5" title="5">      do_wait_thread</a>
<a class="sourceLine" id="cb7-6" title="6">        wait_consider_task</a>
<a class="sourceLine" id="cb7-7" title="7">          wait_task_zombie</a>
<a class="sourceLine" id="cb7-8" title="8">            <span class="cf">if</span> (state == EXIT_DEAD)</a>
<a class="sourceLine" id="cb7-9" title="9">            release_task</a></code></pre></div>
<h2 id="调试"><span class="header-section-number">1.4</span> 调试</h2>
<p>内核打上 <a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/0001-debug-task_struct.patch"><code>0001-debug-task_struct.patch</code></a> 补丁，编译运行 <a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/fork.c"><code>fork.c</code></a> :</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="ex">mkfs.ext2</span> -F image</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="fu">mount</span> image /mnt</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="fu">gcc</span> -o fork fork.c</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ex">./fork</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="fu">ps</span> -e -o pid,ppid,cmd <span class="kw">|</span> <span class="fu">grep</span> fork</a></code></pre></div>
<h1 id="线程"><span class="header-section-number">2</span> 线程</h1>
<p>一个多线程的程序，所有线程形成一个线程组，线程组中的第一个线程为线程组的pid， 这个第一个线程叫主线程，也就是调用<code>pthread_create()</code>的线程，<code>struct task_struct</code>中的<code>tgid</code>表示线程组中主线程的pid，<code>getpid()</code>系统调用获得的就是这个值。</p>
<p>在用户空间，线程id用以下方式获取:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb9-1" title="1"><span class="pp">#include </span><span class="im">&lt;sys/syscall.h&gt;</span><span class="pp"> </span><span class="co">// 用于 SYS_gettid</span></a>
<a class="sourceLine" id="cb9-2" title="2">pid_t tid = syscall(SYS_gettid);</a></code></pre></div>
<h2 id="创建线程"><span class="header-section-number">2.1</span> 创建线程</h2>
<p>线程是和其他进程共享某些资源（如地址空间等）的进程，创建线程:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb10-1" title="1"><span class="co">// 共享: 地址空间、文件系统资源、文件描述符、信号处理程序</span></a>
<a class="sourceLine" id="cb10-2" title="2">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="dv">0</span>)</a></code></pre></div>
<p><code>clone</code>系统调用的参数<code>clone_flags</code>可以是如下值的组合:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb11-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="co"> * cloning flags:</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="pp">#define CSIGNAL     0x000000ff  </span><span class="co">/* 在退出时要发送的信号掩码 */</span></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="pp">#define CLONE_VM    0x00000100  </span><span class="co">/* 设置此标志时，进程之间共享虚拟内存（VM） */</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="pp">#define CLONE_FS    0x00000200  </span><span class="co">/* 设置此标志时，进程之间共享文件系统信息 */</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="pp">#define CLONE_FILES 0x00000400  </span><span class="co">/* 设置此标志时，进程之间共享已打开的文件 */</span></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="pp">#define CLONE_SIGHAND   0x00000800  </span><span class="co">/* 设置此标志时，进程之间共享信号处理程序和被阻塞的信号 */</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="pp">#define CLONE_PIDFD 0x00001000  </span><span class="co">/* 设置此标志时，在父进程中创建一个 pidfd */</span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="pp">#define CLONE_PTRACE    0x00002000  </span><span class="co">/* 设置此标志时，允许对子进程的跟踪继续 */</span></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="pp">#define CLONE_VFORK 0x00004000  </span><span class="co">/* 设置此标志时，子进程在释放内存管理器（mm_release）时唤醒父进程 */</span></a>
<a class="sourceLine" id="cb11-12" title="12"><span class="pp">#define CLONE_PARENT    0x00008000  </span><span class="co">/* 设置此标志时，子进程与克隆进程拥有相同的父进程 */</span></a>
<a class="sourceLine" id="cb11-13" title="13"><span class="pp">#define CLONE_THREAD    0x00010000  </span><span class="co">/* 同一线程组？ */</span></a>
<a class="sourceLine" id="cb11-14" title="14"><span class="pp">#define CLONE_NEWNS 0x00020000  </span><span class="co">/* 新的挂载命名空间组 */</span></a>
<a class="sourceLine" id="cb11-15" title="15"><span class="pp">#define CLONE_SYSVSEM   0x00040000  </span><span class="co">/* 共享 System V 的 SEM_UNDO 语义 */</span></a>
<a class="sourceLine" id="cb11-16" title="16"><span class="pp">#define CLONE_SETTLS    0x00080000  </span><span class="co">/* 为子进程创建新的 TLS */</span></a>
<a class="sourceLine" id="cb11-17" title="17"><span class="pp">#define CLONE_PARENT_SETTID 0x00100000  </span><span class="co">/* 在父进程中设置 TID */</span></a>
<a class="sourceLine" id="cb11-18" title="18"><span class="pp">#define CLONE_CHILD_CLEARTID    0x00200000  </span><span class="co">/* 在子进程中清除 TID */</span></a>
<a class="sourceLine" id="cb11-19" title="19"><span class="pp">#define CLONE_DETACHED      0x00400000  </span><span class="co">/* 未使用，忽略 */</span></a>
<a class="sourceLine" id="cb11-20" title="20"><span class="pp">#define CLONE_UNTRACED      0x00800000  </span><span class="co">/* 设置此标志时，跟踪进程不能强制对子进程使用 CLONE_PTRACE */</span></a>
<a class="sourceLine" id="cb11-21" title="21"><span class="pp">#define CLONE_CHILD_SETTID  0x01000000  </span><span class="co">/* 在子进程中设置 TID */</span></a>
<a class="sourceLine" id="cb11-22" title="22"><span class="pp">#define CLONE_NEWCGROUP     0x02000000  </span><span class="co">/* 新的 cgroup 命名空间 */</span></a>
<a class="sourceLine" id="cb11-23" title="23"><span class="pp">#define CLONE_NEWUTS        0x04000000  </span><span class="co">/* 新的 UTS 命名空间 */</span></a>
<a class="sourceLine" id="cb11-24" title="24"><span class="pp">#define CLONE_NEWIPC        0x08000000  </span><span class="co">/* 新的 IPC 命名空间 */</span></a>
<a class="sourceLine" id="cb11-25" title="25"><span class="pp">#define CLONE_NEWUSER       0x10000000  </span><span class="co">/* 新的用户命名空间 */</span></a>
<a class="sourceLine" id="cb11-26" title="26"><span class="pp">#define CLONE_NEWPID        0x20000000  </span><span class="co">/* 新的 PID 命名空间 */</span></a>
<a class="sourceLine" id="cb11-27" title="27"><span class="pp">#define CLONE_NEWNET        0x40000000  </span><span class="co">/* 新的网络命名空间 */</span></a>
<a class="sourceLine" id="cb11-28" title="28"><span class="pp">#define CLONE_IO        0x80000000  </span><span class="co">/* 克隆 IO 上下文 */</span></a>
<a class="sourceLine" id="cb11-29" title="29"></a>
<a class="sourceLine" id="cb11-30" title="30"><span class="co">/* clone3() 系统调用的标志。 */</span></a>
<a class="sourceLine" id="cb11-31" title="31"><span class="pp">#define CLONE_CLEAR_SIGHAND 0x100000000ULL </span><span class="co">/* 清除任何信号处理程序并重置为 SIG_DFL。 */</span></a>
<a class="sourceLine" id="cb11-32" title="32"><span class="pp">#define CLONE_INTO_CGROUP 0x200000000ULL </span><span class="co">/* 在具有相应权限的情况下克隆到特定的 cgroup 中。 */</span></a>
<a class="sourceLine" id="cb11-33" title="33"></a>
<a class="sourceLine" id="cb11-34" title="34"><span class="co">/*</span></a>
<a class="sourceLine" id="cb11-35" title="35"><span class="co"> * 克隆标志与 CSIGNAL 交叉，因此只能与 unshare 和 clone3 系统调用一起使用:</span></a>
<a class="sourceLine" id="cb11-36" title="36"><span class="co"> */</span></a>
<a class="sourceLine" id="cb11-37" title="37"><span class="pp">#define CLONE_NEWTIME   0x00000080  </span><span class="co">/* 新的时间命名空间 */</span></a></code></pre></div>
<h2 id="内核线程"><span class="header-section-number">2.2</span> 内核线程</h2>
<p>独立运行在内核空间的进程叫内核线程（kernel thread），和普通的用户进程的区别是没有独立的地址空间，也就是<code>task_struct</code>中的<code>mm</code>成员设置为<code>NULL</code>（可使用前一个用户空间进程的<code>mm</code>，用<code>active_mm</code>指向），所有内核线程都是<code>kthreadd</code>内核线程的后代。</p>
<p>创建新的内核线程:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb12-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co"> * kthread_create - 在当前节点上创建一个内核线程，处于不可运行状态，要通过wake_up_process()唤醒</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co"> * </span><span class="an">@threadfn:</span><span class="co"> 要在线程中运行的函数</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co"> * </span><span class="an">@data:</span><span class="co"> 传递给 </span><span class="an">@threadfn()</span><span class="co"> 的数据指针</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co"> * </span><span class="an">@namefmt:</span><span class="co"> 用于线程名称的 printf 风格格式字符串</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co"> * </span><span class="an">@arg</span><span class="co">: 用于 </span><span class="an">@namefmt</span><span class="co"> 的参数</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co"> *</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co"> * 该宏将在当前节点上创建一个内核线程，并将其置于停止状态。</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co"> * 这只是 kthread_create_on_node() 的一个辅助函数；</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="co"> * 详细信息请参见 kthread_create_on_node() 的文档。</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="co"> */</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="pp">#define kthread_create(threadfn, data, namefmt, arg...) \                   </span></a>
<a class="sourceLine" id="cb12-13" title="13">        kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)</a>
<a class="sourceLine" id="cb12-14" title="14"></a>
<a class="sourceLine" id="cb12-15" title="15"><span class="co">/**</span></a>
<a class="sourceLine" id="cb12-16" title="16"><span class="co"> * wake_up_process - 唤醒特定进程，唤醒kthread_create()创建的内核线程</span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="co"> * </span><span class="an">@p</span><span class="cv">:</span><span class="co"> 要唤醒的进程</span></a>
<a class="sourceLine" id="cb12-18" title="18"><span class="co"> *</span></a>
<a class="sourceLine" id="cb12-19" title="19"><span class="co"> * 尝试唤醒指定的进程，并将其移到可运行进程集合中。</span></a>
<a class="sourceLine" id="cb12-20" title="20"><span class="co"> *</span></a>
<a class="sourceLine" id="cb12-21" title="21"><span class="co"> * 返回值: 如果进程被唤醒则返回 1，如果进程已经在运行则返回 0。</span></a>
<a class="sourceLine" id="cb12-22" title="22"><span class="co"> *</span></a>
<a class="sourceLine" id="cb12-23" title="23"><span class="co"> * 该函数在访问任务状态之前执行一个完整的内存屏障。</span></a>
<a class="sourceLine" id="cb12-24" title="24"><span class="co"> */</span></a>
<a class="sourceLine" id="cb12-25" title="25"><span class="dt">int</span> wake_up_process(<span class="kw">struct</span> task_struct *p)</a></code></pre></div>
<p>也可以调用以下函数创建内核线程并立刻运行:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb13-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="co"> * kthread_run - 创建并唤醒一个线程。简单的调用了kthread_create()和wake_up_process()</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co"> * </span><span class="an">@threadfn:</span><span class="co"> 要运行的函数，直到 signal_pending(current) 为止。</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="co"> * </span><span class="an">@data:</span><span class="co"> 传递给 </span><span class="an">@threadfn</span><span class="co"> 的数据指针。</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="co"> * </span><span class="an">@namefmt:</span><span class="co"> 线程名称的 printf 风格格式。</span></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="co"> *</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="co"> * 描述: 这是 kthread_create() 后紧跟 wake_up_process() 的便捷包装。</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="co"> * 返回值: 返回创建的内核线程指针或 ERR_PTR(-ENOMEM)。</span></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="co"> */</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="pp">#define kthread_run(threadfn, data, namefmt, ...)</span></a></code></pre></div>
<p><code>threadfn()</code>一直运行直到调用<code>do_exit()</code>退出，或内核其他部分调用以下函数退出:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb14-1" title="1"><span class="co">/**</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="co"> * kthread_stop - 停止由 kthread_create() 创建的线程。</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="co"> * </span><span class="an">@k:</span><span class="co"> 由 kthread_create() 创建的线程。</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="co"> * 设置 </span><span class="an">@k</span><span class="co"> 线程的 kthread_should_stop() 返回 true，唤醒它，并等待其退出。</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="co"> * 这也可以在 kthread_create() 之后调用，而不是调用 wake_up_process():</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="co"> * 线程将会退出而不调用 threadfn()。</span></a>
<a class="sourceLine" id="cb14-8" title="8"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="co"> * 如果 threadfn() 可能会自己调用 kthread_exit()，则调用者必须确保</span></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="co"> * task_struct 不会被释放。</span></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="co"> *</span></a>
<a class="sourceLine" id="cb14-12" title="12"><span class="co"> * 返回值: 返回 threadfn() 的结果，如果从未调用过 wake_up_process()，</span></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="co"> * 则返回 %-EINTR。</span></a>
<a class="sourceLine" id="cb14-14" title="14"><span class="co"> */</span></a>
<a class="sourceLine" id="cb14-15" title="15"><span class="dt">int</span> kthread_stop(<span class="kw">struct</span> task_struct *k)</a></code></pre></div>
<h2 id="调试-1"><span class="header-section-number">2.3</span> 调试</h2>
<p>内核打上 <a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/0001-debug-task_struct.patch"><code>0001-debug-task_struct.patch</code></a> 补丁，编译运行 <a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/pthread.c"><code>pthread.c</code></a> :</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" title="1"><span class="ex">mkfs.ext2</span> -F image</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="fu">mount</span> image /mnt</a>
<a class="sourceLine" id="cb15-3" title="3"><span class="fu">gcc</span> -o pthread pthread.c -lpthread</a>
<a class="sourceLine" id="cb15-4" title="4"><span class="ex">./pthread</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="fu">ps</span> -L -e -o pid,ppid,lwp,cmd <span class="kw">|</span> <span class="fu">grep</span> pthread <span class="co"># -L 显示线程</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="fu">ls</span> /proc/<span class="op">&lt;</span>thread pid<span class="op">&gt;</span>/task/</a></code></pre></div>
<h1 id="进程调度"><span class="header-section-number">3</span> 进程调度</h1>
<h2 id="简介-1"><span class="header-section-number">3.1</span> 简介</h2>
<p>process scheduler，简称为scheduler，翻译为进程调度器，有些中文书籍也翻译为进程调度程序，简称调度程序，注意这里的“程序”不是前面我们讲的能用<code>ps</code>命令查看的“进程”（所以“进程调度程序”这个翻译不好），而是内核的一个核心功能，直接集成在内核代码中。</p>
<p>抢占式多任务（preemptive multitasking）模式，是由调度器来决定什么时候挂起一个进程，以便其他进程能够有运行的机会，这个强制的挂起动作就叫“抢占”（preemption）。 有些调度算法中，进程在被抢占之前能够运行的时间片（timeslice）是预先设置好的，但CFS调度算法没有采用时间片来达到公平调度。</p>
<p>非抢占式多任务（cooperative multitasking）模式，除非进程主动停止运行，否则会一直执行，进程主动挂起自己的操作叫yielding，翻译为让出（cpu）或让步，可能出现不让出cpu的进程，绝大部分操作系统都采用了抢占式多任务。</p>
<p>进程分为I/O消耗型和处理器消耗型。I/O消耗型进程大部分时间都在提交I/O请求或等待I/O请求（如键盘输入、网络I/O等），经常处于可运行状态，但运行时间很短。处理器消耗型进程刚好相反，大部分时间都在执行代码，没有被抢占就一直运行，不经常运行，但一旦运行时间比较长，如执行大量数学计算的程序。当然，也可能出现某个程序在不同时间段属于不同类型的情况。</p>
<p>Linux采用两种优先级范围:</p>
<ul>
<li>nice值: -20 ~ +19，默认为0，nice代表对其他进程的友好程度，nice值越高优先级越低，有些操作系统的nice值代表分配给进程的时间片的绝对值，Linux内核的nice值代表时间片的比例。使用命令<code>ps -el</code>输出的<code>NI</code>一列就是nice值。</li>
<li>实时优先级: 0 ~ 99，任何实时进程的优先级都高于普通进程，实时优先级与nice优先级处于互不相交的两个范畴。使用命令<code>ps -eo state,uid,pid,ppid,rtprio,time,comm,nice</code>输出的<code>RTPRIO</code>一列就是实时优先级，如果是<code>-</code>就代表不是实时进程。</li>
</ul>
<p>timeslice，翻译为“时间片”（在其他系统上又称为quantum或processor slice），是进程被抢占前能持续运行的时间。时间片的长短会影响系统性能，太长交互表现差，太短又会导致进程切换的开销大。后面要介绍Linux内核现在使用的CFS调度器没有直接给进程分配时间片，而是取决于进程消耗了多少处理器使用比。</p>
<h2 id="用户空间接口"><span class="header-section-number">3.2</span> 用户空间接口</h2>
<p>nice值表示进程对其他进程的<strong>友好程度</strong>，nice值越高表示占用cpu越低。</p>
<p>nice值取值范围 0 ~ 39 （对应静态优先级）。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb16-1" title="1"><span class="dt">int</span> nice(<span class="dt">int</span> incr)</a></code></pre></div>
<p>这个接口是直接调用nice系统调用:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb17-1" title="1">SYSCALL_DEFINE1(nice, <span class="dt">int</span>, increment)</a></code></pre></div>
<p>示例文件 <a href="https://gitee.com/chenxiaosonggitee/blog/blob/master/course/kernel/src/nice.c"><code>nice.c</code></a> 。两个进程并行运行，各自增加自己的计数器。父进程使用默认nice值，子进程nice值可选。</p>
<p><code>gcc nice.c -o nice</code> 编译文件。</p>
<ul>
<li>单核cpu系统，运行 <code>./nice</code> ，nice值相等，父子进程计数值几乎相等。</li>
<li>单核cpu系统，运行 <code>./nice 20</code>，子进程nice值高，子进程的计数值极小。</li>
<li>双核或多核cpu系统，运行 <code>./nice 20</code>，子进程nice值高，但父子进程计数值几乎相等。因为父子进程不共享同一cpu，分别在不同cpu上同时运行。</li>
</ul>
<p><code>/usr/include/pthread.h</code>或<code>/usr/aarch64-linux-gnu/include/pthread.h</code>头文件中POSIX线程调度相关的函数:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb18-1" title="1">pthread_attr_setschedpolicy</a>
<a class="sourceLine" id="cb18-2" title="2">pthread_attr_getschedpolicy</a>
<a class="sourceLine" id="cb18-3" title="3">pthread_attr_getschedparam</a>
<a class="sourceLine" id="cb18-4" title="4">pthread_attr_setschedparam</a>
<a class="sourceLine" id="cb18-5" title="5">pthread_attr_getinheritsched</a>
<a class="sourceLine" id="cb18-6" title="6">pthread_attr_setinheritsched</a></code></pre></div>
<p>再列出一些调度相关的库函数，也是直接调用同名的系统调用:</p>
<ul>
<li><code>getpriority</code>: 获取进程优先级</li>
<li><code>setpriority</code>: 设置进程优先级</li>
<li><code>sched_getscheduler</code>: 获取进程的调度策略</li>
<li><code>sched_setscheduler</code>: 设置进程的调度策略</li>
<li><code>sched_getparam</code>: 获取实时优先级</li>
<li><code>sched_setparam</code>: 设置实时优先级</li>
<li><code>sched_get_priority_max</code>: 获取实时优先级的最大值</li>
<li><code>sched_get_priority_min</code>: 获取实时优先级的最小值</li>
<li><code>sched_rr_get_interval</code>: 获取进程的时间片值</li>
<li><code>sched_setaffinity</code>: 设置处理器亲和力</li>
<li><code>sched_getaffinity</code>: 获取处理器亲和力</li>
<li><code>sched_yield</code>: 暂时让出处理器</li>
</ul>
<h2 id="调度策略"><span class="header-section-number">3.3</span> 调度策略</h2>
<p><code>struct task_struct</code>中的<code>policy</code>表示调度策略。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb19-1" title="1"><span class="co">/*</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="co"> * 调度策略</span></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="co"> */</span></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="pp">#define SCHED_NORMAL            0    </span><span class="co">// 普通调度策略</span></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="pp">#define SCHED_FIFO              1    </span><span class="co">// 先入先出调度策略，运行时间比较短的进程</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="pp">#define SCHED_RR                2    </span><span class="co">// 轮转调度策略，运行时间比较长的进程</span></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="pp">#define SCHED_BATCH             3    </span><span class="co">// 批处理调度策略，cpu消耗型进程</span></a>
<a class="sourceLine" id="cb19-8" title="8"><span class="co">/* SCHED_ISO: 保留但尚未实现 */</span></a>
<a class="sourceLine" id="cb19-9" title="9"><span class="pp">#define SCHED_IDLE              5    </span><span class="co">// 空闲调度策略，极低优先级的后台进程</span></a>
<a class="sourceLine" id="cb19-10" title="10"><span class="pp">#define SCHED_DEADLINE          6    </span><span class="co">// 截止期限调度策略</span></a></code></pre></div>
<p>某个进程的调度策略可以用<code>cat /proc/&lt;pid&gt;/sched | grep policy</code>查看。</p>
<p>调试策略的具体实现用<code>struct sched_class</code>表示，可以查看宏定义<code>DEFINE_SCHED_CLASS</code>的引用。</p>
<p>比较重要的数据结构还有<code>struct rq</code>（管理可运行状态进程，表示一个可运行队列，也就是就绪队列）和<code>struct sched_entity</code>（调度器中调度实体）。</p>
<p>CFS相关的函数流程如下:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb20-1" title="1">schedule</a>
<a class="sourceLine" id="cb20-2" title="2">  __schedule</a>
<a class="sourceLine" id="cb20-3" title="3">    pick_next_task</a>
<a class="sourceLine" id="cb20-4" title="4">      __pick_next_task</a>
<a class="sourceLine" id="cb20-5" title="5">        __pick_next_task_fair <span class="co">// class-&gt;pick_next_task</span></a>
<a class="sourceLine" id="cb20-6" title="6">    context_switch</a></code></pre></div>
<p><code>set_tsk_need_resched()</code>、<code>clear_tsk_need_resched()</code>、<code>test_tsk_need_resched()</code>分别用于设置、清除、检查是否需要重新执行一次调度。</p>
<p>内核即将返回用户空间时（从系统调用返回或中断处理程序返回）会发生用户抢占。Linux内核支持内核抢占，只要没有持有锁，内核就可以抢占，也就是调度器可以挂起一个内核线程。</p>
<p>Linux内核有两种实时调度策略: <code>SCHED_FIFO</code>和<code>SCHED_RR</code>，这两种调度策略的进程比<code>SCHED_NORMAL</code>的进程优先级更高。<code>SCHED_RR</code>是带有时间片的<code>SCHED_FIFO</code>。这两种实时调度器使用静态优先级，高优先级的实时进程总能抢占低优先级进程。Linux内核是软实时，内核调度进程，尽力使进程在限定时间到来前运行，但不保证总能满足这些进程的要求，对于实时任务的调度不做任何保证，但性能还是不错的。实时优先级范围是<code>0 ~ MAX_RT_PRIO-1</code>，而<code>SCHED_NORMAL</code>进程的范围是<code>MAX_RT_PRIO ~ MAX_RT_PRIO+40</code>（对应<code>-20 ~ +19</code>的nice值）。</p>
<h2 id="on和o1调度器"><span class="header-section-number">3.4</span> O(n)和O(1)调度器</h2>
<p><strong>内核2.4</strong>版本的简陋的<strong>O(n)</strong>调度算法,进程数量多时，调度效率非常低:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb21-1" title="1"><span class="cf">for</span> (系统中的每个进程) {</a>
<a class="sourceLine" id="cb21-2" title="2">    重新计算时间片;</a>
<a class="sourceLine" id="cb21-3" title="3">    重新计算优先级;</a>
<a class="sourceLine" id="cb21-4" title="4">}</a></code></pre></div>
<p><strong>内核2.5</strong>版本引入的O(1)调度现在已经被CFS调度取代，但作为一个经典的调度算法，非常值得介绍，其他改进的调度算法都是基于O(1)调度算法。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb22-2" title="2">  <span class="kw">struct</span> prio_array 活跃进程集合，时间片未用完</a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="kw">struct</span> prio_array 过期进程集合，已经用完时间片</a>
<a class="sourceLine" id="cb22-4" title="4">} 可运行队列;</a>
<a class="sourceLine" id="cb22-5" title="5"></a>
<a class="sourceLine" id="cb22-6" title="6"><span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb22-7" title="7">  进程个数;</a>
<a class="sourceLine" id="cb22-8" title="8">  <span class="dt">uint32_t</span> 位图[<span class="dv">5</span>]; <span class="co">//160位，前140位有用，每一位代表对应的进程链表是否存在进程</span></a>
<a class="sourceLine" id="cb22-9" title="9">  进程链表[<span class="dv">140</span>]; <span class="co">//对应动态优先级0~139</span></a>
<a class="sourceLine" id="cb22-10" title="10">} prio_array; <span class="co">// 优先级数组</span></a></code></pre></div>
<p>进程从活跃数组移动到过期数组前，已经重新计算好了时间片，本质就是采用<strong>分散计算时间片</strong>的方法。当活跃进程数组中没有进程时，只需要交换两个数组的指针，原来的过期数组变为活跃数组。因此只需要<strong>依次遍历</strong>位图的第一位，找到第一个置位，对应的进程链表上的所有进程都是优先级最高的，选取链表头的进程来执行即可。</p>
<h1 id="完全公平调度器"><span class="header-section-number">4</span> 完全公平调度器</h1>
<p>Completely Fair Scheduler，翻译为“完全公平调度器”，缩写为CFS。参考了康恩·科里瓦斯所开发的楼梯调度算法（staircase scheduler）与RSDL（反转楼梯最后期限调度算法，The Rotating Staircase Deadline Schedule）的经验。</p>
<p>O(1)调度算法在进程数量不是很多在情况下（几十个）表现出近乎完美的性能。但程序数量更多时，或对响应时间敏感的程序（如需要用户交互的桌面应用），却有一些先天不足。在2.6.23版本中引入了CFS，取代了O(1)调试器。</p>
<p>CFS使用红黑树（Red-Black Tree）数据结构来管理就绪队列中的任务，算法复杂度是 O(log n)。</p>
<p>前面我们说过，CFS下进程是否投入运行取决于处理器时间使用比。我们看一个例子，在只有一个cpu的电脑上，系统运行了2个进程，一个是vim（I/O消耗型），一个是gcc（处理器消耗型），如果nice值相同，CFS承诺给这两个进程各50%的cpu使用比，但vim更多的时间在等待用户输入，所以vim肯定用不到50%的cpu使用比，而gcc肯定用到超过50%的cpu使用比。所以，当我们输入字符唤醒vim时，CFS发现vim的cpu使用更少，所以想兑现完全公平的承诺，立刻抢占gcc，让vim投入运行，我们输入完字符后，vim却还是不贪心只使用了一丢丢cpu就继续睡了。</p>
<p>进程所获得的处理器时间由这个进程和所有可运行进程nice值的相对差值决定的，nice值对应的是处理器使用比。</p>
<p>CFS实现了三种调度策略:</p>
<ul>
<li><code>SCHED_NORMAL</code>（传统上称为 <code>SCHED_OTHER</code>）: 用于常规任务的调度策略。</li>
<li><code>SCHED_BATCH</code>: 不会像常规任务那样频繁抢占，从而允许任务运行更长时间并更好地利用缓存，但代价是降低交互性。这非常适合批处理作业。</li>
<li><code>SCHED_IDLE</code>: 这比 <code>nice 19</code> 更弱，但它不是一个真正的空闲定时器调度器，以避免出现会导致机器死锁的优先级反转问题。</li>
</ul>
<p>因为<code>v6.6</code>已经合入了EEVDF调度器相关的补丁集，所以要看CFS的代码实现，要回退到稍早的版本<code>git checkout v6.5</code>。具体代码实现请查看<code>DEFINE_SCHED_CLASS(fair)</code>。</p>
<h2 id="时间记账"><span class="header-section-number">4.1</span> 时间记账</h2>
<p><code>struct task_struct</code>中有一个<code>struct sched_entity</code>类型的成员<code>se</code>。<code>struct sched_entity</code>的<code>vruntime</code>变量表示进程的虚拟运行时间（virtual runtime），这个值的计算是经过了所有可运行进程总数的标准化（被加权），可以帮助逼近CFS模型所追求的“理想多任务处理器”。</p>
<p>函数调用流程如下:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb23-1" title="1">update_process_times</a>
<a class="sourceLine" id="cb23-2" title="2">  scheduler_tick</a>
<a class="sourceLine" id="cb23-3" title="3">    task_tick_fair</a>
<a class="sourceLine" id="cb23-4" title="4">      entity_tick</a>
<a class="sourceLine" id="cb23-5" title="5">        update_curr</a>
<a class="sourceLine" id="cb23-6" title="6">          curr-&gt;vruntime += calc_delta_fair</a></code></pre></div>
<h2 id="进程选择"><span class="header-section-number">4.2</span> 进程选择</h2>
<p>CFS选择下一个运行进程时，会选择虚拟运行时间最小的进程。CFS使用红黑树来管理可运行进程队列，挑选下一个任务的流程如下:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb24-1" title="1">schedule</a>
<a class="sourceLine" id="cb24-2" title="2">  __schedule</a>
<a class="sourceLine" id="cb24-3" title="3">    pick_next_task</a>
<a class="sourceLine" id="cb24-4" title="4">      __pick_next_task</a>
<a class="sourceLine" id="cb24-5" title="5">        __pick_next_task_fair</a>
<a class="sourceLine" id="cb24-6" title="6">          pick_next_task_fair</a>
<a class="sourceLine" id="cb24-7" title="7">            pick_next_entity</a></code></pre></div>
<p>向红黑树中加入进程发生在进程变为可运行状态（被唤醒）或创建进程时，流程如下:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb25-1" title="1">activate_task</a>
<a class="sourceLine" id="cb25-2" title="2">  enqueue_task</a>
<a class="sourceLine" id="cb25-3" title="3">    enqueue_task_fair</a>
<a class="sourceLine" id="cb25-4" title="4">      enqueue_entity</a>
<a class="sourceLine" id="cb25-5" title="5">        __enqueue_entity</a>
<a class="sourceLine" id="cb25-6" title="6">          rb_add_augmented_cached</a>
<a class="sourceLine" id="cb25-7" title="7">            rb_insert_augmented_cached</a>
<a class="sourceLine" id="cb25-8" title="8">              <span class="co">// 维护一个缓存，存放最左叶子节点</span></a>
<a class="sourceLine" id="cb25-9" title="9">              root-&gt;rb_leftmost = node</a></code></pre></div>
<p>从红黑树中删除进程发生在进程变为不可进行或进程终结时，流程如下:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb26-1" title="1">pick_next_task_fair</a>
<a class="sourceLine" id="cb26-2" title="2">  set_next_entity</a>
<a class="sourceLine" id="cb26-3" title="3">    __dequeue_entity</a></code></pre></div>
<h1 id="eevdf调度器"><span class="header-section-number">5</span> EEVDF调度器</h1>
<ul>
<li>补丁集: <a href="https://chenxiaosong.com/course/kernel/patch/sched-EEVDF-and-latency-nice-and-or-slice-attr.html"><code>sched: EEVDF and latency-nice and/or slice-attr</code></a>。</li>
<li>文档<a href="https://chenxiaosong.com/src/translation/kernel/sched-eevdf.html">EEVDF Scheduler</a>翻译。</li>
</ul>
<p>CFS已经在v6.6被EEVDF (Earliest Eligible Virtual Deadline First，最早可用虚拟截止时间优先) 调度器取代，每个进程有一个虚拟截止时间，代表应该运行完成的时间，EEVDF调度器优先选择虚拟截止时间最早的进程运行，虚拟截止时间取决于进程优先级和已经获得的cpu时间，可以保证延迟敏感的进程及时得到cpu时间。和CFS一样，时间片根据进程的优先级和已使用的 CPU 时间进行综合动态调整。</p>
<p>挑选下一个任务的流程如下:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb27-1" title="1">schedule</a>
<a class="sourceLine" id="cb27-2" title="2">  __schedule</a>
<a class="sourceLine" id="cb27-3" title="3">    pick_next_task</a>
<a class="sourceLine" id="cb27-4" title="4">      __pick_next_task</a>
<a class="sourceLine" id="cb27-5" title="5">        __pick_next_task_fair</a>
<a class="sourceLine" id="cb27-6" title="6">          pick_next_task_fair</a>
<a class="sourceLine" id="cb27-7" title="7">            pick_next_entity</a>
<a class="sourceLine" id="cb27-8" title="8">              pick_eevdf</a>
<a class="sourceLine" id="cb27-9" title="9">                __pick_eevdf</a></code></pre></div>
<h1 id="休眠和唤醒"><span class="header-section-number">6</span> 休眠和唤醒</h1>
<p>内核用<code>wait_queue_entry</code>表示等待队列，静态创建可以用<code>DECLARE_WAITQUEUE()</code>，动态创建可以用<code>init_waitqueue_head()</code>。</p>
<p>休眠操作如下:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb28-1" title="1"><span class="co">// wq 是等待队列</span></a>
<a class="sourceLine" id="cb28-2" title="2">DEFINE_WAIT(wait); <span class="co">// 或者用 init_wait()</span></a>
<a class="sourceLine" id="cb28-3" title="3">add_wait_queue(&amp;wq, &amp;wait); <span class="co">// 在其他地方用 wake_up()唤醒</span></a>
<a class="sourceLine" id="cb28-4" title="4"><span class="cf">while</span> (!condition) <span class="co">// condition是等待的事件</span></a>
<a class="sourceLine" id="cb28-5" title="5">        prepare_to_wait(&amp;wq, &amp;wait, TASK_INTERRUPTIBLE);</a>
<a class="sourceLine" id="cb28-6" title="6">        <span class="cf">if</span> (signal_pending(current)) {</a>
<a class="sourceLine" id="cb28-7" title="7">                <span class="co">// 处理信号</span></a>
<a class="sourceLine" id="cb28-8" title="8">        }</a>
<a class="sourceLine" id="cb28-9" title="9">        schedule();</a>
<a class="sourceLine" id="cb28-10" title="10">}</a>
<a class="sourceLine" id="cb28-11" title="11">finish_wait(&amp;wq, &amp;wait);</a></code></pre></div>
<p><code>inotify_read()</code>函数中相关代码:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb29-1" title="1">DEFINE_WAIT_FUNC(wait, woken_wake_function);</a>
<a class="sourceLine" id="cb29-2" title="2">add_wait_queue(&amp;group-&gt;notification_waitq, &amp;wait);</a>
<a class="sourceLine" id="cb29-3" title="3"><span class="cf">while</span> (<span class="dv">1</span>) {</a>
<a class="sourceLine" id="cb29-4" title="4">        <span class="cf">if</span> (condition)</a>
<a class="sourceLine" id="cb29-5" title="5">                <span class="cf">break</span>; <span class="co">// condition是等待的事件</span></a>
<a class="sourceLine" id="cb29-6" title="6">        <span class="cf">if</span> (signal_pending(current))</a>
<a class="sourceLine" id="cb29-7" title="7">                <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb29-8" title="8">        wait_woken(&amp;wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</a>
<a class="sourceLine" id="cb29-9" title="9">}</a>
<a class="sourceLine" id="cb29-10" title="10">remove_wait_queue(&amp;group-&gt;notification_waitq, &amp;wait);</a></code></pre></div>
<p>用<code>wake_up(struct wait_queue_head *wq_head)</code>唤醒。</p>
<h1 id="多处理器系统中的运行队列平衡"><span class="header-section-number">7</span> 多处理器系统中的运行队列平衡</h1>
<p>多处理器机器有以下几种类型:</p>
<ul>
<li>标准的多处理器体系结构: 采用对称多处理（Symmetric Multi Processing，SMP），每个cpu都参与调度操作系统的所有任务。每个cpu有自己的寄存器集，也有自己的高速缓存，但RAM芯片集被所有cpu共享。</li>
<li>超线程: intel发明的，当前线程在访问内存的间隙，处理器可以使用它的机器周期支执行另一个线程。一个超线程的物理cpu可以被Linux看作几个不同的逻辑cpu。</li>
<li>NUMA: Non-Uniform Memory Access，非统一内存访问，把cpu和RAM以本地“节点”为单位分组。当cpu访问与它在同一个节点中的“本地”RAM，几乎没有竞争，访问非常快。</li>
</ul>
<p>可以使用<code>lscpu</code>命令查看，<code>Thread(s) per core</code>代表每个核心的线程数，如果大于1，说明启用了超线程；<code>NUMA node(s)</code>表示NUMA节点的数量，如果只有一个节点，则表明不是NUMA架构，内存是所有CPU共享的。</p>
<p><code>schedule()</code>函数从本地cpu运行队列中挑选进程运行，每个cpu有自己的运行队列，一个可运行进程只在一个队列中。</p>
<p>“调度域”（scheduling domain），是一个cpu集合，采取分层组织形式，最上层调度域（所有cpu）包括多个子调度域，子调度域包括一个cpu子集。底层某个调度域（基本调度域）的某个组的总工作量远远低于同一个调度域的另一个组时，开始迁移进程。调度域用<code>struct sched_domain</code>表示，调度域中的组用<code>struct sched_group</code>表示。<code>struct sched_group</code>中的<code>cpumask</code>数组表示这个组的cpu，再使用<code>cpu_rq()</code>获取运行队列。</p>
<p>相关函数请查看v6.6的<code>run_rebalance_domains()</code>（在v6.10-rc1已重命名成<code>sched_balance_softirq()</code>）。</p>
<h1 id="其他调度器"><span class="header-section-number">8</span> 其他调度器</h1>
<h2 id="bfs"><span class="header-section-number">8.1</span> BFS</h2>
<p>Brain Fuck Scheduler, 脑残调度器，由澳洲麻醉师康恩·科里瓦斯所撰写，是O(n)调度器，但在桌面交互式应用场景性能很好。科里瓦斯并没有打算将BFS应用在 mainline Linux，<a href="http://ck.kolivas.org/patches/5.0/5.12/5.12-ck1/">而是以补丁来维护这套源代码</a>。</p>
<p>直接附上维斯百科对他的介绍吧:</p>
<blockquote>
<p>康恩·科里瓦斯（英语: Con Kolivas）是一名澳洲麻醉师。闲暇时，他曾是Linux内核的开发者之一，在排程器上贡献许多程式码。</p>
</blockquote>
<blockquote>
<p>科里瓦斯是一位职业麻醉师, 同时也是Linux爱好者，据其本人表示，他刚接触Linux内核时甚至没有学习过C语言。他曾开发Linux内核所使用的楼梯调度算法（Staircase Deadline Scheduler）与RSDL（The Rotating Staircase Deadline Schedule）。早期他为Linux kernel编写的补丁都标记为xxx-ck，并由匈牙利程式员英格·蒙内负责审阅。由于林纳斯·托瓦兹改采蒙内撰写的完全公平排程器（CFS）取代Con Kolivas的调度器，并于2.6.23内核采用，出现很大争论。为此科里瓦斯曾一度退出Linux kernel团队。2007年, 科里瓦斯在《澳大利亚个人电脑》杂志上发表了一篇文章，说明自己为什么退出Linux开发。</p>
</blockquote>
<blockquote>
<p>2009年8月31日, 科里瓦斯卷土重来，打造了全新的排程器，并命名为脑残排程器（BFS）BFS调度器的原理十分简单，是为桌面交互式应用量身打造，使得用户的桌面环境更为流畅，过去使用CFS编译内核时，音频视频同时出现会出现严重的停顿，而使用BFS则没有这些问题。Android曾经在试验性的分支，使用BFS作为其操作系统排程器。但是经过测试发现对使用者并没有明显的改进，因此并未合入之后发表的正式版本。</p>
</blockquote>
<blockquote>
<p>2011年7月13日，科里瓦斯又推出一全新软件，名之为cgminer，用于探勘比特币和莱特币等加密电子货币。</p>
</blockquote>
<h2 id="extensible-scheduler-class"><span class="header-section-number">8.2</span> Extensible Scheduler Class</h2>
<ul>
<li>文档<a href="https://chenxiaosong.com/src/translation/kernel/sched-ext.html">Extensible Scheduler Class</a>翻译</li>
</ul>
<p>代码位于内核仓库的<code>tools/sched_ext/</code>目录下。</p>
<h1 id="硬实时"><span class="header-section-number">9</span> 硬实时</h1>
<p>维基百科上对实时操作系统的一些描述:</p>
<blockquote>
<p>实时操作系统（Real-time operating system, RTOS），又称即时操作系统，它会按照排序执行、管理系统资源，并为开发应用程序提供一致的基础。</p>
</blockquote>
<blockquote>
<p>实时操作系统与一般的操作系统相比，最大的特色就是“实时性”，如果有一个任务需要执行，实时操作系统会马上（在较短时间内）执行该任务，不会有较长的延时。这种特性保证了各个任务的及时执行。</p>
</blockquote>
<blockquote>
<p>设计实时操作系统的首要目标不是高的吞吐量，而是保证任务在特定时间内完成，因此衡量一个实时操作系统坚固性的重要指标，是系统从接收一个任务，到完成该任务所需的时间，其时间的变化称为抖动。可以依抖动将实时操作系统分为两种：硬实时操作系统及软实时操作系统，硬实时操作系统比软实时操作系统有更少的抖动：</p>
</blockquote>
<blockquote>
<ul>
<li>硬实时操作系统必须使任务在确定的时间内完成。</li>
<li>软实时操作系统能让绝大多数任务在确定时间内完成。</li>
</ul>
</blockquote>
<blockquote>
<p>实时操作系统与一般的操作系统有着不同的调度算法。普通的操作系统的调度器对于线程优先级等方面的处理更加灵活；而实时操作系统追求最小的中断延时和线程切换延时。</p>
</blockquote>
<blockquote>
<p>PREEMPT_RT 是一组针对 Linux 内核的补丁，旨在实现硬实时和软实时计算功能，而微软 Windows 仍然是软实时内核。2024 年 9 月 20 日，PREEMPT_RT 在支持的架构 x86、x86_64、RISC-V 和 ARM64 上被完全合并并在主线 Linux 中启用。</p>
</blockquote>
<blockquote>
<p>PREEMPT_RT 补丁集自 2005 年起开始开发。在 2021 年，抢占核心的锁定代码已被合并。</p>
</blockquote>
<blockquote>
<p>自 2023 年 2 月起，Canonical 已经开始发布实时版本的 Ubuntu Pro，个人和小规模商业使用可以免费在最多 5 台机器上运行。实时内核可以通过启用过程添加到各种现有的 Ubuntu 版本中。这些内核包含了 PREEMPT_RT 补丁集并提供长期支持。</p>
</blockquote>
<blockquote>
<p>MontaVista Software 自 2000 年初以来一直发布包含 PREEMPT_RT 补丁集的实时 Linux 发行版。MontaVista 目前的主要嵌入式 Linux 产品 CGX 将实时抢占作为标准功能。</p>
</blockquote>
<blockquote>
<p>在 2024 年 9 月的欧洲开源峰会上，Linus Torvalds 宣布 PREEMPT_RT 已被接受到主线 Linux 内核中，此前经过了与 printk 内核日志功能相关的长期开发难题。</p>
</blockquote>
<div class="sourceCode" id="cb30"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb30-1" title="1"><span class="ex">commit</span> baeb9a7d8b60b021d907127509c44507539c15e5</a>
<a class="sourceLine" id="cb30-2" title="2"><span class="ex">Merge</span>: 2004cef11ea07 2638e4e6b1823</a>
<a class="sourceLine" id="cb30-3" title="3"><span class="ex">Author</span>: Linus Torvalds <span class="op">&lt;</span>torvalds@linux-foundation.org<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="ex">Date</span>:   Fri Sep 20 06:04:27 2024 +0200</a>
<a class="sourceLine" id="cb30-5" title="5"></a>
<a class="sourceLine" id="cb30-6" title="6">    <span class="ex">Merge</span> tag <span class="st">&#39;sched-rt-2024-09-17&#39;</span> of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip</a>
<a class="sourceLine" id="cb30-7" title="7"></a>
<a class="sourceLine" id="cb30-8" title="8">    <span class="ex">Pull</span> RT enablement from Thomas Gleixner:</a>
<a class="sourceLine" id="cb30-9" title="9">     <span class="st">&quot;在支持的架构上启用PREEMPT_RT：</span></a>
<a class="sourceLine" id="cb30-10" title="10"><span class="st">      经过二十年的开发，我们终于达到了在主线内核中启用PREEMPT_RT支持的阶段。</span></a>
<a class="sourceLine" id="cb30-11" title="11"><span class="st">      所有先决条件已经合并，因此在支持的架构ARM64、RISCV和X86（32/64位）上启用它。&quot;</span></a>
<a class="sourceLine" id="cb30-12" title="12"></a>
<a class="sourceLine" id="cb30-13" title="13">    <span class="ex">*</span> tag <span class="st">&#39;sched-rt-2024-09-17&#39;</span> of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:</a>
<a class="sourceLine" id="cb30-14" title="14">      <span class="ex">riscv</span>: Allow to enable PREEMPT_RT.</a>
<a class="sourceLine" id="cb30-15" title="15">      <span class="ex">arm64</span>: Allow to enable PREEMPT_RT.</a>
<a class="sourceLine" id="cb30-16" title="16">      <span class="ex">x86</span>: Allow to enable PREEMPT_RT.</a></code></pre></div>
<p><a href="https://lore.kernel.org/all/20240906111841.562402-1-bigeasy@linutronix.de/"><code>[PATCH 0/3] Allow to enable PREEMPT_RT.</code></a>:</p>
<pre><code>printk 相关的补丁已经合并到 linux-next，这是 PREEMPT_RT 的最后一个已知障碍。RT 队列中还有针对 8250 UART 的“原子控制台”功能，但这还没有进入 linux-next。这意味着“传统控制台”行为，即在紧急情况下无法从原子上下文中打印。目前，8250 UART 驱动程序是唯一提供“原子控制台”支持的驱动程序。

随着 printk 相关补丁的合并，PREEMPT_RT 可以在 X86、ARM64 和 Risc-V 上启用。这三个架构多年来都合并了所需的变更，目前我手头上没有影响这些架构的关键更改。

ARM 和 POWERPC 还有一些关键补丁需要完成，我已经不太清楚 MIPS 的进展了。</code></pre>
<p><a href="https://lore.kernel.org/all/20240904120536.115780-1-john.ogness@linutronix.de/"><code>[PATCH printk v6 00/17] add threaded printing + the rest</code></a>:</p>
<pre><code>你好，

这是实现线程化控制台打印和一些其他小功能（例如 nbcon 控制台的 proc 和 sysfs 识别）的第六版系列补丁。第五版可在[0]处找到。

关于 nbcon 控制台的动机，请参考最初第一版的封面信[1]。

该系列补丁提供了 printk 重构的剩余部分。其他组件要么已经合并到主线，要么目前在 linux-next 中。特别是这个系列实现了以下功能：

- 为每个 nbcon 控制台实现专用打印线程。
  
- 为 PREEMPT_RT 强制线程化传统控制台。
  
- 为与控制台相关的 proc 和 sysfs 文件实现 nbcon 支持。
  
- 提供了一个新帮助函数 `nbcon_reacquire_nobuf()`，允许 nbcon 控制台驱动重新获取所有权。

请注意，这个系列**不**提供 nbcon 控制台驱动程序。这将在后续系列中提供。

以下是自第五版以来的更改：

- 在 `nbcon_kthreads_wake()` 中，跳过 `!CON_NBCON` 控制台。

- 在 `console_flush_all()` 中，如果 `ft.nbcon_atomic == true`，同样跳过 nbcon 控制台，并改进了注释解释原因。

- 在 `legacy_kthread_should_wakeup()` 中，如果 `ft.nbcon_atomic == true`，同样跳过 nbcon 控制台，并改进了注释解释原因。

John Ogness

[0] https://lore.kernel.org/lkml/20240830152916.10136-1-john.ogness@linutronix.de

[1] https://lore.kernel.org/lkml/20230302195618.156940-1-john.ogness@linutronix.de</code></pre>
</body>
</html>
